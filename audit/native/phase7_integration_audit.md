# Phase 7: Integration Audit

**Date**: February 2026
**Status**: Complete (infrastructure ready, translator integration pending)

---

## Overview

Phase 7 wired together all Cranelift-ported components into a cohesive native code generation pipeline.

## Components Implemented

### 1. compile.zig - Main Orchestration (~600 LOC)

**Location**: `compiler/codegen/native/compile.zig`

**Status**: Complete

Implements the top-level `compile()` function that orchestrates:
- Target ISA selection (ARM64/x64)
- VCode adapter for register allocation
- Backend interfaces

Key types:
- `TargetIsa` - Union for AArch64Backend and X64Backend
- `CompiledCode` - Result with machine code buffer and metadata
- `VCodeAdapter` - Bridge between VCode and regalloc Function interface

### 2. VCode emit() Method

**Location**: `compiler/codegen/native/machinst/vcode.zig`

**Status**: Complete

Added `emit()` method to VCode that:
- Iterates through blocks in order
- Gets allocations for each instruction from regalloc output
- Calls `emitWithAllocs()` on each instruction
- Produces finalized machine code buffer

Key types:
- `EmitResult` - Contains buffer, frame_size, block offsets
- `RegallocOutput` - Provides instruction allocations
- `EmitInfo` - Target-specific encoding settings

### 3. ARM64 emitWithAllocs() (~800 LOC)

**Location**: `compiler/codegen/native/isa/aarch64/inst/mod.zig`

**Status**: Complete

Handles all ARM64 instruction variants:
- ALU operations (rrr, rrrr, rr_imm12, rr_imm_logic, etc.)
- Load/store operations (uload8..uload64, store8..store64, load_p64, store_p64)
- Move operations (mov, mov_wide, movk, mov_from_preg, mov_to_preg)
- Conditional operations (csel, csneg, cset, csetm, ccmp)
- FPU operations (fpu_rr, fpu_rrr, fpu_rrrr, fpu_round, fpu_cmp)
- Control flow (jump, cond_br, test_bit_and_branch, indirect_br)
- Atomic operations (atomic_rmw, atomic_cas, ldaxr, stlxr, etc.)
- Vector operations (vec_rrr, vec_misc, vec_shift_imm, etc.)

Helper functions:
- `applyAlloc()` - Apply allocation to Reg
- `applyAllocWritable()` - Apply allocation to Writable(Reg)
- `applyAllocAMode()` - Apply allocations to addressing modes
- `applyAllocPairAMode()` - Apply allocations to pair addressing modes

### 4. x64 emitWithAllocs() (~800 LOC)

**Location**: `compiler/codegen/native/isa/x64/inst/mod.zig`

**Status**: Complete

Handles all x86-64 instruction variants:
- Move instructions (mov_r_r, mov_from_preg, mov_to_preg, imm, movzx, movsx)
- ALU instructions (alu_rmi_r, unary_rm_r, shift_r, mul, div, sign_extend_data)
- Load/store (mov_r_m, mov_m_r, lea, push64, pop64)
- Comparison (cmp_rmi_r, test_rmi_r, setcc, cmove)
- Control flow (jmp_known, jmp_cond, jmp_table_seq, jmp_unknown)
- XMM operations (xmm_rm_r, xmm_unary_rm_r, xmm_cmp_rm_r, xmm_mov_r_m, etc.)
- Conversion (xmm_to_gpr, gpr_to_xmm, cvt_int_to_float, cvt_float_to_int)
- Pseudo-instructions (checked_srem_seq, cvt_uint64_to_float_seq, etc.)

Helper functions:
- `applyAllocGpr()` - Apply allocation to Gpr
- `applyAllocWritableGpr()` - Apply allocation to WritableGpr
- `applyAllocXmm()` - Apply allocation to Xmm
- `applyAllocWritableXmm()` - Apply allocation to WritableXmm
- `applyAllocSyntheticAmode()` - Apply allocations to addressing modes
- `applyAllocAmode()` - Apply allocations to base Amode

### 5. Driver Integration

**Location**: `compiler/driver.zig`

**Status**: Complete

Added native codegen path:
- Imports for native modules (compile, wasm_parser, wasm_to_clif, macho, elf)
- `generateNativeCode()` function that:
  - Parses Wasm module from generated bytes
  - Reports target platform (ARM64/x64, macOS/Linux)
  - Currently returns `error.NativeCodegenNotImplemented` (translator integration pending)

---

## Test Results

All tests pass (386/405 with 19 skipped).

The 19 skipped tests are native codegen tests that require:
- Full Wasm→CLIF translation
- Complete function compilation through the pipeline

---

## Remaining Work

### Wasm→CLIF Translator Integration

The translator infrastructure exists in `compiler/codegen/native/wasm_to_clif/`:
- `translator.zig` - Opcode translation logic
- `func_translator.zig` - Function-level translation
- `stack.zig` - Value and control stack management

Integration needed:
1. Wire `FuncTranslator` to consume `wasm_parser.FuncCode`
2. Connect output CLIF IR to `compile.compile()`
3. Handle function calls across the module

### Linker Integration

Object file generation is ready:
- `macho.zig` - Mach-O format for macOS
- `elf.zig` - ELF format for Linux

Integration needed:
1. Collect compiled function results
2. Generate object file with relocations
3. Wire to system linker (clang)

---

## Architecture Summary

```
Cot Source
    ↓
Parser → AST
    ↓
Checker → Typed AST
    ↓
Lowerer → IR
    ↓
SSA Builder → SSA
    ↓
Wasm Passes → Lower to Wasm ops
    ↓
Wasm Codegen → Wasm bytes
    ↓
=== NATIVE PATH (Phase 7) ===
    ↓
wasm_parser → WasmModule
    ↓
wasm_to_clif → CLIF Function [PENDING]
    ↓
compile.compile():
    ├─ BlockLoweringOrder
    ├─ Lower::lower() → VCode (vregs)
    ├─ regalloc::run() → Output
    └─ VCode::emit() → MachBuffer [COMPLETE]
    ↓
macho/elf → Object file [READY]
    ↓
clang → Executable [READY]
```

---

## Files Modified/Created

| File | Status | LOC |
|------|--------|-----|
| `compile.zig` | Created | ~600 |
| `machinst/vcode.zig` | Modified | +300 |
| `isa/aarch64/inst/mod.zig` | Modified | +800 |
| `isa/x64/inst/mod.zig` | Modified | +800 |
| `driver.zig` | Modified | +100 |

**Total**: ~2,600 LOC
