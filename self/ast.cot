// ast — Abstract Syntax Tree node definitions.
// Ported from compiler/frontend/ast.zig

// ============================================================================
// Node index — reference AST nodes by position in the node array
// ============================================================================

const null_node: int = 0xFFFFFFFF

// ============================================================================
// Span — source location tracking (inlined from source.cot)
// ============================================================================

struct Span {
    start: int,
    end: int,
}


// ============================================================================
// Declarations
// ============================================================================

const StructLayout = enum { auto, @"packed", @"extern" }

struct FnDecl {
    name: string,
    return_type: int,
    body: int,
    is_extern: bool,
    is_async: bool,
    doc_comment: string,
    span: Span,
}

struct VarDecl {
    name: string,
    type_expr: int,
    value: int,
    is_const: bool,
    doc_comment: string,
    span: Span,
}

struct StructDecl {
    name: string,
    layout: int,
    doc_comment: string,
    span: Span,
}

struct EnumDecl {
    name: string,
    backing_type: int,
    doc_comment: string,
    span: Span,
}

struct UnionDecl {
    name: string,
    doc_comment: string,
    span: Span,
}

struct TypeAlias {
    name: string,
    target: int,
    doc_comment: string,
    span: Span,
}

struct ImportDecl {
    path: string,
    span: Span,
}

struct ImplBlock {
    type_name: string,
    doc_comment: string,
    span: Span,
}

struct TraitDecl {
    name: string,
    doc_comment: string,
    span: Span,
}

struct ImplTraitBlock {
    trait_name: string,
    target_type: string,
    doc_comment: string,
    span: Span,
}

struct ErrorSetDecl {
    name: string,
    doc_comment: string,
    span: Span,
}

struct TestDecl {
    name: string,
    body: int,
    span: Span,
}

struct BenchDecl {
    name: string,
    body: int,
    span: Span,
}

struct BadDecl {
    span: Span,
}

// Helper types for declarations
struct Field {
    name: string,
    type_expr: int,
    default_value: int,
    doc_comment: string,
    span: Span,
}

struct EnumVariant {
    name: string,
    value: int,
    span: Span,
}

struct UnionVariant {
    name: string,
    type_expr: int,
    span: Span,
}

// Decl — top-level construct in a Cot source file.
// Zig: pub const Decl = union(enum) { fn_decl: FnDecl, ... };
union Decl {
    fn_decl: FnDecl,
    var_decl: VarDecl,
    struct_decl: StructDecl,
    enum_decl: EnumDecl,
    union_decl: UnionDecl,
    type_alias: TypeAlias,
    import_decl: ImportDecl,
    impl_block: ImplBlock,
    trait_decl: TraitDecl,
    impl_trait: ImplTraitBlock,
    error_set_decl: ErrorSetDecl,
    test_decl: TestDecl,
    bench_decl: BenchDecl,
    bad_decl: BadDecl,
}

fn declSpan(d: Decl) Span {
    switch d {
        Decl.fn_decl |v| => { return v.span },
        Decl.var_decl |v| => { return v.span },
        Decl.struct_decl |v| => { return v.span },
        Decl.enum_decl |v| => { return v.span },
        Decl.union_decl |v| => { return v.span },
        Decl.type_alias |v| => { return v.span },
        Decl.import_decl |v| => { return v.span },
        Decl.impl_block |v| => { return v.span },
        Decl.trait_decl |v| => { return v.span },
        Decl.impl_trait |v| => { return v.span },
        Decl.error_set_decl |v| => { return v.span },
        Decl.test_decl |v| => { return v.span },
        Decl.bench_decl |v| => { return v.span },
        Decl.bad_decl |v| => { return v.span },
    }
}

// ============================================================================
// Expressions
// ============================================================================

const LiteralKind = enum {
    @"int", @"float", @"string", char,
    true_lit, false_lit, null_lit, undefined_lit, unreachable_lit,
}

struct Ident { name: string, span: Span }
struct Literal { kind: int, value: string, span: Span }
struct Binary { op: int, left: int, right: int, span: Span }
struct Unary { op: int, operand: int, span: Span }
struct Call { callee: int, span: Span }
struct Index { base: int, idx: int, span: Span }
struct SliceExpr { base: int, start: int, end: int, span: Span }
struct FieldAccess { base: int, field: string, span: Span }
struct ArrayLiteral { span: Span }
struct Paren { inner: int, span: Span }
struct IfExpr { condition: int, then_branch: int, else_branch: int, capture: string, span: Span }
struct SwitchExpr { subject: int, else_body: int, span: Span }
struct SwitchCase { capture: string, guard: int, is_range: bool, body: int, span: Span }
struct BlockExpr { expr: int, span: Span }
struct StructInit { type_name: string, span: Span }
struct FieldInit { name: string, value: int, span: Span }
struct NewExpr { type_name: string, is_constructor: bool, span: Span }
struct BuiltinCall { kind: int, type_arg: int, span: Span }
struct StringInterp { span: Span }
struct TypeExpr { span: Span }
struct TryExpr { operand: int, span: Span }
struct AwaitExpr { operand: int, span: Span }
struct CatchExpr { operand: int, capture: string, fallback: int, span: Span }
struct ErrorLiteral { error_name: string, span: Span }
struct ClosureExpr { return_type: int, body: int, span: Span }
struct TupleLiteral { span: Span }
struct ComptimeBlock { body: int, span: Span }
struct ZeroInit { span: Span }
struct AddrOf { operand: int, span: Span }
struct Deref { operand: int, span: Span }
struct BadExpr { span: Span }

// Expr — any expression node.
// Zig: pub const Expr = union(enum) { ident: Ident, literal: Literal, ... };
union Expr {
    ident: Ident,
    literal: Literal,
    binary: Binary,
    unary: Unary,
    call: Call,
    index: Index,
    slice_expr: SliceExpr,
    field_access: FieldAccess,
    array_literal: ArrayLiteral,
    paren: Paren,
    if_expr: IfExpr,
    switch_expr: SwitchExpr,
    block_expr: BlockExpr,
    struct_init: StructInit,
    new_expr: NewExpr,
    builtin_call: BuiltinCall,
    string_interp: StringInterp,
    type_expr: TypeExpr,
    try_expr: TryExpr,
    await_expr: AwaitExpr,
    catch_expr: CatchExpr,
    error_literal: ErrorLiteral,
    closure_expr: ClosureExpr,
    tuple_literal: TupleLiteral,
    comptime_block: ComptimeBlock,
    zero_init: ZeroInit,
    addr_of: AddrOf,
    deref: Deref,
    bad_expr: BadExpr,
}

fn exprSpan(e: Expr) Span {
    switch e {
        Expr.ident |v| => { return v.span },
        Expr.literal |v| => { return v.span },
        Expr.binary |v| => { return v.span },
        Expr.unary |v| => { return v.span },
        Expr.call |v| => { return v.span },
        Expr.index |v| => { return v.span },
        Expr.slice_expr |v| => { return v.span },
        Expr.field_access |v| => { return v.span },
        Expr.array_literal |v| => { return v.span },
        Expr.paren |v| => { return v.span },
        Expr.if_expr |v| => { return v.span },
        Expr.switch_expr |v| => { return v.span },
        Expr.block_expr |v| => { return v.span },
        Expr.struct_init |v| => { return v.span },
        Expr.new_expr |v| => { return v.span },
        Expr.builtin_call |v| => { return v.span },
        Expr.string_interp |v| => { return v.span },
        Expr.type_expr |v| => { return v.span },
        Expr.try_expr |v| => { return v.span },
        Expr.await_expr |v| => { return v.span },
        Expr.catch_expr |v| => { return v.span },
        Expr.error_literal |v| => { return v.span },
        Expr.closure_expr |v| => { return v.span },
        Expr.tuple_literal |v| => { return v.span },
        Expr.comptime_block |v| => { return v.span },
        Expr.zero_init |v| => { return v.span },
        Expr.addr_of |v| => { return v.span },
        Expr.deref |v| => { return v.span },
        Expr.bad_expr |v| => { return v.span },
    }
}

// ============================================================================
// Statements
// ============================================================================

struct ExprStmt { expr: int, span: Span }
struct ReturnStmt { value: int, span: Span }
struct VarStmt { name: string, type_expr: int, value: int, is_const: bool, is_weak: bool, span: Span }
struct AssignStmt { target: int, op: int, value: int, span: Span }
struct IfStmt { condition: int, then_branch: int, else_branch: int, capture: string, span: Span }
struct WhileStmt { condition: int, body: int, capture: string, continue_expr: int, span: Span }
struct ForStmt {
    binding: string,
    iterable: int,
    range_start: int,
    range_end: int,
    body: int,
    is_inline: bool,
    span: Span,
}
struct BlockStmt { span: Span }
struct BreakStmt { span: Span }
struct ContinueStmt { span: Span }
struct DeferStmt { expr: int, is_errdefer: bool, span: Span }
struct DestructureBinding { name: string, type_expr: int, span: Span }
struct DestructureStmt { value: int, is_const: bool, span: Span }
struct BadStmt { span: Span }

// Stmt — any statement node.
// Zig: pub const Stmt = union(enum) { expr_stmt: ExprStmt, ... };
union Stmt {
    expr_stmt: ExprStmt,
    return_stmt: ReturnStmt,
    var_stmt: VarStmt,
    assign_stmt: AssignStmt,
    if_stmt: IfStmt,
    while_stmt: WhileStmt,
    for_stmt: ForStmt,
    block_stmt: BlockStmt,
    break_stmt: BreakStmt,
    continue_stmt: ContinueStmt,
    defer_stmt: DeferStmt,
    destructure_stmt: DestructureStmt,
    bad_stmt: BadStmt,
}

fn stmtSpan(s: Stmt) Span {
    switch s {
        Stmt.expr_stmt |v| => { return v.span },
        Stmt.return_stmt |v| => { return v.span },
        Stmt.var_stmt |v| => { return v.span },
        Stmt.assign_stmt |v| => { return v.span },
        Stmt.if_stmt |v| => { return v.span },
        Stmt.while_stmt |v| => { return v.span },
        Stmt.for_stmt |v| => { return v.span },
        Stmt.block_stmt |v| => { return v.span },
        Stmt.break_stmt |v| => { return v.span },
        Stmt.continue_stmt |v| => { return v.span },
        Stmt.defer_stmt |v| => { return v.span },
        Stmt.destructure_stmt |v| => { return v.span },
        Stmt.bad_stmt |v| => { return v.span },
    }
}

// ============================================================================
// Unified Node
// ============================================================================

// Node — any AST node (declaration, expression, or statement).
// Zig: pub const Node = union(enum) { decl: Decl, expr: Expr, stmt: Stmt };
union Node {
    decl: Decl,
    expr: Expr,
    stmt: Stmt,
}

fn nodeSpan(n: Node) Span {
    switch n {
        Node.decl |d| => { return declSpan(d) },
        Node.expr |e| => { return exprSpan(e) },
        Node.stmt |s| => { return stmtSpan(s) },
    }
}

// ============================================================================
// BuiltinKind — all @builtin function variants
// ============================================================================

const BuiltinKind = enum {
    // Type intrinsics
    size_of, align_of, enum_len,
    // Casts
    int_cast, float_cast, float_from_int, int_from_float,
    ptr_cast, int_to_ptr, ptr_to_int,
    // String construction
    @"string",
    // Assertions
    assert, assert_eq,
    // Memory
    alloc, dealloc, realloc, memcpy,
    // WASI file I/O
    fd_write, fd_read, fd_close, fd_seek, fd_open,
    // String decomposition
    ptr_of, len_of,
    // Process control
    trap, exit,
    // Time/random
    time, random,
    // CLI args
    args_count, arg_len, arg_ptr,
    // Environment
    environ_count, environ_len, environ_ptr,
    // Comptime targets
    target_os, target_arch, target,
    // Compile-time
    compile_error,
    // Math (float unary)
    abs, ceil, floor, @"trunc", round, sqrt,
    // Math (float binary)
    fmin, fmax,
    // Networking (TCP sockets)
    net_socket, net_bind, net_listen, net_accept, net_connect, net_set_reuse_addr,
    // Event loop (kqueue/epoll)
    kqueue_create, kevent_add, kevent_del, kevent_wait,
    epoll_create, epoll_add, epoll_del, epoll_wait, set_nonblocking,
    // Process spawning
    fork, execve, waitpid, pipe, dup2,
    // Compile-time file embedding
    embed_file,
    // Reflection builtins
    has_field, type_of, field,
    // Enum/error intrinsics
    int_from_enum, enum_from_int, tag_name, error_name, int_from_bool,
    // Cast intrinsics
    bit_cast, truncate, @"as",
    // Struct introspection
    offset_of,
    // Integer min/max
    min, max,
    // Pointer cast
    align_cast, const_cast,
    // ARC management
    arc_retain, arc_release,
    // Panic
    panic,
    // Terminal detection
    isatty,
    // Memory fill
    memset,
    // Bit manipulation
    ctz, clz, pop_count,
    // Comptime reflection
    type_name, enum_name, type_info,
}

// Zig: pub fn fromString(s: []const u8) ?BuiltinKind { return map.get(s); }
// Cot: String switch for keyword dispatch (same pattern as token.cot lookup).
fn builtinFromString(name: string) int {
    return switch (name) {
        "sizeOf" => @intFromEnum(BuiltinKind.size_of),
        "alignOf" => @intFromEnum(BuiltinKind.align_of),
        "enumLen" => @intFromEnum(BuiltinKind.enum_len),
        "intCast" => @intFromEnum(BuiltinKind.int_cast),
        "floatCast" => @intFromEnum(BuiltinKind.float_cast),
        "floatFromInt" => @intFromEnum(BuiltinKind.float_from_int),
        "intFromFloat" => @intFromEnum(BuiltinKind.int_from_float),
        "ptrCast" => @intFromEnum(BuiltinKind.ptr_cast),
        "intToPtr" => @intFromEnum(BuiltinKind.int_to_ptr),
        "ptrToInt" => @intFromEnum(BuiltinKind.ptr_to_int),
        "string" => @intFromEnum(BuiltinKind.@"string"),
        "assert" => @intFromEnum(BuiltinKind.assert),
        "assert_eq" => @intFromEnum(BuiltinKind.assert_eq),
        "alloc" => @intFromEnum(BuiltinKind.alloc),
        "dealloc" => @intFromEnum(BuiltinKind.dealloc),
        "realloc" => @intFromEnum(BuiltinKind.realloc),
        "memcpy" => @intFromEnum(BuiltinKind.memcpy),
        "fd_write" => @intFromEnum(BuiltinKind.fd_write),
        "fd_read" => @intFromEnum(BuiltinKind.fd_read),
        "fd_close" => @intFromEnum(BuiltinKind.fd_close),
        "fd_seek" => @intFromEnum(BuiltinKind.fd_seek),
        "fd_open" => @intFromEnum(BuiltinKind.fd_open),
        "ptrOf" => @intFromEnum(BuiltinKind.ptr_of),
        "lenOf" => @intFromEnum(BuiltinKind.len_of),
        "trap" => @intFromEnum(BuiltinKind.trap),
        "exit" => @intFromEnum(BuiltinKind.exit),
        "time" => @intFromEnum(BuiltinKind.time),
        "random" => @intFromEnum(BuiltinKind.random),
        "args_count" => @intFromEnum(BuiltinKind.args_count),
        "arg_len" => @intFromEnum(BuiltinKind.arg_len),
        "arg_ptr" => @intFromEnum(BuiltinKind.arg_ptr),
        "environ_count" => @intFromEnum(BuiltinKind.environ_count),
        "environ_len" => @intFromEnum(BuiltinKind.environ_len),
        "environ_ptr" => @intFromEnum(BuiltinKind.environ_ptr),
        "target_os" => @intFromEnum(BuiltinKind.target_os),
        "target_arch" => @intFromEnum(BuiltinKind.target_arch),
        "target" => @intFromEnum(BuiltinKind.target),
        "compileError" => @intFromEnum(BuiltinKind.compile_error),
        "abs" => @intFromEnum(BuiltinKind.abs),
        "ceil" => @intFromEnum(BuiltinKind.ceil),
        "floor" => @intFromEnum(BuiltinKind.floor),
        "trunc" => @intFromEnum(BuiltinKind.@"trunc"),
        "round" => @intFromEnum(BuiltinKind.round),
        "sqrt" => @intFromEnum(BuiltinKind.sqrt),
        "fmin" => @intFromEnum(BuiltinKind.fmin),
        "fmax" => @intFromEnum(BuiltinKind.fmax),
        "net_socket" => @intFromEnum(BuiltinKind.net_socket),
        "net_bind" => @intFromEnum(BuiltinKind.net_bind),
        "net_listen" => @intFromEnum(BuiltinKind.net_listen),
        "net_accept" => @intFromEnum(BuiltinKind.net_accept),
        "net_connect" => @intFromEnum(BuiltinKind.net_connect),
        "net_set_reuse_addr" => @intFromEnum(BuiltinKind.net_set_reuse_addr),
        "kqueue_create" => @intFromEnum(BuiltinKind.kqueue_create),
        "kevent_add" => @intFromEnum(BuiltinKind.kevent_add),
        "kevent_del" => @intFromEnum(BuiltinKind.kevent_del),
        "kevent_wait" => @intFromEnum(BuiltinKind.kevent_wait),
        "epoll_create" => @intFromEnum(BuiltinKind.epoll_create),
        "epoll_add" => @intFromEnum(BuiltinKind.epoll_add),
        "epoll_del" => @intFromEnum(BuiltinKind.epoll_del),
        "epoll_wait" => @intFromEnum(BuiltinKind.epoll_wait),
        "set_nonblocking" => @intFromEnum(BuiltinKind.set_nonblocking),
        "fork" => @intFromEnum(BuiltinKind.fork),
        "execve" => @intFromEnum(BuiltinKind.execve),
        "waitpid" => @intFromEnum(BuiltinKind.waitpid),
        "pipe" => @intFromEnum(BuiltinKind.pipe),
        "dup2" => @intFromEnum(BuiltinKind.dup2),
        "embedFile" => @intFromEnum(BuiltinKind.embed_file),
        "hasField" => @intFromEnum(BuiltinKind.has_field),
        "TypeOf" => @intFromEnum(BuiltinKind.type_of),
        "field" => @intFromEnum(BuiltinKind.field),
        "intFromEnum" => @intFromEnum(BuiltinKind.int_from_enum),
        "enumFromInt" => @intFromEnum(BuiltinKind.enum_from_int),
        "tagName" => @intFromEnum(BuiltinKind.tag_name),
        "errorName" => @intFromEnum(BuiltinKind.error_name),
        "intFromBool" => @intFromEnum(BuiltinKind.int_from_bool),
        "bitCast" => @intFromEnum(BuiltinKind.bit_cast),
        "truncate" => @intFromEnum(BuiltinKind.truncate),
        "as" => @intFromEnum(BuiltinKind.@"as"),
        "offsetOf" => @intFromEnum(BuiltinKind.offset_of),
        "min" => @intFromEnum(BuiltinKind.min),
        "max" => @intFromEnum(BuiltinKind.max),
        "alignCast" => @intFromEnum(BuiltinKind.align_cast),
        "constCast" => @intFromEnum(BuiltinKind.const_cast),
        "arc_retain" => @intFromEnum(BuiltinKind.arc_retain),
        "arc_release" => @intFromEnum(BuiltinKind.arc_release),
        "panic" => @intFromEnum(BuiltinKind.panic),
        "isatty" => @intFromEnum(BuiltinKind.isatty),
        "memset" => @intFromEnum(BuiltinKind.memset),
        "ctz" => @intFromEnum(BuiltinKind.ctz),
        "clz" => @intFromEnum(BuiltinKind.clz),
        "popCount" => @intFromEnum(BuiltinKind.pop_count),
        "typeName" => @intFromEnum(BuiltinKind.type_name),
        "enumName" => @intFromEnum(BuiltinKind.enum_name),
        "typeInfo" => @intFromEnum(BuiltinKind.type_info),
        else => -1,
    }
}

// ============================================================================
// Tests
// ============================================================================

test "null_node sentinel" {
    @assert_eq(null_node, 0xFFFFFFFF)
}

test "span init" {
    var s = Span { start: 5, end: 10 }
    @assert_eq(s.start, 5)
    @assert_eq(s.end, 10)
}

test "span zero" {
    var s = Span { start: 0, end: 0 }
    @assert_eq(s.start, 0)
    @assert_eq(s.end, 0)
}

test "StructLayout enum" {
    @assert_eq(@intFromEnum(StructLayout.auto), 0)
    @assert_eq(@intFromEnum(StructLayout.@"packed"), 1)
    @assert_eq(@intFromEnum(StructLayout.@"extern"), 2)
}

test "LiteralKind enum" {
    @assert_eq(@intFromEnum(LiteralKind.@"int"), 0)
    @assert_eq(@intFromEnum(LiteralKind.@"float"), 1)
    @assert_eq(@intFromEnum(LiteralKind.@"string"), 2)
    @assert_eq(@intFromEnum(LiteralKind.char), 3)
    @assert_eq(@intFromEnum(LiteralKind.true_lit), 4)
    @assert_eq(@intFromEnum(LiteralKind.null_lit), 6)
    @assert_eq(@intFromEnum(LiteralKind.unreachable_lit), 8)
}

test "Decl union fn_decl" {
    var s = Span { start: 0, end: 10 }
    var fd = FnDecl { name: "main", return_type: null_node, body: null_node, is_extern: false, is_async: false, doc_comment: "", span: s }
    var d: Decl = Decl.fn_decl(fd)
    switch d {
        Decl.fn_decl |v| => {
            @assert_eq(v.name, "main")
            @assert_eq(v.span.start, 0)
            @assert_eq(v.span.end, 10)
            @assert_eq(v.is_extern, false)
        },
        Decl.var_decl |v| => { @assert_eq(0, 1) },
        Decl.struct_decl |v| => { @assert_eq(0, 1) },
        Decl.enum_decl |v| => { @assert_eq(0, 1) },
        Decl.union_decl |v| => { @assert_eq(0, 1) },
        Decl.type_alias |v| => { @assert_eq(0, 1) },
        Decl.import_decl |v| => { @assert_eq(0, 1) },
        Decl.impl_block |v| => { @assert_eq(0, 1) },
        Decl.trait_decl |v| => { @assert_eq(0, 1) },
        Decl.impl_trait |v| => { @assert_eq(0, 1) },
        Decl.error_set_decl |v| => { @assert_eq(0, 1) },
        Decl.test_decl |v| => { @assert_eq(0, 1) },
        Decl.bench_decl |v| => { @assert_eq(0, 1) },
        Decl.bad_decl |v| => { @assert_eq(0, 1) },
    }
}

test "Decl union test_decl" {
    var s = Span { start: 5, end: 15 }
    var td = TestDecl { name: "my test", body: 42, span: s }
    var d: Decl = Decl.test_decl(td)
    switch d {
        Decl.test_decl |v| => {
            @assert_eq(v.name, "my test")
            @assert_eq(v.body, 42)
            @assert_eq(v.span.start, 5)
            @assert_eq(v.span.end, 15)
        },
        Decl.fn_decl |v| => { @assert_eq(0, 1) },
        Decl.var_decl |v| => { @assert_eq(0, 1) },
        Decl.struct_decl |v| => { @assert_eq(0, 1) },
        Decl.enum_decl |v| => { @assert_eq(0, 1) },
        Decl.union_decl |v| => { @assert_eq(0, 1) },
        Decl.type_alias |v| => { @assert_eq(0, 1) },
        Decl.import_decl |v| => { @assert_eq(0, 1) },
        Decl.impl_block |v| => { @assert_eq(0, 1) },
        Decl.trait_decl |v| => { @assert_eq(0, 1) },
        Decl.impl_trait |v| => { @assert_eq(0, 1) },
        Decl.error_set_decl |v| => { @assert_eq(0, 1) },
        Decl.bench_decl |v| => { @assert_eq(0, 1) },
        Decl.bad_decl |v| => { @assert_eq(0, 1) },
    }
}

test "Expr union ident" {
    var s = Span { start: 0, end: 3 }
    var id = Ident { name: "foo", span: s }
    var e: Expr = Expr.ident(id)
    switch e {
        Expr.ident |v| => {
            @assert_eq(v.name, "foo")
            @assert_eq(v.span.start, 0)
            @assert_eq(v.span.end, 3)
        },
        Expr.literal |v| => { @assert_eq(0, 1) },
        Expr.binary |v| => { @assert_eq(0, 1) },
        Expr.unary |v| => { @assert_eq(0, 1) },
        Expr.call |v| => { @assert_eq(0, 1) },
        Expr.index |v| => { @assert_eq(0, 1) },
        Expr.slice_expr |v| => { @assert_eq(0, 1) },
        Expr.field_access |v| => { @assert_eq(0, 1) },
        Expr.array_literal |v| => { @assert_eq(0, 1) },
        Expr.paren |v| => { @assert_eq(0, 1) },
        Expr.if_expr |v| => { @assert_eq(0, 1) },
        Expr.switch_expr |v| => { @assert_eq(0, 1) },
        Expr.block_expr |v| => { @assert_eq(0, 1) },
        Expr.struct_init |v| => { @assert_eq(0, 1) },
        Expr.new_expr |v| => { @assert_eq(0, 1) },
        Expr.builtin_call |v| => { @assert_eq(0, 1) },
        Expr.string_interp |v| => { @assert_eq(0, 1) },
        Expr.type_expr |v| => { @assert_eq(0, 1) },
        Expr.try_expr |v| => { @assert_eq(0, 1) },
        Expr.await_expr |v| => { @assert_eq(0, 1) },
        Expr.catch_expr |v| => { @assert_eq(0, 1) },
        Expr.error_literal |v| => { @assert_eq(0, 1) },
        Expr.closure_expr |v| => { @assert_eq(0, 1) },
        Expr.tuple_literal |v| => { @assert_eq(0, 1) },
        Expr.comptime_block |v| => { @assert_eq(0, 1) },
        Expr.zero_init |v| => { @assert_eq(0, 1) },
        Expr.addr_of |v| => { @assert_eq(0, 1) },
        Expr.deref |v| => { @assert_eq(0, 1) },
        Expr.bad_expr |v| => { @assert_eq(0, 1) },
    }
}

test "Expr union binary" {
    var s = Span { start: 0, end: 5 }
    var b = Binary { op: 0, left: 1, right: 2, span: s }
    var e: Expr = Expr.binary(b)
    switch e {
        Expr.binary |v| => {
            @assert_eq(v.op, 0)
            @assert_eq(v.left, 1)
            @assert_eq(v.right, 2)
            @assert_eq(v.span.end, 5)
        },
        else => { @assert_eq(0, 1) },
    }
}

test "Stmt union return" {
    var s = Span { start: 0, end: 8 }
    var r = ReturnStmt { value: 42, span: s }
    var st: Stmt = Stmt.return_stmt(r)
    switch st {
        Stmt.return_stmt |v| => {
            @assert_eq(v.value, 42)
            @assert_eq(v.span.start, 0)
            @assert_eq(v.span.end, 8)
        },
        Stmt.expr_stmt |v| => { @assert_eq(0, 1) },
        Stmt.var_stmt |v| => { @assert_eq(0, 1) },
        Stmt.assign_stmt |v| => { @assert_eq(0, 1) },
        Stmt.if_stmt |v| => { @assert_eq(0, 1) },
        Stmt.while_stmt |v| => { @assert_eq(0, 1) },
        Stmt.for_stmt |v| => { @assert_eq(0, 1) },
        Stmt.block_stmt |v| => { @assert_eq(0, 1) },
        Stmt.break_stmt |v| => { @assert_eq(0, 1) },
        Stmt.continue_stmt |v| => { @assert_eq(0, 1) },
        Stmt.defer_stmt |v| => { @assert_eq(0, 1) },
        Stmt.destructure_stmt |v| => { @assert_eq(0, 1) },
        Stmt.bad_stmt |v| => { @assert_eq(0, 1) },
    }
}

test "Node union wraps expr" {
    var s = Span { start: 1, end: 9 }
    var id = Ident { name: "x", span: s }
    var e: Expr = Expr.ident(id)
    var n: Node = Node.expr(e)
    // Test Node dispatches to correct variant
    var matched = false
    switch n {
        Node.expr |inner| => { matched = true },
        Node.decl |d| => { @assert_eq(0, 1) },
        Node.stmt |s2| => { @assert_eq(0, 1) },
    }
    @assert_eq(matched, true)
}

test "BuiltinKind enum count" {
    // Verify enum has all 94 variants
    @assert_eq(@enumLen(BuiltinKind), 94)
}

test "builtinFromString known" {
    @assert_eq(builtinFromString("sizeOf"), @intFromEnum(BuiltinKind.size_of))
    @assert_eq(builtinFromString("intCast"), @intFromEnum(BuiltinKind.int_cast))
    @assert_eq(builtinFromString("assert_eq"), @intFromEnum(BuiltinKind.assert_eq))
    @assert_eq(builtinFromString("fd_write"), @intFromEnum(BuiltinKind.fd_write))
    @assert_eq(builtinFromString("net_socket"), @intFromEnum(BuiltinKind.net_socket))
    @assert_eq(builtinFromString("typeName"), @intFromEnum(BuiltinKind.type_name))
    @assert_eq(builtinFromString("typeInfo"), @intFromEnum(BuiltinKind.type_info))
    @assert_eq(builtinFromString("panic"), @intFromEnum(BuiltinKind.panic))
}

test "builtinFromString unknown" {
    @assert_eq(builtinFromString("nonexistent"), -1)
    @assert_eq(builtinFromString(""), -1)
}

test "BuiltinKind quoted identifiers" {
    // Verify @"string", @"trunc", @"as" work as enum variants
    @assert_eq(@intFromEnum(BuiltinKind.@"string"), 10)
    @assert_eq(@intFromEnum(BuiltinKind.@"as"), 77)
}

test "ForStmt isRange pattern" {
    var s = Span { start: 0, end: 10 }
    var fs = ForStmt { binding: "i", iterable: null_node, range_start: 0, range_end: 10, body: 1, is_inline: false, span: s }
    // range check: range_start != null_node means it's a range loop
    @assert_eq(fs.range_start != null_node, true)
    var fs2 = ForStmt { binding: "item", iterable: 5, range_start: null_node, range_end: null_node, body: 1, is_inline: false, span: s }
    @assert_eq(fs2.range_start != null_node, false)
}

test "VarStmt fields" {
    var s = Span { start: 0, end: 20 }
    var vs = VarStmt { name: "x", type_expr: null_node, value: 42, is_const: true, is_weak: false, span: s }
    @assert_eq(vs.name, "x")
    @assert_eq(vs.is_const, true)
    @assert_eq(vs.is_weak, false)
    @assert_eq(vs.value, 42)
}

test "nested union Decl in Node" {
    var s = Span { start: 0, end: 5 }
    var bd = BadDecl { span: s }
    var d: Decl = Decl.bad_decl(bd)
    var n: Node = Node.decl(d)
    // Test Node dispatches to correct variant
    var matched = false
    switch n {
        Node.decl |inner| => { matched = true },
        Node.expr |e| => { @assert_eq(0, 1) },
        Node.stmt |s2| => { @assert_eq(0, 1) },
    }
    @assert_eq(matched, true)
}
