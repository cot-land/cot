/// Lexical scanner for the self-hosted compiler.
/// Ported from compiler/frontend/scanner.zig

import "std/string"
import "token"
import "errors"
import "source"

/// Result of scanning a single token: token type, span, and text.
struct TokenInfo {
    tok: int,
    start_offset: int,
    end_offset: int,
    text: string,
}

/// Lexical scanner state: tracks position, current character, and interpolation depth.
struct Scanner {
    content: string,
    src: ?*Source,
    pos: int,
    ch: ?int,
    in_interp_string: bool,
    interp_brace_depth: int,
    err: ?*ErrorReporter,

    /// Create a new scanner for the given source content (no error reporting).
    static fn init(content: string) Scanner {
        return Scanner.make(content, null, null)
    }

    /// Create a scanner with error reporting.
    static fn initWithErrors(content: string, err: *ErrorReporter) Scanner {
        return Scanner.make(content, null, err)
    }

    /// Create a scanner with Source object and error reporting (Zig parity).
    static fn initWithSource(src: *Source, err: *ErrorReporter) Scanner {
        return Scanner.make(src.content, src, err)
    }

    /// Shared constructor — all init variants delegate here.
    static fn make(content: string, src: ?*Source, err: ?*ErrorReporter) Scanner {
        var s = Scanner {
            content: content,
            src: src,
            pos: 0,
            ch: null,
            in_interp_string: false,
            interp_brace_depth: 0,
            err: err,
        }
        if (@lenOf(content) > 0) {
            s.ch = charAt(content, 0)
        }
        return s
    }

    /// Report a scanner error if error reporter is attached.
    fn errorAt(offset: int, code: ErrorCode, msg: string) void {
        if (self.err) |e| {
            e.report(offset, code, msg)
        }
    }

    /// Advance one byte forward.
    fn advance() void {
        self.pos += 1
        if (self.pos >= @lenOf(self.content)) {
            self.ch = null
        } else {
            self.ch = charAt(self.content, self.pos)
        }
    }

    /// Peek n bytes ahead without advancing.
    fn peek(n: int) ?int {
        const offset = self.pos + n
        if (offset >= @lenOf(self.content)) {
            return null
        }
        return charAt(self.content, offset)
    }

    /// Scan the next token from input.
    fn scanNext() TokenInfo {
        self.skipWhitespaceAndComments()
        const start = self.pos

        if (self.ch == null) {
            return TokenInfo {
                tok: Token.eof as int,
                start_offset: start,
                end_offset: start,
                text: "",
            }
        }

        // Doc comment: /// ... (handled separately to keep scanNext simple)
        const c = self.ch.?
        if (c == '/') {
            if (self.peek(1) == '/') {
                if (self.peek(2) == '/') {
                    return self.scanDocComment(start)
                }
            }
            return self.scanOperator(start)
        }

        return self.scanNextInner(start)
    }

    fn scanNextInner(start: int) TokenInfo {
        const c = self.ch.?
        if (isAlpha(c) or c == '_') { return self.scanIdentifier(start) }
        if (isDigit(c)) { return self.scanNumber(start) }
        if (c == '"') { return self.scanString(start) }
        if (c == '\'') { return self.scanChar(start) }
        return self.scanOperator(start)
    }

    /// Scan a /// doc comment.
    fn scanDocComment(start: int) TokenInfo {
        self.advance() // /
        self.advance() // /
        self.advance() // /
        // Skip optional space after ///
        if (self.ch) |c| {
            if (c == ' ') { self.advance() }
        }
        const text_start = self.pos
        while (self.ch) |c| {
            if (c == '\n') { break }
            self.advance()
        }
        const text = substring(self.content, text_start, self.pos)
        // Consume the newline
        if (self.ch) |c| {
            if (c == '\n') { self.advance() }
        }
        return TokenInfo {
            tok: Token.doc_comment as int,
            start_offset: start,
            end_offset: self.pos,
            text: text,
        }
    }

    /// Skip whitespace and comments (line // and block /* */).
    fn skipWhitespaceAndComments() void {
        while (self.ch) |c| {
            if (c == ' ' or c == '\t' or c == '\n' or c == '\r') {
                // Whitespace
                self.advance()
            } else if (c == '/' and self.peek(1) == '/') {
                // // prefix — check if doc comment or line comment
                if (self.peek(2) == '/') {
                    // Doc comment /// — stop, let scanNext handle it
                    break
                }
                // Line comment (not doc comment) — skip to end of line
                self.advance()
                self.advance()
                while (self.ch) |cc| {
                    if (cc == '\n') {
                        self.advance()
                        break
                    }
                    self.advance()
                }
            } else if (c == '/' and self.peek(1) == '*') {
                // Block comment /* ... */
                self.advance()
                self.advance()
                while (self.ch != null) {
                    if (self.ch.? == '*' and self.peek(1) == '/') {
                        self.advance()
                        self.advance()
                        break
                    }
                    self.advance()
                }
            } else {
                break
            }
        }
    }

    /// Scan an identifier or keyword.
    fn scanIdentifier(start: int) TokenInfo {
        while (self.ch) |c| {
            if (isAlphaNumeric(c) or c == '_') {
                self.advance()
            } else {
                break
            }
        }
        const text = substring(self.content, start, self.pos)
        const kw = lookup(text)
        if (kw != Token.ident) {
            return TokenInfo { tok: kw as int, start_offset: start, end_offset: self.pos, text: text }
        }
        return TokenInfo {
            tok: Token.ident as int,
            start_offset: start,
            end_offset: self.pos,
            text: text,
        }
    }

    /// Scan float decimal point and exponent suffix. Returns 1 if float, 0 if int.
    fn scanFloatPart() int {
        // Decimal point (but not ".." range)
        if (self.ch) |c| {
            var is_range = false
            if (self.peek(1)) |p| {
                if (p == '.') { is_range = true }
            }
            if (c == '.' and !is_range) {
                self.advance()
                while (self.ch) |cc| {
                    if (isDigit(cc) or cc == '_') { self.advance() } else { break }
                }
                // Check for exponent after decimal
                if (self.ch) |ec| {
                    if (ec == 'e' or ec == 'E') {
                        self.advance()
                        if (self.ch) |sc| {
                            if (sc == '+' or sc == '-') { self.advance() }
                        }
                        while (self.ch) |cc| {
                            if (isDigit(cc) or cc == '_') { self.advance() } else { break }
                        }
                    }
                }
                return 1
            }
        }
        // Exponent without decimal (e.g. 1e5)
        if (self.ch) |c| {
            if (c == 'e' or c == 'E') {
                self.advance()
                if (self.ch) |sc| {
                    if (sc == '+' or sc == '-') { self.advance() }
                }
                while (self.ch) |cc| {
                    if (isDigit(cc) or cc == '_') { self.advance() } else { break }
                }
                return 1
            }
        }
        return 0
    }

    /// Scan a numeric literal (int, float, hex, octal, binary).
    fn scanNumber(start: int) TokenInfo {
        if (self.ch.? == '0') {
            // '0' prefix — check for hex/octal/binary
            self.advance()
            if (self.ch) |c| {
                if (c == 'x' or c == 'X') {
                    // 0x or 0X — hex
                    self.advance()
                    while (self.ch) |cc| {
                        if (isHexDigit(cc) or cc == '_') { self.advance() } else { break }
                    }
                    return self.makeNumberToken(start, false)
                } else if (c == 'o' or c == 'O') {
                    // 0o or 0O — octal
                    self.advance()
                    while (self.ch) |cc| {
                        if ((cc >= '0' and cc <= '7') or cc == '_') { self.advance() } else { break }
                    }
                    return self.makeNumberToken(start, false)
                } else if (c == 'b' or c == 'B') {
                    // 0b or 0B — binary
                    self.advance()
                    while (self.ch) |cc| {
                        if (cc == '0' or cc == '1' or cc == '_') { self.advance() } else { break }
                    }
                    return self.makeNumberToken(start, false)
                }
            }
        }

        // Decimal digits
        while (self.ch) |c| {
            if (isDigit(c) or c == '_') { self.advance() } else { break }
        }

        // Float detection (decimal point + exponent) in separate function
        if (self.scanFloatPart() == 1) {
            return self.makeNumberToken(start, true)
        }
        return self.makeNumberToken(start, false)
    }

    fn makeNumberToken(start: int, is_float: bool) TokenInfo {
        var tok = Token.int_lit as int
        if (is_float) { tok = Token.float_lit as int }
        return TokenInfo {
            tok: tok,
            start_offset: start,
            end_offset: self.pos,
            text: substring(self.content, start, self.pos),
        }
    }

    /// Scan a string literal (with interpolation support).
    fn scanString(start: int) TokenInfo {
        self.advance() // opening "

        while (self.ch) |c| {
            if (c == '"') {
                // closing "
                self.advance()
                break
            } else if (c == '\\') {
                // backslash escape
                self.advance()
                if (self.ch != null) { self.advance() }
            } else if (c == '$' and self.peek(1) == '{') {
                // ${ — string interpolation
                self.advance()
                self.advance()
                self.in_interp_string = true
                self.interp_brace_depth = 1
                const text = substring(self.content, start, self.pos)
                return TokenInfo {
                    tok: Token.string_interp_start as int,
                    start_offset: start,
                    end_offset: self.pos,
                    text: text,
                }
            } else if (c == '\n') {
                // newline — unterminated
                self.errorAt(start, ErrorCode.e100, "unterminated string literal")
                break
            } else {
                self.advance()
            }
        }

        return TokenInfo {
            tok: Token.string_lit as int,
            start_offset: start,
            end_offset: self.pos,
            text: substring(self.content, start, self.pos),
        }
    }

    /// Scan string continuation after interpolation expression.
    fn scanStringContinuation(start: int) TokenInfo {
        while (self.ch) |c| {
            if (c == '"') {
                self.advance()
                self.in_interp_string = false
                return TokenInfo {
                    tok: Token.string_interp_end as int,
                    start_offset: start,
                    end_offset: self.pos,
                    text: substring(self.content, start, self.pos),
                }
            } else if (c == '\\') {
                self.advance()
                if (self.ch != null) { self.advance() }
            } else if (c == '$' and self.peek(1) == '{') {
                self.advance()
                self.advance()
                self.interp_brace_depth = 1
                return TokenInfo {
                    tok: Token.string_interp_mid as int,
                    start_offset: start,
                    end_offset: self.pos,
                    text: substring(self.content, start, self.pos),
                }
            } else if (c == '\n') {
                self.errorAt(start, ErrorCode.e100, "unterminated string literal")
                break
            } else {
                self.advance()
            }
        }

        return TokenInfo {
            tok: Token.string_interp_end as int,
            start_offset: start,
            end_offset: self.pos,
            text: substring(self.content, start, self.pos),
        }
    }

    /// Scan a character literal.
    fn scanChar(start: int) TokenInfo {
        self.advance() // opening '
        if (self.ch) |c| {
            if (c == '\\') {
                // escape sequence
                self.advance()
                if (self.ch != null) { self.advance() }
            } else if (c != '\'') {
                self.advance()
            }
        }
        if (self.ch) |c| {
            if (c == '\'') {
                self.advance()
            } else {
                self.errorAt(start, ErrorCode.e101, "unterminated character literal")
            }
        } else {
            self.errorAt(start, ErrorCode.e101, "unterminated character literal")
        }
        return TokenInfo {
            tok: Token.char_lit as int,
            start_offset: start,
            end_offset: self.pos,
            text: substring(self.content, start, self.pos),
        }
    }

    /// Scan an operator or punctuation token.
    fn scanOperator(start: int) TokenInfo {
        const c = self.ch.?
        self.advance()

        // String interpolation brace tracking
        if (c == '{' and self.in_interp_string) {
            self.interp_brace_depth += 1
            return TokenInfo {
                tok: Token.lbrace as int,
                start_offset: start,
                end_offset: self.pos,
                text: "",
            }
        }
        if (c == '}' and self.in_interp_string) {
            self.interp_brace_depth -= 1
            if (self.interp_brace_depth == 0) {
                return self.scanStringContinuation(start)
            }
            return TokenInfo {
                tok: Token.rbrace as int,
                start_offset: start,
                end_offset: self.pos,
                text: "",
            }
        }

        // Single-char operators (no lookahead needed)
        if (c == '(') { return makeOp(start, self.pos, Token.lparen as int) }
        if (c == ')') { return makeOp(start, self.pos, Token.rparen as int) }
        if (c == '[') { return makeOp(start, self.pos, Token.lbrack as int) }
        if (c == ']') { return makeOp(start, self.pos, Token.rbrack as int) }
        if (c == '{') { return makeOp(start, self.pos, Token.lbrace as int) }
        if (c == '}') { return makeOp(start, self.pos, Token.rbrace as int) }
        if (c == ',') { return makeOp(start, self.pos, Token.comma as int) }
        if (c == ';') { return makeOp(start, self.pos, Token.semicolon as int) }
        if (c == ':') { return makeOp(start, self.pos, Token.colon as int) }
        if (c == '~') { return makeOp(start, self.pos, Token.@"not" as int) }
        if (c == '@') {
            // @"..." quoted identifier (Zig pattern: use keywords as identifiers)
            // Ported from scanner.zig:286-303
            if (self.ch) |nc| {
                if (nc == '"') {
                    self.advance()  // consume opening "
                    const text_start = self.pos
                    while (self.ch) |qc| {
                        if (qc == '"') {
                            break
                        }
                        if (qc == '\n') {
                            self.errorAt(start, ErrorCode.e100, "unterminated quoted identifier")
                            break
                        }
                        self.advance()
                    }
                    const ident_text = substring(self.content, text_start, self.pos)
                    if (self.ch) |ec| {
                        if (ec == '"') {
                            self.advance()  // consume closing "
                        } else {
                            self.errorAt(start, ErrorCode.e100, "unterminated quoted identifier")
                        }
                    } else {
                        self.errorAt(start, ErrorCode.e100, "unterminated quoted identifier")
                    }
                    return TokenInfo { tok: Token.ident as int, start_offset: start, end_offset: self.pos, text: ident_text }
                }
            }
            return makeOp(start, self.pos, Token.at as int)
        }

        // Two-char arithmetic operators
        if (c == '+') {
            if (self.ch) |nc| {
                if (nc == '+') { self.advance(); return makeOp(start, self.pos, Token.concat as int) }
                if (nc == '=') { self.advance(); return makeOp(start, self.pos, Token.add_assign as int) }
            }
            return makeOp(start, self.pos, Token.add as int)
        }
        if (c == '-') {
            if (self.ch) |nc| {
                if (nc == '=') { self.advance(); return makeOp(start, self.pos, Token.sub_assign as int) }
                if (nc == '>') { self.advance(); return makeOp(start, self.pos, Token.arrow as int) }
            }
            return makeOp(start, self.pos, Token.sub as int)
        }
        if (c == '*') {
            if (self.ch) |nc| { if (nc == '=') { self.advance(); return makeOp(start, self.pos, Token.mul_assign as int) } }
            return makeOp(start, self.pos, Token.mul as int)
        }
        if (c == '/') {
            if (self.ch) |nc| { if (nc == '=') { self.advance(); return makeOp(start, self.pos, Token.quo_assign as int) } }
            return makeOp(start, self.pos, Token.quo as int)
        }
        if (c == '%') {
            if (self.ch) |nc| { if (nc == '=') { self.advance(); return makeOp(start, self.pos, Token.rem_assign as int) } }
            return makeOp(start, self.pos, Token.rem as int)
        }

        // Delegate to second half for bitwise, comparison, and punctuation operators
        return self.scanOperator2(c, start)
    }

    fn scanOperator2(c: int, start: int) TokenInfo {
        if (c == '&') {
            if (self.ch) |nc| {
                if (nc == '&') { self.advance(); return makeOp(start, self.pos, Token.land as int) }
                if (nc == '=') { self.advance(); return makeOp(start, self.pos, Token.and_assign as int) }
            }
            return makeOp(start, self.pos, Token.@"and" as int)
        }
        if (c == '|') {
            if (self.ch) |nc| {
                if (nc == '|') { self.advance(); return makeOp(start, self.pos, Token.lor as int) }
                if (nc == '=') { self.advance(); return makeOp(start, self.pos, Token.or_assign as int) }
            }
            return makeOp(start, self.pos, Token.@"or" as int)
        }
        if (c == '^') {
            if (self.ch) |nc| { if (nc == '=') { self.advance(); return makeOp(start, self.pos, Token.xor_assign as int) } }
            return makeOp(start, self.pos, Token.xor as int)
        }
        if (c == '=') {
            if (self.ch) |nc| {
                if (nc == '=') { self.advance(); return makeOp(start, self.pos, Token.eql as int) }
                if (nc == '>') { self.advance(); return makeOp(start, self.pos, Token.fat_arrow as int) }
            }
            return makeOp(start, self.pos, Token.assign as int)
        }
        if (c == '!') {
            if (self.ch) |nc| { if (nc == '=') { self.advance(); return makeOp(start, self.pos, Token.neq as int) } }
            return makeOp(start, self.pos, Token.lnot as int)
        }
        if (c == '<') {
            if (self.ch) |nc| {
                if (nc == '=') { self.advance(); return makeOp(start, self.pos, Token.leq as int) }
                if (nc == '<') { self.advance(); return makeOp(start, self.pos, Token.shl as int) }
            }
            return makeOp(start, self.pos, Token.lss as int)
        }
        if (c == '>') {
            if (self.ch) |nc| {
                if (nc == '=') { self.advance(); return makeOp(start, self.pos, Token.geq as int) }
                if (nc == '>') { self.advance(); return makeOp(start, self.pos, Token.shr as int) }
            }
            return makeOp(start, self.pos, Token.gtr as int)
        }
        if (c == '.') {
            if (self.ch) |nc| {
                if (nc == '.') { self.advance(); return makeOp(start, self.pos, Token.period_period as int) }
                if (nc == '*') { self.advance(); return makeOp(start, self.pos, Token.period_star as int) }
                if (nc == '?') { self.advance(); return makeOp(start, self.pos, Token.period_question as int) }
            }
            return makeOp(start, self.pos, Token.period as int)
        }
        if (c == '?') {
            if (self.ch) |nc| { if (nc == '.') { self.advance(); return makeOp(start, self.pos, Token.optional_chain as int) } }
            return makeOp(start, self.pos, Token.question as int)
        }

        self.errorAt(start, ErrorCode.e104, "unexpected character")
        return makeOp(start, self.pos, Token.illegal as int)
    }
}

/// Create an operator TokenInfo with no text.
fn makeOp(start: int, end: int, tok: int) TokenInfo {
    return TokenInfo { tok: tok, start_offset: start, end_offset: end, text: "" }
}

// Character classification helpers
fn isHexDigit(c: int) bool {
    return isDigit(c) or (c >= 'a' and c <= 'f') or (c >= 'A' and c <= 'F')
}

fn isAlphaNumeric(c: int) bool {
    return isAlpha(c) or isDigit(c)
}

// ============================================================================
// Test helpers
// ============================================================================

fn expectTok(s: *Scanner, expected: int) void {
    const t = s.scanNext()
    @assertEq(t.tok, expected)
}

fn expectTokText(s: *Scanner, expected_tok: int, expected_text: string) void {
    const t = s.scanNext()
    @assertEq(t.tok, expected_tok)
    @assertEq(t.text, expected_text)
}

fn expectText(s: *Scanner, expected_text: string) void {
    const t = s.scanNext()
    @assertEq(t.text, expected_text)
}

// ============================================================================
// Tests
// ============================================================================

test "scanner basics" {
    var s = Scanner.init("fn main() { return 42 }")
    expectTok(s, Token.kw_fn as int)
    expectTokText(s, Token.ident as int, "main")
    expectTok(s, Token.lparen as int)
    expectTok(s, Token.rparen as int)
    expectTok(s, Token.lbrace as int)
    expectTok(s, Token.kw_return as int)
    expectTokText(s, Token.int_lit as int, "42")
    expectTok(s, Token.rbrace as int)
    expectTok(s, Token.eof as int)
}

test "scanner operators" {
    var s = Scanner.init("== != <= >= << >> .* .? ?. orelse")
    expectTok(s, Token.eql as int)
    expectTok(s, Token.neq as int)
    expectTok(s, Token.leq as int)
    expectTok(s, Token.geq as int)
    expectTok(s, Token.shl as int)
    expectTok(s, Token.shr as int)
    expectTok(s, Token.period_star as int)
    expectTok(s, Token.period_question as int)
    expectTok(s, Token.optional_chain as int)
    expectTok(s, Token.kw_orelse as int)
}

test "scanner strings" {
    var s = Scanner.init("\"hello world\"")
    expectTokText(s, Token.string_lit as int, "\"hello world\"")
}

test "scanner numbers" {
    var s = Scanner.init("42 3.14 0xFF 0b1010 0o777 1_000_000")
    expectTokText(s, Token.int_lit as int, "42")
    expectTokText(s, Token.float_lit as int, "3.14")
    expectText(s, "0xFF")
    expectText(s, "0b1010")
    expectText(s, "0o777")
    expectText(s, "1_000_000")
}

test "scanner comments" {
    var s = Scanner.init("// line comment\nx /* block */ y")
    expectTokText(s, Token.ident as int, "x")
    expectText(s, "y")
    expectTok(s, Token.eof as int)
}

test "scanner keywords" {
    var s = Scanner.init("fn var const if else while for return")
    expectTok(s, Token.kw_fn as int)
    expectTok(s, Token.kw_var as int)
    expectTok(s, Token.kw_const as int)
    expectTok(s, Token.kw_if as int)
    expectTok(s, Token.kw_else as int)
    expectTok(s, Token.kw_while as int)
    expectTok(s, Token.kw_for as int)
    expectTok(s, Token.kw_return as int)
}

test "scanner type keywords" {
    var s = Scanner.init("int float bool string i64 u8")
    expectTok(s, Token.kw_int as int)
    expectTok(s, Token.kw_float as int)
    expectTok(s, Token.kw_bool as int)
    expectTok(s, Token.kw_string as int)
    expectTok(s, Token.kw_i64 as int)
    expectTok(s, Token.kw_u8 as int)
}

test "scanner char literals" {
    var s = Scanner.init("'a' '\\n'")
    expectTokText(s, Token.char_lit as int, "'a'")
    expectTok(s, Token.char_lit as int)
}

test "scanner compound assignment" {
    var s = Scanner.init("+= -= *= /= %= &= |= ^=")
    expectTok(s, Token.add_assign as int)
    expectTok(s, Token.sub_assign as int)
    expectTok(s, Token.mul_assign as int)
    expectTok(s, Token.quo_assign as int)
    expectTok(s, Token.rem_assign as int)
    expectTok(s, Token.and_assign as int)
    expectTok(s, Token.or_assign as int)
    expectTok(s, Token.xor_assign as int)
}

test "scanner arrows" {
    var s = Scanner.init("-> =>")
    expectTok(s, Token.arrow as int)
    expectTok(s, Token.fat_arrow as int)
}

test "scanner doc comment" {
    var s = Scanner.init("/// hello world\nx")
    expectTokText(s, Token.doc_comment as int, "hello world")
    expectTokText(s, Token.ident as int, "x")
}

test "scanner empty input" {
    var s = Scanner.init("")
    expectTok(s, Token.eof as int)
}

test "scanner logical operators" {
    var s = Scanner.init("&& || ! & |")
    expectTok(s, Token.land as int)
    expectTok(s, Token.lor as int)
    expectTok(s, Token.lnot as int)
    expectTok(s, Token.@"and" as int)
    expectTok(s, Token.@"or" as int)
}

test "scanner comparison operators" {
    var s = Scanner.init("< > = . ?")
    expectTok(s, Token.lss as int)
    expectTok(s, Token.gtr as int)
    expectTok(s, Token.assign as int)
    expectTok(s, Token.period as int)
    expectTok(s, Token.question as int)
}

test "scanner full statement" {
    var s = Scanner.init("var x = 42 + y")
    expectTok(s, Token.kw_var as int)
    expectTokText(s, Token.ident as int, "x")
    expectTok(s, Token.assign as int)
    expectTokText(s, Token.int_lit as int, "42")
    expectTok(s, Token.add as int)
    expectTokText(s, Token.ident as int, "y")
    expectTok(s, Token.eof as int)
}

test "scanner quoted identifier" {
    var s = Scanner.init("@\"or\" @\"and\"")
    expectTokText(s, Token.ident as int, "or")
    expectTokText(s, Token.ident as int, "and")
    expectTok(s, Token.eof as int)
}

test "scanner concat operator" {
    var s = Scanner.init("a ++ b")
    expectTokText(s, Token.ident as int, "a")
    expectTok(s, Token.concat as int)
    expectTokText(s, Token.ident as int, "b")
    expectTok(s, Token.eof as int)
}
