WebAssembly Specification
Release 3.0 (Draft 2025-09-16)

WebAssembly Community Group
Andreas Rossberg (editor)

Sep 26, 2025

Contents

1

Introduction
1.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
1.2 Overview . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

1
1
3

2

Structure
2.1 Conventions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.2 Values . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.3 Types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.4 Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.5 Modules . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

5
5
6
8
13
22

3

Validation
3.1 Conventions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
3.2 Types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
3.3 Matching . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
3.4 Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
3.5 Modules . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

27
27
32
38
44
69

4

Execution
79
4.1 Conventions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 79
4.2 Runtime Structure . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 81
4.3 Numerics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 90
4.4 Types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 115
4.5 Values . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 115
4.6 Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 118
4.7 Modules . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 171

5

Binary Format
181
5.1 Conventions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 181
5.2 Values . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 183
5.3 Types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 184
5.4 Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 187
5.5 Modules . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 200

6

Text Format
209
6.1 Conventions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 209
6.2 Lexical Format . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 211
6.3 Values . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 213
6.4 Types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 215
6.5 Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 218
6.6 Modules . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 232

i

7

Appendix
241
7.1 Embedding . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 241
7.2 Profiles . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 249
7.3 Implementation Limitations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 251
7.4 Type Soundness . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 254
7.5 Type System Properties . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 267
7.6 Validation Algorithm . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 270
7.7 Custom Sections and Annotations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 278
7.8 Change History . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 282
7.9 Index of Types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 293
7.10 Index of Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 294
7.11 Index of Semantic Rules . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 305

Index

ii

309

CHAPTER

1

Introduction

1.1 Introduction
WebAssembly (abbreviated Wasm2 ) is a safe, portable, low-level code format designed for efficient execution and
compact representation. Its main goal is to enable high performance applications on the Web, but it does not make
any Web-specific assumptions or provide Web-specific features, so it can be employed in other environments as
well.
WebAssembly is an open standard developed by a W3C Community Group1 .
This document describes version 3.0 (Draft 2025-09-16) of the core WebAssembly standard. It is intended that it
will be superseded by new incremental releases with additional features in the future.

1.1.1 Design Goals
The design goals of WebAssembly are the following:
â€¢ Fast, safe, and portable semantics:
â€“ Fast: executes with near native code performance, taking advantage of capabilities common to all
contemporary hardware.
â€“ Safe: code is validated and executes in a memory-safe3 , sandboxed environment preventing data corruption or security breaches.
â€“ Well-defined: fully and precisely defines valid programs and their behavior in a way that is easy to
reason about informally and formally.
â€“ Hardware-independent: can be compiled on all modern architectures, desktop or mobile devices and
embedded systems alike.
â€“ Language-independent: does not privilege any particular language, programming model, or object
model.
â€“ Platform-independent: can be embedded in browsers, run as a stand-alone VM, or integrated in other
environments.
â€“ Open: programs can interoperate with their environment in a simple and universal manner.
2 A contraction of â€œWebAssemblyâ€, not an acronym, hence not using all-caps.
1 https://www.w3.org/community/webassembly/

3 No program can break WebAssemblyâ€™s memory model. Of course, it cannot guarantee that an unsafe language compiling to WebAssembly
does not corrupt its own memory layout, e.g. inside WebAssemblyâ€™s linear memory.

1

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

â€¢ Efficient and portable representation:
â€“ Compact: has a binary format that is fast to transmit by being smaller than typical text or native code
formats.
â€“ Modular: programs can be split up in smaller parts that can be transmitted, cached, and consumed
separately.
â€“ Efficient: can be decoded, validated, and compiled in a fast single pass, equally with either just-in-time
(JIT) or ahead-of-time (AOT) compilation.
â€“ Streamable: allows decoding, validation, and compilation to begin as soon as possible, before all data
has been seen.
â€“ Parallelizable: allows decoding, validation, and compilation to be split into many independent parallel
tasks.
â€“ Portable: makes no architectural assumptions that are not broadly supported across modern hardware.
WebAssembly code is also intended to be easy to inspect and debug, especially in environments like web browsers,
but such features are beyond the scope of this specification.

1.1.2 Scope
At its core, WebAssembly is a virtual instruction set architecture (virtual ISA). As such, it has many use cases
and can be embedded in many different environments. To encompass their variety and enable maximum reuse, the
WebAssembly specification is split and layered into several documents.
This document is concerned with the core ISA layer of WebAssembly. It defines the instruction set, binary encoding, validation, and execution semantics, as well as a textual representation. It does not, however, define how
WebAssembly programs can interact with a specific environment they execute in, nor how they are invoked from
such an environment.
Instead, this specification is complemented by additional documents defining interfaces to specific embedding
environments such as the Web. These will each define a WebAssembly application programming interface (API)
suitable for a given environment.

1.1.3 Security Considerations
WebAssembly provides no ambient access to the computing environment in which code is executed. Any interaction with the environment, such as I/O, access to resources, or operating system calls, can only be performed
by invoking functions provided by the embedder and imported into a WebAssembly module. An embedder can
establish security policies suitable for a respective environment by controlling or limiting which functional capabilities it makes available for import. Such considerations are an embedderâ€™s responsibility and the subject of API
definitions for a specific environment.
Because WebAssembly is designed to be translated into machine code running directly on the hostâ€™s hardware, it
is potentially vulnerable to side channel attacks on the hardware level. In environments where this is a concern, an
embedder may have to put suitable mitigations into place to isolate WebAssembly computations.

1.1.4 Dependencies
WebAssembly depends on two existing standards:
â€¢ IEEE 7544 , for the representation of floating-point data and the semantics of respective numeric operations.
â€¢ Unicode5 , for the representation of import/export names and the text format.
However, to make this specification self-contained, relevant aspects of the aforementioned standards are defined
and formalized as part of this specification, such as the binary representation and rounding of floating-point values,
and the value range and UTF-8 encoding of Unicode characters.
4 https://ieeexplore.ieee.org/document/8766229
5 https://www.unicode.org/versions/latest/

2

Chapter 1. Introduction

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

Ã² Note
The aforementioned standards are the authoritative source of all respective definitions. Formalizations given in
this specification are intended to match these definitions. Any discrepancy in the syntax or semantics described
is to be considered an error.

1.2 Overview
1.2.1 Concepts
WebAssembly encodes a low-level, assembly-like programming language. This language is structured around the
following concepts.
Values
WebAssembly provides only four basic number types. These are integers and IEEE 7546 numbers, each in
32 and 64 bit width. 32 bit integers also serve as Booleans and as memory addresses. The usual operations
on these types are available, including the full matrix of conversions between them. There is no distinction
between signed and unsigned integer types. Instead, integers are interpreted by respective operations as
either unsigned or signed in twoâ€™s complement representation.
In addition to these basic number types, there is a single 128 bit wide vector type representing different types
of packed data. The supported representations are 4 32-bit, or 2 64-bit IEEE 7547 numbers, or different
widths of packed integer values, specifically 2 64-bit integers, 4 32-bit integers, 8 16-bit integers, or 16 8-bit
integers.
Finally, values can consist of opaque references that represent pointers towards different sorts of entities.
Unlike with other types, their size or representation is not observable.
Instructions
The computational model of WebAssembly is based on a stack machine. Code consists of sequences of
instructions that are executed in order. Instructions manipulate values on an implicit operand stack 8 and
fall into two main categories. Simple instructions perform basic operations on data. They pop arguments
from the operand stack and push results back to it. Control instructions alter control flow. Control flow
is structured, meaning it is expressed with well-nested constructs such as blocks, loops, and conditionals.
Branches can only target such constructs.
Traps
Under some conditions, certain instructions may produce a trap, which immediately aborts execution. Traps
cannot be handled by WebAssembly code, but are reported to the outside environment, where they typically
can be caught.
Functions
Code is organized into separate functions. Each function takes a sequence of values as parameters and returns
a sequence of values as results. Functions can call each other, including recursively, resulting in an implicit
call stack that cannot be accessed directly. Functions may also declare mutable local variables that are usable
as virtual registers.
Tables
A table is an array of opaque values of a particular reference type. It allows programs to select such values
indirectly through a dynamic index operand. Thereby, for example, a program can call functions indirectly
through a dynamic index into a table. This allows emulating function pointers by way of table indices.
Linear Memory
A linear memory is a contiguous, mutable array of raw bytes. Such a memory is created with an initial size
but can be grown dynamically. A program can load and store values from/to a linear memory at any byte
address (including unaligned). Integer loads and stores can specify a storage size which is smaller than the
6 https://ieeexplore.ieee.org/document/8766229
7 https://ieeexplore.ieee.org/document/8766229

8 In practice, implementations need not maintain an actual operand stack. Instead, the stack can be viewed as a set of anonymous registers
that are implicitly referenced by instructions. The type system ensures that the stack height, and thus any referenced register, is always known
statically.

1.2. Overview

3

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

size of the respective value type. A trap occurs if an access is not within the bounds of the current memory
size.
Modules
A WebAssembly binary takes the form of a module that contains definitions for functions, tables, and linear
memories, as well as mutable or immutable global variables. Definitions can also be imported, specifying a
module/name pair and a suitable type. Each definition can optionally be exported under one or more names.
In addition to definitions, modules can define initialization data for their memories or tables that takes the
form of segments copied to given offsets. They can also define a start function that is automatically executed.
Embedder
A WebAssembly implementation will typically be embedded into a host environment. This environment
defines how loading of modules is initiated, how imports are provided (including host-side definitions), and
how exports can be accessed. However, the details of any particular embedding are beyond the scope of this
specification, and will instead be provided by complementary, environment-specific API definitions.

1.2.2 Semantic Phases
Conceptually, the semantics of WebAssembly is divided into three phases. For each part of the language, the
specification specifies each of them.
Decoding
WebAssembly modules are distributed in a binary format. Decoding processes that format and converts it
into an internal representation of a module. In this specification, this representation is modelled by abstract
syntax, but a real implementation could compile directly to machine code instead.
Validation
A decoded module has to be valid. Validation checks a number of well-formedness conditions to guarantee that the module is meaningful and safe. In particular, it performs type checking of functions and the
instruction sequences in their bodies, ensuring for example that the operand stack is used consistently.
Execution
Finally, a valid module can be executed. Execution can be further divided into two phases:
Instantiation. A module instance is the dynamic representation of a module, complete with its own state
and execution stack. Instantiation executes the module body itself, given definitions for all its imports. It
initializes globals, memories and tables and invokes the moduleâ€™s start function if defined. It returns the
instances of the moduleâ€™s exports.
Invocation. Once instantiated, further WebAssembly computations can be initiated by invoking an exported
function on a module instance. Given the required arguments, that executes the respective function and
returns its results.
Instantiation and invocation are operations within the embedding environment.

4

Chapter 1. Introduction

CHAPTER

2

Structure

2.1 Conventions
WebAssembly is a programming language that has multiple concrete representations (its binary format and the text
format). Both map to a common structure. For conciseness, this structure is described in the form of an abstract
syntax. All parts of this specification are defined in terms of this abstract syntax.

2.1.1 Grammar Notation
The following conventions are adopted in defining grammar rules for abstract syntax.
â€¢ Terminal symbols (atoms) are written in sans-serif font or in symbolic form: i32, end, â†’, [, ].
â€¢ Nonterminal symbols are written in italic font: valtype, instr .
â€¢ ğ´ğ‘› is a sequence of ğ‘› â‰¥ 0 iterations of ğ´.
â€¢ ğ´* is a possibly empty sequence of iterations of ğ´. (This is a shorthand for ğ´ğ‘› used where ğ‘› is not relevant.)
â€¢ ğ´+ is a non-empty sequence of iterations of ğ´. (This is a shorthand for ğ´ğ‘› where ğ‘› â‰¥ 1.)
â€¢ ğ´? is an optional occurrence of ğ´. (This is a shorthand for ğ´ğ‘› where ğ‘› â‰¤ 1.)
â€¢ Productions are written sym ::= ğ´1 | . . . | ğ´ğ‘› .
â€¢ Large productions may be split into multiple definitions, indicated by ending the first one with explicit ellipses, sym ::= ğ´1 | . . ., and starting continuations with ellipses, sym ::= . . . | ğ´2 .
â€¢ Some productions are augmented with side conditions in parentheses, â€œ(if condition)â€, that provide a shorthand for a combinatorial expansion of the production into many separate cases.
â€¢ If the same meta variable or non-terminal symbol appears multiple times in a production, then all those
occurrences must have the same instantiation. (This is a shorthand for a side condition requiring multiple
different variables to be equal.)

2.1.2 Auxiliary Notation
When dealing with syntactic constructs the following notation is also used:
â€¢ ğœ– denotes the empty sequence.
â€¢ |ğ‘ | denotes the length of a sequence ğ‘ .
â€¢ ğ‘ [ğ‘–] denotes the ğ‘–-th element of a sequence ğ‘ , starting from 0.
5

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

â€¢ ğ‘ [ğ‘– : ğ‘›] denotes the sub-sequence ğ‘ [ğ‘–] . . . ğ‘ [ğ‘– + ğ‘› âˆ’ 1] of a sequence ğ‘ .
â€¢ ğ‘  with [ğ‘–] = ğ´ denotes the same sequence as ğ‘ , except that the ğ‘–-th element is replaced with ğ´.
â€¢ ğ‘  with [ğ‘– : ğ‘›] = ğ´ğ‘› denotes the same sequence as ğ‘ , except that the sub-sequence ğ‘ [ğ‘– : ğ‘›] is replaced with
ğ´ğ‘› .
â€¢ concat(ğ‘ * ) denotes the flat sequence formed by concatenating all sequences ğ‘ ğ‘– in ğ‘ * .
Moreover, the following conventions are employed:
â€¢ The notation ğ‘¥ğ‘› , where ğ‘¥ is a non-terminal symbol, is treated as a meta variable ranging over respective
sequences of ğ‘¥ (similarly for ğ‘¥* , ğ‘¥+ , ğ‘¥? ).
â€¢ When given a sequence ğ‘¥ğ‘› , then the occurrences of ğ‘¥ in a sequence written (ğ´1 ğ‘¥ ğ´2 )ğ‘› are assumed to be in
point-wise correspondence with ğ‘¥ğ‘› (similarly for ğ‘¥* , ğ‘¥+ , ğ‘¥? ). This implicitly expresses a form of mapping
syntactic constructions over a sequence.
Productions of the following form are interpreted as records that map a fixed set of fields fieldğ‘– to â€œvaluesâ€ ğ´ğ‘– ,
respectively:
r ::= {field1 ğ´1 , field2 ğ´2 , . . . }
The following notation is adopted for manipulating such records:
â€¢ ğ‘Ÿ.field denotes the contents of the field component of ğ‘Ÿ.
â€¢ ğ‘Ÿ with field = ğ´ denotes the same record as ğ‘Ÿ, except that the contents of the field component is replaced
with ğ´.
â€¢ ğ‘Ÿ1 âŠ•ğ‘Ÿ2 denotes the composition of two records with the same fields of sequences by appending each sequence
point-wise:
{field1 ğ´*1 , field2 ğ´*2 , . . . } âŠ• {field1 ğµ1* , field2 ğµ2* , . . . } = {field1 ğ´*1 ğµ1* , field2 ğ´*2 ğµ2* , . . . }
â€¢

â¨ï¸€ *
ğ‘Ÿ denotes the composition of a sequence of records, respectively; if the sequence is empty, then all fields
of the resulting record are empty.

The update notation for sequences and records generalizes recursively to nested components accessed by â€œpathsâ€
pth ::= ([. . . ] | .field)+ :
â€¢ ğ‘  with [ğ‘–] pth = ğ´ is short for ğ‘  with [ğ‘–] = (ğ‘ [ğ‘–] with pth = ğ´),
â€¢ ğ‘Ÿ with field pth = ğ´ is short for ğ‘Ÿ with field = (ğ‘Ÿ.field with pth = ğ´),
where ğ‘Ÿ with .field = ğ´ is shortened to ğ‘Ÿ with field = ğ´.

2.1.3 Vectors
Vectors are bounded sequences of the form ğ´ğ‘› (or ğ´* ), where the ğ´ can either be values or complex constructions.
A vector can have at most 232 âˆ’ 1 elements.
vec(ğ´)

::= ğ´ğ‘›

(if ğ‘› < 232 )

2.2 Values
WebAssembly programs operate on primitive numeric values. Moreover, in the definition of programs, immutable
sequences of values occur to represent more complex data, such as text strings or other vectors.

2.2.1 Bytes
The simplest form of value are raw uninterpreted bytes. In the abstract syntax they are represented as hexadecimal
literals.
byte
6

::= 0x00 | . . . | 0xFF
Chapter 2. Structure

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

Conventions
â€¢ The meta variable ğ‘ ranges over bytes.
â€¢ Bytes are sometimes interpreted as natural numbers ğ‘› < 256.

2.2.2 Integers
Different classes of integers with different value ranges are distinguished by their bit width ğ‘ and by whether they
are unsigned or signed.
uğ‘
sğ‘
iğ‘

::= 0 | 1 | . . . | 2ğ‘ âˆ’1
::= âˆ’2ğ‘ âˆ’1 | . . . | âˆ’1 | 0 | 1 | . . . | 2ğ‘ âˆ’1 âˆ’1
::= uğ‘

The class i ğ‘ defines uninterpreted integers, whose signedness interpretation can vary depending on context. In
the abstract syntax, they are represented as unsigned values. However, some operations convert them to signed
based on a twoâ€™s complement interpretation.
Ã² Note
The main integer types occurring in this specification are u32 , u64 , s32 , s64 , i8 , i16 , i32 , i64 . However,
other sizes occur as auxiliary constructions, e.g., in the definition of floating-point numbers.
Conventions
â€¢ The meta variables ğ‘š, ğ‘›, ğ‘– range over integers.
â€¢ Numbers may be denoted by simple arithmetics, as in the grammar above. In order to distinguish arithmetics
like 2ğ‘ from sequences like (1)ğ‘ , the latter is distinguished with parentheses.

2.2.3 Floating-Point
Floating-point data represents 32 or 64 bit values that correspond to the respective binary formats of the IEEE
7549 standard (Section 3.3).
Every value has a sign and a magnitude. Magnitudes can either be expressed as normal numbers of the form
ğ‘š0 .ğ‘š1 ğ‘š2 . . . ğ‘šğ‘€ Â· 2ğ‘’ , where ğ‘’ is the exponent and ğ‘š is the significand whose most significant bit ğ‘š0 is 1, or as a
subnormal number where the exponent is fixed to the smallest possible value and ğ‘š0 is 0; among the subnormals
are positive and negative zero values. Since the significands are binary values, normals are represented in the form
(1 + ğ‘š Â· 2âˆ’ğ‘€ ) Â· 2ğ‘’ , where ğ‘€ is the bit width of ğ‘š; similarly for subnormals.
Possible magnitudes also include the special values âˆ (infinity) and nan (NaN, not a number). NaN values have a
payload that describes the mantissa bits in the underlying binary representation. No distinction is made between
signalling and quiet NaNs.
fğ‘
f Nmag

::=
::=
|
|
|

+f Nmag | âˆ’f Nmag
(1 + uğ‘€ Â· 2âˆ’ğ‘€ ) Â· 2ğ‘’
(0 + uğ‘€ Â· 2âˆ’ğ‘€ ) Â· 2ğ‘’
âˆ
nan(ğ‘›)

(if âˆ’2ğ¸âˆ’1 + 2 â‰¤ ğ‘’ â‰¤ 2ğ¸âˆ’1 âˆ’ 1)
(if ğ‘’ = âˆ’2ğ¸âˆ’1 + 2)
(if 1 â‰¤ ğ‘› < 2ğ‘€ )

where ğ‘€ = signif(ğ‘ ) and ğ¸ = expon(ğ‘ ) with
signif(32)
signif(64)

=
=

23
52

expon(32)
expon(64)

=
=

8
11

A canonical NaN is a floating-point value Â±nan(canonğ‘ ) where canonğ‘ is a payload whose most significant bit
is 1 while all others are 0:
canonğ‘ = 2signif(ğ‘ )âˆ’1
9 https://ieeexplore.ieee.org/document/8766229

2.2. Values

7

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

An arithmetic NaN is a floating-point value Â±nan(ğ‘›) with ğ‘› â‰¥ canonğ‘ , such that the most significant bit is 1
while all others are arbitrary.
Ã² Note
In the abstract syntax, subnormals are distinguished by the leading 0 of the significand. The exponent of
subnormals has the same value as the smallest possible exponent of a normal number. Only in the binary
representation the exponent of a subnormal is encoded differently than the exponent of any normal number.
The notion of canonical NaN defined here is unrelated to the notion of canonical NaN that the IEEE 75410
standard (Section 3.5.2) defines for decimal interchange formats.
Conventions
â€¢ The meta variable ğ‘§ ranges over floating-point values where clear from context.

2.2.4 Vectors
Numeric vectors are 128-bit values that are processed by vector instructions (also known as SIMD instructions,
single instruction multiple data). They are represented in the abstract syntax using i128 . The interpretation of
lane types (integer or floating-point numbers) and lane sizes are determined by the specific instruction operating
on them.

2.2.5 Names
Names are sequences of characters, which are scalar values as defined by Unicode11 (Section 2.4).
name
char

::=
::=

char *
(if |utf8(char * )| < 232 )
U+00 | . . . | U+D7FF | U+E000 | . . . | U+10FFFF

Due to the limitations of the binary format, the length of a name is bounded by the length of its UTF-8 encoding.
Convention
â€¢ Characters (Unicode scalar values) are sometimes used interchangeably with natural numbers ğ‘› < 1114112.

2.3 Types
Various entities in WebAssembly are classified by types. Types are checked during validation, instantiation, and
possibly execution.

2.3.1 Number Types
Number types classify numeric values.
numtype

::= i32 | i64 | f32 | f64

The types i32 and i64 classify 32 and 64 bit integers, respectively. Integers are not inherently signed or unsigned,
their interpretation is determined by individual operations.
The types f32 and f64 classify 32 and 64 bit floating-point data, respectively. They correspond to the respective
binary floating-point representations, also known as single and double precision, as defined by the IEEE 75412
standard (Section 3.3).
Number types are transparent, meaning that their bit patterns can be observed. Values of number type can be stored
in memories.
10 https://ieeexplore.ieee.org/document/8766229
11 https://www.unicode.org/versions/latest/

12 https://ieeexplore.ieee.org/document/8766229

8

Chapter 2. Structure

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

Conventions
â€¢ The notation |ğ‘¡| denotes the bit width of a number type ğ‘¡. That is, |i32| = |f32| = 32 and |i64| = |f64| = 64.

2.3.2 Vector Types
Vector types classify vectors of numeric values processed by vector instructions (also known as SIMD instructions,
single instruction multiple data).
vectype

::= v128

The type v128 corresponds to a 128 bit vector of packed integer or floating-point data. The packed data can be
interpreted as signed or unsigned integers, single or double precision floating-point values, or a single 128 bit type.
The interpretation is determined by individual operations.
Vector types, like number types are transparent, meaning that their bit patterns can be observed. Values of vector
type can be stored in memories.
Conventions
â€¢ The notation |ğ‘¡| for bit width extends to vector types as well, that is, |v128| = 128.

2.3.3 Heap Types
Heap types classify objects in the runtime store. There are three disjoint hierarchies of heap types:
â€¢ function types classify functions,
â€¢ aggregate types classify dynamically allocated managed data, such as structures, arrays, or unboxed scalars,
â€¢ external types classify external references possibly owned by the embedder.
The values from the latter two hierarchies are interconvertible by ways of the extern.convert_any and
any.convert_extern instructions. That is, both type hierarchies are inhabited by an isomorphic set of values, but
may have different, incompatible representations in practice.
absheaptype

heaptype

::=
|
|
|
::=

func | nofunc
exn | noexn
extern | noextern
any | eq | i31 | struct | array | none
absheaptype | typeidx

A heap type is either abstract or concrete.
The abstract type func denotes the common supertype of all function types, regardless of their concrete definition.
Dually, the type nofunc denotes the common subtype of all function types, regardless of their concrete definition.
This type has no values.
The abstract type exn denotes the type of all exception references. Dually, the type noexn denotes the common
subtype of all forms of exception references. This type has no values.
The abstract type extern denotes the common supertype of all external references received through the embedder.
This type has no concrete subtypes. Dually, the type noextern denotes the common subtype of all forms of external
references. This type has no values.
The abstract type any denotes the common supertype of all aggregate types, as well as possibly abstract values
produced by internalizing an external reference of type extern. Dually, the type none denotes the common subtype
of all forms of aggregate types. This type has no values.
The abstract type eq is a subtype of any that includes all types for which references can be compared, i.e., aggregate
values and i31.
The abstract types struct and array denote the common supertypes of all structure and array aggregates, respectively.

2.3. Types

9

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

The abstract type i31 denotes unboxed scalars, that is, integers injected into references. Their observable value
range is limited to 31 bits.
Ã² Note
An i31 is not actually allocated in the store, but represented in a way that allows them to be mixed with actual
references into the store without ambiguity. Engines need to perform some form of pointer tagging to achieve
this, which is why 1 bit is reserved.
Although the types none, nofunc, noexn, and noextern are not inhabited by any values, they can be used to
form the types of all null references in their respective hierarchy. For example, (ref null nofunc) is the generic
type of a null reference compatible with all function reference types.
A concrete heap type consists of a type index and classifies an object of the respective type defined in a module.
The syntax of heap types is extended with additional forms for the purpose of specifying validation and execution.

2.3.4 Reference Types
Reference types classify values that are first-class references to objects in the runtime store.
reftype

::= ref null? heaptype

A reference type is characterised by the heap type it points to.
In addition, a reference type of the form ref null ht is nullable, meaning that it can either be a proper reference to
ht or null. Other references are non-null.
Reference types are opaque, meaning that neither their size nor their bit pattern can be observed. Values of reference
type can be stored in tables.
Conventions
â€¢ The reference type anyref is an abbreviation for ref null any.
â€¢ The reference type eqref is an abbreviation for ref null eq.
â€¢ The reference type i31ref is an abbreviation for ref null i31.
â€¢ The reference type structref is an abbreviation for ref null struct.
â€¢ The reference type arrayref is an abbreviation for ref null array.
â€¢ The reference type funcref is an abbreviation for ref null func.
â€¢ The reference type exnref is an abbreviation for ref null exn.
â€¢ The reference type externref is an abbreviation for ref null extern.
â€¢ The reference type nullref is an abbreviation for ref null none.
â€¢ The reference type nullfuncref is an abbreviation for ref null nofunc.
â€¢ The reference type nullexnref is an abbreviation for ref null noexn.
â€¢ The reference type nullexternref is an abbreviation for ref null noextern.

2.3.5 Value Types
Value types classify the individual values that WebAssembly code can compute with and the values that a variable
accepts. They are either number types, vector types, or reference types.
valtype

::= numtype | vectype | reftype

The syntax of value types is extended with additional forms for the purpose of specifying validation.

10

Chapter 2. Structure

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

Conventions
â€¢ The meta variable ğ‘¡ ranges over value types or subclasses thereof where clear from context.

2.3.6 Result Types
Result types classify the result of executing instructions or functions, which is a sequence of values, written with
brackets.
resulttype

::=

[vec(valtype)]

2.3.7 Function Types
Function types classify the signature of functions, mapping a vector of parameters to a vector of results. They are
also used to classify the inputs and outputs of instructions.
functype

::= resulttype â†’ resulttype

2.3.8 Aggregate Types
Aggregate types describe compound objects consisting of multiple values. These are either structures or arrays,
which both consist of a list of possibly mutable and possibly packed fields. Structures are heterogeneous, but
require static indexing, while arrays need to be homogeneous, but allow dynamic indexing.
structtype
arraytype
fieldtype
storagetype
packedtype

::=
::=
::=
::=
::=

fieldtype *
fieldtype
mut storagetype
valtype | packedtype
i8 | i16

Conventions
â€¢ The notation |ğ‘¡| for bit width extends to packed types as well, that is, |i8| = 8 and |i16| = 16.
â€¢ The auxiliary function unpack maps a storage type to the value type obtained when accessing a field:
unpack(valtype)
=
unpack(packedtype) =

valtype
i32

2.3.9 Composite Types
Composite types are all types composed from simpler types, including function types and aggregate types.
comptype

::=

func functype | struct structtype | array arraytype

2.3.10 Recursive Types
Recursive types denote a group of mutually recursive composite types, each of which can optionally declare a list
of type indices of supertypes that it matches. Each type can also be declared final, preventing further subtyping.
rectype
subtype

::= rec subtype *
::= sub final? typeidx * comptype

In a module, each member of a recursive type is assigned a separate type index.
The syntax of sub types is generalized for the purpose of specifying validation and execution.
2.3. Types

11

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

2.3.11 Address Type
Address types are a subset of number types that classify the values that can be used as offsets into memories and
tables.
addrtype

::=

i32 | i64

Conventions
The minimum of two address types is defined as the address type whose bit width is the minimum of the two.
min(at 1 , at 2 ) =
min(at 1 , at 2 ) =

at 1
at 2

(if |at 1 | â‰¤ |at 2 |)
(otherwise)

2.3.12 Limits
Limits classify the size range of resizeable storage associated with memory types and table types.
::= {min u64 , max u64 ? }

limits

If no maximum is given, the respective storage can grow to any size.

2.3.13 Memory Types
Memory types classify linear memories and their size range.
memtype

::= addrtype limits

The limits constrain the minimum and optionally the maximum size of a memory. The limits are given in units of
page size.

2.3.14 Table Types
Table types classify tables over elements of reference type within a size range.
tabletype

::= addrtype limits reftype

Like memories, tables are constrained by limits for their minimum and optionally maximum size. The limits are
given in numbers of entries.

2.3.15 Global Types
Global types classify global variables, which hold a value and can either be mutable or immutable.
globaltype
mut

::=
::=

mut valtype
const | var

2.3.16 Tag Types
Tag types classify the signature of tags with a defined type deftype, which expands to a function type functype.
tagtype

::= deftype

Currently tags are only used for categorizing exceptions. The parameters of functype define the list of values
associated with the exception thrown with this tag. Furthermore, it is an invariant of the semantics that every
functype in a valid tag type for an exception has an empty result type.

12

Chapter 2. Structure

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

Ã² Note
Future versions of WebAssembly may have additional uses for tags, and may allow non-empty result types in
the function types of tags.

2.3.17 External Types
External types classify imports and external values with their respective types.
externtype

::= func deftype | table tabletype | mem memtype | global globaltype | tag tagtype

Conventions
The following auxiliary notation is defined for sequences of external types. It filters out entries of a specific kind
in an order-preserving fashion:
â€¢ funcs(externtype * ) = [deftype | (func deftype) âˆˆ externtype * ]
â€¢ tables(externtype * ) = [tabletype | (table tabletype) âˆˆ externtype * ]
â€¢ mems(externtype * ) = [memtype | (mem memtype) âˆˆ externtype * ]
â€¢ globals(externtype * ) = [globaltype | (global globaltype) âˆˆ externtype * ]
â€¢ tags(externtype * ) = [tagtype | (tag tagtype) âˆˆ externtype * ]

2.4 Instructions
WebAssembly code consists of sequences of instructions. Its computational model is based on a stack machine
in that instructions manipulate values on an implicit operand stack, consuming (popping) argument values and
producing or returning (pushing) result values.
In addition to dynamic operands from the stack, some instructions also have static immediate arguments, typically
indices or type annotations, which are part of the instruction itself.
Some instructions are structured in that they bracket nested sequences of instructions.
The following sections group instructions into a number of different categories.

2.4. Instructions

13

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

2.4.1 Numeric Instructions
Numeric instructions provide basic operations over numeric values of specific type. These operations closely match
respective operations available in hardware.
nn, mm
sx
instr

iunop
ibinop
funop
fbinop
itestop
irelop
frelop

::=
::=
::=
|
|
|
|
|
|
|
|
|
|
::=
::=
|
::=
::=
::=
::=
::=

32 | 64
u|s
inn.const unn | fnn.const f nn
inn.iunop | fnn.funop
inn.ibinop | fnn.fbinop
inn.itestop
inn.irelop | fnn.frelop
inn.extend8_s | inn.extend16_s | i64.extend32_s
i32.wrap_i64 | i64.extend_i32_sx | inn.trunc_fmm_sx
inn.trunc_sat_fmm_sx
f32.demote_f64 | f64.promote_f32 | fnn.convert_imm_sx
inn.reinterpret_fnn | fnn.reinterpret_inn
...
clz | ctz | popcnt
add | sub | mul | div_sx | rem_sx
and | or | xor | shl | shr_sx | rotl | rotr
abs | neg | sqrt | ceil | floor | trunc | nearest
add | sub | mul | div | min | max | copysign
eqz
eq | ne | lt_sx | gt_sx | le_sx | ge_sx
eq | ne | lt | gt | le | ge

Numeric instructions are divided by number type. For each type, several subcategories can be distinguished:
â€¢ Constants: return a static constant.
â€¢ Unary Operations: consume one operand and produce one result of the respective type.
â€¢ Binary Operations: consume two operands and produce one result of the respective type.
â€¢ Tests: consume one operand of the respective type and produce a Boolean integer result.
â€¢ Comparisons: consume two operands of the respective type and produce a Boolean integer result.
â€¢ Conversions: consume a value of one type and produce a result of another (the source type of the conversion
is the one after the â€œ_â€).
Some integer instructions come in two flavors, where a signedness annotation sx distinguishes whether the operands
are to be interpreted as unsigned or signed integers. For the other integer instructions, the use of twoâ€™s complement
for the signed interpretation means that they behave the same regardless of signedness.
Conventions
Occasionally, it is convenient to group operators together according to the following grammar shorthands:
unop
binop
testop
relop
cvtop

14

::=
::=
::=
::=
::=

iunop | funop | extendğ‘ _s
ibinop | fbinop
itestop
irelop | frelop
wrap | extend | trunc | trunc_sat | convert | demote | promote | reinterpret

Chapter 2. Structure

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

2.4.2 Vector Instructions
Vector instructions (also known as SIMD instructions, single instruction multiple data) provide basic operations
over values of vector type.
ishape
fshape
shape
half
laneidx
instr

::=
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|

::=
::=
::=
::=
::=

i8x16 | i16x8 | i32x4 | i64x2
f32x4 | f64x2
ishape | fshape
low | high
u8

...
v128.const i128
v128.vvunop
v128.vvbinop
v128.vvternop
v128.vvtestop
i8x16.shuffle laneidx 16
i8x16.swizzle
shape.splat
i8x16.extract_lane_sx laneidx | i16x8.extract_lane_sx laneidx
i32x4.extract_lane laneidx | i64x2.extract_lane laneidx
fshape.extract_lane laneidx
shape.replace_lane laneidx
i8x16.virelop | i16x8.virelop | i32x4.virelop
i64x2.eq | i64x2.ne | i64x2.lt_s | i64x2.gt_s | i64x2.le_s | i64x2.ge_s
fshape.vfrelop
ishape.viunop | i8x16.popcnt
i16x8.q15mulr_sat_s
i32x4.dot_i16x8_s
fshape.vfunop
ishape.vitestop
ishape.bitmask
i8x16.narrow_i16x8_sx | i16x8.narrow_i32x4_sx
i16x8.extend_half _i8x16_sx | i32x4.extend_half _i16x8_sx
i64x2.extend_half _i32x4_sx
ishape.vishiftop
ishape.vibinop
i8x16.viminmaxop | i16x8.viminmaxop | i32x4.viminmaxop
i8x16.visatbinop | i16x8.visatbinop
i16x8.mul | i32x4.mul | i64x2.mul
i8x16.avgr_u | i16x8.avgr_u
i16x8.extmul_half _i8x16_sx | i32x4.extmul_half _i16x8_sx | i64x2.extmul_half _i32x4_sx
i16x8.extadd_pairwise_i8x16_sx | i32x4.extadd_pairwise_i16x8_sx
fshape.vfbinop
i32x4.trunc_sat_f32x4_sx | i32x4.trunc_sat_f64x2_sx _zero
f32x4.convert_i32x4_sx | f32x4.demote_f64x2_zero
f64x2.convert_low_i32x4_sx | f64x2.promote_low_f32x4
i8x16.relaxed_swizzle
i16x8.relaxed_q15mulr_s
i32x4.relaxed_trunc_f32x4_sx
i16x8.relaxed_dot_i8x16_i7x16_s
i32x4.relaxed_dot_i8x16_i7x16_add_s
ishape.relaxed_laneselect
fshape.rvfternop
fshape.rvfbinop
...

2.4. Instructions

15

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)
vvunop
vvbinop
vvternop
vvtestop
vitestop
virelop
vfrelop
viunop
vibinop
viminmaxop
visatbinop
vishiftop
vfunop
vfbinop
rvfbinop
rvfternop

::=
::=
::=
::=
::=
::=
::=
::=
::=
::=
::=
::=
::=
::=
::=
::=

not
and | andnot | or | xor
bitselect
any_true
all_true
eq | ne | lt_sx | gt_sx | le_sx | ge_sx
eq | ne | lt | gt | le | ge
abs | neg
add | sub
min_sx | max_sx
add_sat_sx | sub_sat_sx
shl | shr_sx
abs | neg | sqrt | ceil | floor | trunc | nearest
add | sub | mul | div | min | max | pmin | pmax
relaxed_min | relaxed_max
relaxed_madd | relaxed_nmadd

Vector instructions have a naming convention involving a prefix that determines how their operands will be interpreted. This prefix describes the shape of the operand, written ğ‘¡xğ‘ , and consisting of a packed numeric type ğ‘¡ and
the number of lanes ğ‘ of that type. Operations are performed point-wise on the values of each lane.
Ã² Note
For example, the shape i32x4 interprets the operand as four i32 values, packed into an i128 . The bit width of
the numeric type ğ‘¡ times ğ‘ always is 128.
Instructions prefixed with v128 do not involve a specific interpretation, and treat the v128 as an i128 value or a
vector of 128 individual bits.
Vector instructions can be grouped into several subcategories:
â€¢ Constants: return a static constant.
â€¢ Unary Operations: consume one v128 operand and produce one v128 result.
â€¢ Binary Operations: consume two v128 operands and produce one v128 result.
â€¢ Ternary Operations: consume three v128 operands and produce one v128 result.
â€¢ Tests: consume one v128 operand and produce a Boolean integer result.
â€¢ Shifts: consume a v128 operand and a i32 operand, producing one v128 result.
â€¢ Splats: consume a value of numeric type and produce a v128 result of a specified shape.
â€¢ Extract lanes: consume a v128 operand and return the numeric value in a given lane.
â€¢ Replace lanes: consume a v128 operand and a numeric value for a given lane, and produce a v128 result.
Some vector instructions have a signedness annotation sx which distinguishes whether the elements in the operands
are to be interpreted as unsigned or signed integers. For the other vector instructions, the use of twoâ€™s complement
for the signed interpretation means that they behave the same regardless of signedness.

16

Chapter 2. Structure

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

Conventions
Occasionally, it is convenient to group operators together according to the following grammar shorthands:
vunop
vbinop

vternop
vtestop
vrelop
vcvtop

::=
::=
|
|
|
|
::=
::=
::=
::=

viunop | vfunop | popcnt
vibinop | vfbinop
viminmaxop | visatbinop
rvfbinop
mul | avgr_u | q15mulr_sat_s
relaxed_q15mulr_s_s
vvternop | rvfternop
vitestop
virelop | vfrelop
extend | trunc_sat | convert | demote | promote | relaxed_trunc

2.4.3 Reference Instructions
Instructions in this group are concerned with accessing references.
instr

::=
|
|
|
|
|
|
|

...
ref.null heaptype
ref.func funcidx
ref.is_null
ref.as_non_null
ref.eq
ref.test reftype
ref.cast reftype

The ref.null and ref.func instructions produce a null value or a reference to a given function, respectively.
The instruction ref.is_null checks for null, while ref.as_non_null converts a nullable to a non-null one, and traps
if it encounters null.
The ref.eq compares two references.
The instructions ref.test and ref.cast test the dynamic type of a reference operand. The former merely returns the
result of the test, while the latter performs a downcast and traps if the operandâ€™s type does not match.
Ã² Note
The br_on_cast and br_on_cast_fail instructions provides versions of the latter that branch depending on the
success of the downcast instead of trapping.

2.4. Instructions

17

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

2.4.4 Aggregate Instructions
Instructions in this group are concerned with creating and accessing references to aggregate types.
instr

::=
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|

...
struct.new typeidx
struct.new_default typeidx
struct.get typeidx fieldidx
struct.get_sx typeidx fieldidx
struct.set typeidx fieldidx
array.new typeidx
array.new_fixed typeidx u32
array.new_default typeidx
array.new_data typeidx dataidx
array.new_elem typeidx elemidx
array.get typeidx
array.get_sx typeidx
array.set typeidx
array.len
array.fill typeidx
array.copy typeidx typeidx
array.init_data typeidx dataidx
array.init_elem typeidx elemidx
ref.i31
i31.get_sx
any.convert_extern
extern.convert_any

The instructions struct.new and struct.new_default allocate a new structure, initializing them either with operands
or with default values. The remaining instructions on structs access individual fields, allowing for different sign
extension modes in the case of packed storage types.
Similarly, arrays can be allocated either with an explicit initialization operand or a default value. Furthermore,
array.new_fixed allocates an array with statically fixed size, and array.new_data and array.new_elem allocate
an array and initialize it from a data or element segment, respectively. array.get, array.get_s, array.get_u, and
array.set access individual slots, again allowing for different sign extension modes in the case of a packed storage
type. array.len produces the length of an array. array.fill fills a specified slice of an array with a given value and
array.copy, array.init_data, and array.init_elem copy elements to a specified slice of an array from a given array,
data segment, or element segment, respectively.
The instructions ref.i31 and i31.get_sx convert between type i31 and an unboxed scalar.
The instructions any.convert_extern and extern.convert_any allow lossless conversion between references represented as type (ref null extern).

2.4.5 Parametric Instructions
Instructions in this group can operate on operands of any value type.
instr

::= . . .
| drop
| select (valtype * )?

The drop instruction simply throws away a single operand.
The select instruction selects one of its first two operands based on whether its third operand is zero or not. It may
include a value type determining the type of these operands. If missing, the operands must be of numeric or vector
type.

18

Chapter 2. Structure

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

Ã² Note
In future versions of WebAssembly, the type annotation on select may allow for more than a single value being
selected at the same time.

2.4.6 Variable Instructions
Variable instructions are concerned with access to local or global variables.
instr

::=
|
|
|
|
|

...
local.get localidx
local.set localidx
local.tee localidx
global.get globalidx
global.set globalidx

These instructions get or set the values of variables, respectively. The local.tee instruction is like local.set but also
returns its argument.

2.4.7 Table Instructions
Instructions in this group are concerned with tables table.
instr

::=
|
|
|
|
|
|
|
|

...
table.get tableidx
table.set tableidx
table.size tableidx
table.grow tableidx
table.fill tableidx
table.copy tableidx tableidx
table.init tableidx elemidx
elem.drop elemidx

The table.get and table.set instructions load or store an element in a table, respectively.
The table.size instruction returns the current size of a table. The table.grow instruction grows table by a given
delta and returns the previous size, or âˆ’1 if enough space cannot be allocated. It also takes an initialization value
for the newly allocated entries.
The table.fill instruction sets all entries in a range to a given value.
The table.copy instruction copies elements from a source table region to a possibly overlapping destination region;
the first index denotes the destination. The table.init instruction copies elements from a passive element segment
into a table. The elem.drop instruction prevents further use of a passive element segment. This instruction is
intended to be used as an optimization hint. After an element segment is dropped its elements can no longer be
retrieved, so the memory used by this segment may be freed.
An additional instruction that accesses a table is the control instruction call_indirect.

2.4. Instructions

19

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

2.4.8 Memory Instructions
Instructions in this group are concerned with linear memory.
memarg
nn
ww
instr

::=
::=
::=
::=
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|

{offset u64 , align u32 }
32 | 64
8 | 16 | 32 | 64
...
inn.load memidx memarg | fnn.load memidx memarg
v128.load memidx memarg
inn.store memidx memarg | fnn.store memidx memarg
v128.store memidx memarg
inn.load8_sx memidx memarg | inn.load16_sx memidx memarg | i64.load32_sx memidx memarg
v128.load8x8_sx memidx memarg | v128.load16x4_sx memidx memarg | v128.load32x2_sx memidx mem
v128.load32_zero memidx memarg | v128.load64_zero memidx memarg
v128.loadww _splat memidx memarg
v128.loadww _lane memidx memarg laneidx | inn.store8 memidx memarg | inn.store16 memidx memarg
v128.storeww _lane memidx memarg laneidx
memory.size memidx
memory.grow memidx
memory.fill memidx
memory.copy memidx memidx
memory.init memidx dataidx
data.drop dataidx

Memory is accessed with load and store instructions for the different number types and vector types. They all
take a memory index and a memory immediate memarg that contains an address offset and the expected alignment
(expressed as the exponent of a power of 2).
Integer loads and stores can optionally specify a storage size that is smaller than the bit width of the respective
value type. In the case of loads, a sign extension mode sx is then required to select appropriate behavior.
Vector loads can specify a shape that is half the bit width of v128. Each lane is half its usual size, and the sign
extension mode sx then specifies how the smaller lane is extended to the larger lane. Alternatively, vector loads
can perform a splat, such that only a single lane of the specified storage size is loaded, and the result is duplicated
to all lanes.
The static address offset is added to the dynamic address operand, yielding a 33-bit or 65-bit effective address that
is the zero-based index at which the memory is accessed. All values are read and written in little endian13 byte
order. A trap results if any of the accessed memory bytes lies outside the address range implied by the memoryâ€™s
current size.
The memory.size instruction returns the current size of a memory. The memory.grow instruction grows a memory
by a given delta and returns the previous size, or âˆ’1 if enough memory cannot be allocated. Both instructions
operate in units of page size. The memory.fill instruction sets all values in a region of a memory to a given byte.
The memory.copy instruction copies data from a source memory region to a possibly overlapping destination region
in another or the same memory; the first index denotes the destination. The memory.init instruction copies data
from a passive data segment into a memory. The data.drop instruction prevents further use of a passive data
segment. This instruction is intended to be used as an optimization hint. After a data segment is dropped its data
can no longer be retrieved, so the memory used by this segment may be freed.
13 https://en.wikipedia.org/wiki/Endianness#Little-endian

20

Chapter 2. Structure

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

2.4.9 Control Instructions
Instructions in this group affect the flow of control.
blocktype
instr

catch

::=
::=
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
::=
|
|
|

typeidx | valtype ?
...
nop
unreachable
block blocktype instr * end
loop blocktype instr * end
if blocktype instr * else instr * end
br labelidx
br_if labelidx
br_table vec(labelidx ) labelidx
br_on_null labelidx
br_on_non_null labelidx
br_on_cast labelidx reftype reftype
br_on_cast_fail labelidx reftype reftype
return
call funcidx
call_ref typeidx
call_indirect tableidx typeidx
return_call funcidx
return_call_ref typeidx
return_call_indirect tableidx typeidx
throw tagidx
throw_ref
try_table blocktype catch * instr * end
catch tagidx labelidx
catch_ref tagidx labelidx
catch_all labelidx
catch_all_ref labelidx

The nop instruction does nothing.
The unreachable instruction causes an unconditional trap.
The block, loop, if, and try_table instructions are structured instructions. They bracket nested sequences of instructions, called blocks, separated by the else pseudo-instruction, and terminated with an end pseudo-instruction.
As the grammar prescribes, they must be well-nested.
The instructions throw, throw_ref, and try_table are concerned with exceptions. The try_table instruction installs
an exception handler that handles exceptions as specified by its catch clauses.. The throw and throw_ref instructions raise and reraise an exception, respectively, and transfers control to the innermost enclosing exception handler
that has a matching catch clause.
A structured instruction can consume input and produce output on the operand stack according to its annotated
block type. It is given either as a type index that refers to a suitable function type reinterpreted as an instruction
type, or as an optional value type inline, which is a shorthand for the instruction type [] â†’ [valtype ? ].
Each structured control instruction introduces an implicit label. Labels are targets for branch instructions that
reference them with label indices. Unlike with other index spaces, indexing of labels is relative by nesting depth,
that is, label 0 refers to the innermost structured control instruction enclosing the referring branch instruction, while
increasing indices refer to those farther out. Consequently, labels can only be referenced from within the associated
structured control instruction. This also implies that branches can only be directed outwards, â€œbreakingâ€ from the
block of the control construct they target. The exact effect depends on that control construct. In case of block or
if it is a forward jump, resuming execution after the matching end. In case of loop it is a backward jump to the
beginning of the loop.
Ã² Note

2.4. Instructions

21

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

This enforces structured control flow. Intuitively, a branch targeting a block or if behaves like a break statement
in most C-like languages, while a branch targeting a loop behaves like a continue statement.
Branch instructions come in several flavors: br performs an unconditional branch, br_if performs a conditional
branch, and br_table performs an indirect branch through an operand indexing into the label vector that is an immediate to the instruction, or to a default target if the operand is out of bounds. The br_on_null and br_on_non_null
instructions check whether a reference operand is null and branch if that is the case or not the case, respectively.
Similarly, br_on_cast and br_on_cast_fail attempt a downcast on a reference operand and branch if that succeeds,
or fails, respectively.
The return instruction is a shortcut for an unconditional branch to the outermost block, which implicitly is the body
of the current function. Taking a branch unwinds the operand stack up to the height where the targeted structured
control instruction was entered. However, branches may additionally consume operands themselves, which they
push back on the operand stack after unwinding. Forward branches require operands according to the output of
the targeted blockâ€™s type, i.e., represent the values produced by the terminated block. Backward branches require
operands according to the input of the targeted blockâ€™s type, i.e., represent the values consumed by the restarted
block.
The call instruction invokes another function, consuming the necessary arguments from the stack and returning
the result values of the call. The call_ref instruction invokes a function indirectly through a function reference
operand. The call_indirect instruction calls a function indirectly through an operand indexing into a table that is
denoted by a table index and must contain function references. Since it may contain functions of heterogeneous
type, the callee is dynamically checked against the function type indexed by the instructionâ€™s second immediate,
and the call is aborted with a trap if it does not match.
The return_call, return_call_ref, and return_call_indirect instructions are tail-call variants of the previous ones.
That is, they first return from the current function before actually performing the respective call. It is guaranteed
that no sequence of nested calls using only these instructions can cause resource exhaustion due to hitting an
implementationâ€™s limit on the number of active calls.

2.4.10 Expressions
Function bodies, initialization values for globals, elements and offsets of element segments, and offsets of data
segments are given as expressions, which are sequences of instructions terminated by an end marker.
expr

::= instr * end

In some places, validation restricts expressions to be constant, which limits the set of allowable instructions.

2.5 Modules
WebAssembly programs are organized into modules, which are the unit of deployment, loading, and compilation.
A module collects definitions for types, functions, tables, memories, tags, and globals. In addition, it can declare
imports and exports and provide initialization in the form of data and element segments, or a start function.
module

::= {

types vec(rectype),
funcs vec(func),
tables vec(table),
mems vec(mem),
globals vec(global ),
tags vec(tag),
elems vec(elem),
datas vec(data),
start start ? ,
imports vec(import),
exports vec(export) }

Each of the vectors â€“ and thus the entire module â€“ may be empty.

22

Chapter 2. Structure

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

2.5.1 Indices
Definitions are referenced with zero-based indices. Each class of definition has its own index space, as distinguished
by the following classes.
typeidx
funcidx
tableidx
memidx
globalidx
tagidx
elemidx
dataidx
localidx
labelidx
fieldidx

::=
::=
::=
::=
::=
::=
::=
::=
::=
::=
::=

u32
u32
u32
u32
u32
u32
u32
u32
u32
u32
u32

The index space for functions, tables, memories, globals, and tags includes respective imports declared in the same
module. The indices of these imports precede the indices of other definitions in the same index space.
Element indices reference element segments and data indices reference data segments.
The index space for locals is only accessible inside a function and includes the parameters of that function, which
precede the local variables.
Label indices reference structured control instructions inside an instruction sequence.
Each aggregate type provides an index space for its fields.
Conventions
â€¢ The meta variable ğ‘™ ranges over label indices.
â€¢ The meta variables ğ‘¥, ğ‘¦ range over indices in any of the other index spaces.
â€¢ The notation idx(ğ´) denotes the set of indices from index space idx occurring free in ğ´. Sometimes this
set is reinterpreted as the vector of its elements.
Ã² Note
For example, if instr * is (data.drop ğ‘¥)(memory.init ğ‘¦), then dataidx(instr * ) = {ğ‘¥, ğ‘¦}, or equivalently, the
vector ğ‘¥ ğ‘¦.

2.5.2 Types
The types component of a module defines a vector of recursive types, each of consisting of a list of sub types
referenced by individual type indices. All function or aggregate types used in a module must be defined in this
component.

2.5.3 Functions
The funcs component of a module defines a vector of functions with the following structure:
func
local

::= {type typeidx , locals vec(local ), body expr }
::= {type valtype}

The type of a function declares its signature by reference to a type defined in the module. The parameters of the
function are referenced through 0-based local indices in the functionâ€™s body; they are mutable.
The locals declare a vector of mutable local variables and their types. These variables are referenced through local
indices in the functionâ€™s body. The index of the first local is the smallest index not referencing a parameter.

2.5. Modules

23

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

The body is an instruction sequence that upon termination must produce a stack matching the function typeâ€™s result
type.
Functions are referenced through function indices, starting with the smallest index not referencing a function import.

2.5.4 Tables
The tables component of a module defines a vector of tables described by their table type:
table

::= {type tabletype, init expr }

A table is an array of opaque values of a particular reference type. Moreover, each table slot is initialized with the
init value given by a constant initializer expression. Tables can further be initialized through element segments.
The min size in the limits of the table type specifies the initial size of that table, while its max, if present, restricts
the size to which it can grow later.
Tables are referenced through table indices, starting with the smallest index not referencing a table import. Most
constructs implicitly reference table index 0.

2.5.5 Memories
The mems component of a module defines a vector of linear memories (or memories for short) as described by
their memory type:
mem

::= {type memtype}

A memory is a vector of raw uninterpreted bytes. The min size in the limits of the memory type specifies the initial
size of that memory, while its max, if present, restricts the size to which it can grow later. Both are in units of page
size.
Memories can be initialized through data segments.
Memories are referenced through memory indices, starting with the smallest index not referencing a memory
import. Most constructs implicitly reference memory index 0.

2.5.6 Globals
The globals component of a module defines a vector of global variables (or globals for short):
global

::= {type globaltype, init expr }

Each global stores a single value of the given global type. Its type also specifies whether a global is immutable or
mutable. Moreover, each global is initialized with an init value given by a constant initializer expression.
Globals are referenced through global indices, starting with the smallest index not referencing a global import.

2.5.7 Tags
The tags component of a module defines a vector of tags with the following structure.
tag

::= {type typeidx }

The result type of the function signature with type index typeidx must be empty.
Tags are referenced through tag indices, starting with the smallest index not referencing a tag import.

24

Chapter 2. Structure

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

2.5.8 Element Segments
The initial contents of a table is uninitialized. Element segments can be used to initialize a subrange of a table from
a static vector of elements.
The elems component of a module defines a vector of element segments. Each element segment defines a reference
type and a corresponding list of constant element expressions.
Element segments have a mode that identifies them as either passive, active, or declarative. A passive element
segmentâ€™s elements can be copied to a table using the table.init instruction. An active element segment copies its
elements into a table during instantiation, as specified by a table index and a constant expression defining an offset
into that table. A declarative element segment is not available at runtime but merely serves to forward-declare
references that are formed in code with instructions like ref.func.
elem
elemmode

::=
::=
|
|

{type reftype, init vec(expr ), mode elemmode}
passive
active {table tableidx , offset expr }
declarative

The offset is given by a constant expression.
Element segments are referenced through element indices.

2.5.9 Data Segments
The initial contents of a memory are zero bytes. Data segments can be used to initialize a range of memory from
a static vector of bytes.
The datas component of a module defines a vector of data segments.
Like element segments, data segments have a mode that identifies them as either passive or active. A passive data
segmentâ€™s contents can be copied into a memory using the memory.init instruction. An active data segment copies
its contents into a memory during instantiation, as specified by a memory index and a constant expression defining
an offset into that memory.
data
datamode

::= {init vec(byte), mode datamode}
::= passive
| active {memory memidx , offset expr }

Data segments are referenced through data indices.
Ã² Note
In the current version of WebAssembly, at most one memory is allowed in a module. Consequently, the only
valid memidx is 0.

2.5.10 Start Function
The start component of a module declares the function index of a start function that is automatically invoked when
the module is instantiated, after tables and memories have been initialized.
start

::= {func funcidx }

Ã² Note
The start function is intended for initializing the state of a module. The module and its exports are not accessible
externally before this initialization has completed.

2.5. Modules

25

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

2.5.11 Exports
The exports component of a module defines a set of exports that become accessible to the host environment once
the module has been instantiated.
export
exportdesc

::=
::=
|
|
|
|

{name name, desc exportdesc}
func funcidx
table tableidx
mem memidx
global globalidx
tag tagidx

Each export is labeled by a unique name. Exportable definitions are functions, tables, memories, globals, and tags,
which are referenced through a respective descriptor.
Conventions
The following auxiliary notation is defined for sequences of exports, filtering out indices of a specific kind in an
order-preserving fashion:
â€¢ funcs(export * ) = [funcidx | func funcidx âˆˆ (export.desc)* ]
â€¢ tables(export * ) = [tableidx | table tableidx âˆˆ (export.desc)* ]
â€¢ mems(export * ) = [memidx | mem memidx âˆˆ (export.desc)* ]
â€¢ globals(export * ) = [globalidx | global globalidx âˆˆ (export.desc)* ]
â€¢ tags(export * ) = [tagidx | tag tagidx âˆˆ (export.desc)* ]

2.5.12 Imports
The imports component of a module defines a set of imports that are required for instantiation.
import
importdesc

::=
::=
|
|
|
|

{module name, name name, desc importdesc}
func typeidx
table tabletype
mem memtype
global globaltype
tag typeidx

Each import is labeled by a two-level name space, consisting of a module name and a name for an entity within
that module. Importable definitions are functions, tables, memories, globals, and tags. Each import is specified by
a descriptor with a respective type that a definition provided during instantiation is required to match.
Every import defines an index in the respective index space. In each index space, the indices of imports go before
the first index of any definition contained in the module itself.
Ã² Note
Unlike export names, import names are not necessarily unique. It is possible to import the same module/name
pair multiple times; such imports may even have different type descriptions, including different kinds of entities.
A module with such imports can still be instantiated depending on the specifics of how an embedder allows
resolving and supplying imports. However, embedders are not required to support such overloading, and a
WebAssembly module itself cannot implement an overloaded name.

26

Chapter 2. Structure

CHAPTER

3

Validation

3.1 Conventions
Validation checks that a WebAssembly module is well-formed. Only valid modules can be instantiated.
Validity is defined by a type system over the abstract syntax of a module and its contents. For each piece of abstract
syntax, there is a typing rule that specifies the constraints that apply to it. All rules are given in two equivalent
forms:
1. In prose, describing the meaning in intuitive form.
2. In formal notation, describing the rule in mathematical form.14
Ã² Note
The prose and formal rules are equivalent, so that understanding of the formal notation is not required to
read this specification. The formalism offers a more concise description in notation that is used widely in
programming languages semantics and is readily amenable to mathematical proof.
In both cases, the rules are formulated in a declarative manner. That is, they only formulate the constraints, they do
not define an algorithm. The skeleton of a sound and complete algorithm for type-checking instruction sequences
according to this specification is provided in the appendix.

3.1.1 Types
To define the semantics, the definition of some sorts of types is extended to include additional forms. By virtue
of not being representable in either the binary format or the text format, these forms cannot be used in a program;
they only occur during validation or execution.
valtype
absheaptype
heaptype
subtype

::=
::=
::=
::=

. . . | bot
. . . | bot
. . . | deftype | rec ğ‘–
sub final? heaptype * comptype

14 The semantics is derived from the following article: Andreas Haas, Andreas Rossberg, Derek Schuff, Ben Titzer, Dan Gohman, Luke
Wagner, Alon Zakai, JF Bastien, Michael Holman. Bringing the Web up to Speed with WebAssembly15 . Proceedings of the 38th ACM
SIGPLAN Conference on Programming Language Design and Implementation (PLDI 2017). ACM 2017.
15 https://dl.acm.org/citation.cfm?doid=3062341.3062363

27

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

The unique value type bot is a bottom type that matches all value types. Similarly, bot is also used as a bottom
type of all heap types.
Ã² Note
No validation rule uses bottom types explicitly, but various rules can pick any value or heap type, including
bottom. This ensures the existence of principal types, and thus a validation algorithm without back tracking.
A concrete heap type can consist of a defined type directly. this occurs as the result of substituting a type index
with its definition.
A concrete heap type may also be a recursive type index. Such an index refers to the ğ‘–-th component of a surrounding
recursive type. It occurs as the result of rolling up the definition of a recursive type.
Finally, the representation of supertypes in a sub type is generalized from mere type indices to heap types. They
occur as defined types or recursive type indices after substituting type indices or rolling up recursive types.
Ã² Note
It is an invariant of the semantics that sub types occur only in one of two forms: either as â€œsyntacticâ€ types
as in a source module, where all supertypes are type indices, or as â€œsemanticâ€ types, where all supertypes are
resolved to either defined types or recursive type indices.
A type of any form is closed when it does not contain a heap type that is a type index or a recursive type index
without a surrounding recursive type, i.e., all type indices have been substituted with their defined type and all free
recursive type indices have been unrolled.
Ã² Note
Recursive type indices are internal to a recursive type. They are distinguished from regular type indices and
represented such that two closed types are syntactically equal if and only if they have the same recursive structure.
Convention
â€¢ The difference rt 1 âˆ– rt 2 between two reference types is defined as follows:
(ref null?1 ht 1 ) âˆ– (ref null ht 2 ) = (ref ht 1 )
(ref null?1 ht 1 ) âˆ– (ref ht 2 )
= (ref null?1 ht 1 )
Ã² Note
This definition computes an approximation of the reference type that is inhabited by all values from rt 1 except
those from rt 2 . Since the type system does not have general union types, the defnition only affects the presence
of null and cannot express the absence of other values.

3.1.2 Defined Types
Defined types denote the individual types defined in a module. Each such type is represented as a projection from
the recursive type group it originates from, indexed by its position in that group.
deftype

::= rectype.ğ‘–

Defined types do not occur in the binary or text format, but are formed by rolling up the recursive types defined in
a module.
It is hence an invariant of the semantics that all recursive types occurring in defined types are rolled up.
28

Chapter 3. Validation

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

Conventions
â€¢ ğ‘¡[ğ‘¥* := dt * ] denotes the parallel substitution of type indices ğ‘¥* with defined types dt * in type ğ‘¡, provided
|ğ‘¥* | = |dt * |.
â€¢ ğ‘¡[(rec ğ‘–)* := dt * ] denotes the parallel substitution of recursive type indices (rec ğ‘–)* with defined types dt *
in type ğ‘¡, provided |(rec ğ‘–)* | = |dt * |.
â€¢ ğ‘¡[:= dt * ] is shorthand for the substitution ğ‘¡[ğ‘¥* := dt * ], where ğ‘¥* = 0 Â· Â· Â· (|dt * | âˆ’ 1).

3.1.3 Rolling and Unrolling
In order to allow comparing recursive types for equivalence, their representation is changed such that all type
indices internal to the same recursive type are replaced by recursive type indices.
Ã² Note
This representation is independent of the type index space, so that it is meaningful across module boundaries.
Moreover, this representation ensures that types with equivalent recursive structure are also syntactically equal,
hence allowing a simple equality check on (closed) types. It gives rise to an iso-recursive interpretation of types.
The representation change is performed by two auxiliary operations on the syntax of recursive types:
â€¢ Rolling up a recursive type substitutes its internal type indices with corresponding recursive type indices.
â€¢ Unrolling a recursive type substitutes its recursive type indices with the corresponding defined types.
These operations are extended to defined types and defined as follows:
rollğ‘¥ (rec subtype * ) = rec (subtype[(ğ‘¥ + ğ‘–)* := (rec ğ‘–)* ])*
(if ğ‘–* = 0 Â· Â· Â· (|subtype * | âˆ’ 1))
*
*
*
* *
unroll(rec subtype ) = rec (subtype[(rec ğ‘–) := ((rec subtype ).ğ‘–) ]) (if ğ‘–* = 0 Â· Â· Â· (|subtype * | âˆ’ 1))
roll* ğ‘¥ (rectype)

= ((rec subtype * ).ğ‘–)*

unroll(rectype.ğ‘–)

= subtype * [ğ‘–]

(if ğ‘–* = 0 Â· Â· Â· (|subtype * | âˆ’ 1)
âˆ§ rollğ‘¥ (rectype) = rec subtype * )
(if unroll(rectype) = rec subtype * )

In addition, the following auxiliary function denotes the expansion of a defined type:
expand(deftype)

= comptype

(if unroll(deftype) = sub final? ht * comptype)

3.1.4 Instruction Types
Instruction types classify the behaviour of instructions or instruction sequences, by describing how they manipulate
the operand stack and the initialization status of locals:
instrtype

::= resulttype â†’localidx * resulttype

An instruction type [ğ‘¡*1 ] â†’ğ‘¥* [ğ‘¡*2 ] describes the required input stack with argument values of types ğ‘¡*1 that an
instruction pops off and the provided output stack with result values of types ğ‘¡*2 that it pushes back. Moreover, it
enumerates the indices ğ‘¥* of locals that have been set by the instruction or sequence.
Ã² Note
Instruction types are only used for validation, they do not occur in programs.

3.1. Conventions

29

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

3.1.5 Local Types
Local types classify locals, by describing their value type as well as their initialization status:
init
localtype

::= set | unset
::= init valtype

Ã² Note
Local types are only used for validation, they do not occur in programs.

3.1.6 Contexts
Validity of an individual definition is specified relative to a context, which collects relevant information about the
surrounding module and the definitions in scope:
â€¢ Types: the list of types defined in the current module.
â€¢ Functions: the list of functions declared in the current module, represented by a defined type that expands
to their function type.
â€¢ Tables: the list of tables declared in the current module, represented by their table type.
â€¢ Memories: the list of memories declared in the current module, represented by their memory type.
â€¢ Globals: the list of globals declared in the current module, represented by their global type.
â€¢ Tags: the list of tags declared in the current module, represented by their tag type.
â€¢ Element Segments: the list of element segments declared in the current module, represented by the elementsâ€™
reference type.
â€¢ Data Segments: the list of data segments declared in the current module, each represented by an ok entry.
â€¢ Locals: the list of locals declared in the current function (including parameters), represented by their local
type.
â€¢ Labels: the stack of labels accessible from the current position, represented by their result type.
â€¢ Return: the return type of the current function, represented as an optional result type that is absent when no
return is allowed, as in free-standing expressions.
â€¢ References: the list of function indices that occur in the module outside functions and can hence be used to
form references inside them.
In other words, a context contains a sequence of suitable types for each index space, describing each defined entry
in that space. Locals, labels and return type are only used for validating instructions in function bodies, and are
left empty elsewhere. The label stack is the only part of the context that changes as validation of an instruction
sequence proceeds.
More concretely, contexts are defined as records ğ¶ with abstract syntax:
ğ¶

30

::=

{ types
funcs
tables
mems
globals
tags
elems
datas
locals
labels
return
refs

deftype * ,
deftype * ,
tabletype * ,
memtype * ,
globaltype * ,
tagtype * ,
reftype * ,
ok* ,
localtype * ,
resulttype * ,
resulttype ? ,
funcidx * }
Chapter 3. Validation

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

In addition to field access written ğ¶.field the following notation is adopted for manipulating contexts:
â€¢ When spelling out a context, empty fields are omitted.
â€¢ ğ¶, field ğ´* denotes the same context as ğ¶ but with the elements ğ´* prepended to its field component sequence.
Ã² Note
Indexing notation like ğ¶.labels[ğ‘–] is used to look up indices in their respective index space in the context.
Context extension notation ğ¶, field ğ´ is primarily used to locally extend relative index spaces, such as label
indices. Accordingly, the notation is defined to append at the front of the respective sequence, introducing a
new relative index 0 and shifting the existing ones.

Convention
Any form of type can be closed to bring it into closed form relative to a context it is valid in by substituting each
type index ğ‘¥ occurring in it with the corresponding defined type ğ¶.types[ğ‘¥], after first closing the types in ğ¶.types
themselves.
closğ¶ (ğ‘¡)

= ğ‘¡[:= clos* (ğ¶.types)]

clos* (ğœ–)
clos* (dt * dt ğ‘ )

= ğœ–
*
*
= dt â€² dt ğ‘ [:= dt â€² ]

*

(if dt â€² = clos* (dt * ))

3.1.7 Prose Notation
Validation is specified by stylised rules for each relevant part of the abstract syntax. The rules not only state
constraints defining when a phrase is valid, they also classify it with a type. The following conventions are adopted
in stating these rules.
â€¢ A phrase ğ´ is said to be â€œvalid with type ğ‘‡ â€ if and only if all constraints expressed by the respective rules
are met. The form of ğ‘‡ depends on what ğ´ is.
Ã² Note
For example, if ğ´ is a function, then ğ‘‡ is a function type; for an ğ´ that is a global, ğ‘‡ is a global type;
and so on.
â€¢ The rules implicitly assume a given context ğ¶.
â€¢ In some places, this context is locally extended to a context ğ¶ â€² with additional entries. The formulation
â€œUnder context ğ¶ â€² , . . . statement . . . â€ is adopted to express that the following statement must apply under
the assumptions embodied in the extended context.

3.1.8 Formal Notation
Ã² Note
This section gives a brief explanation of the notation for specifying typing rules formally. For the interested
reader, a more thorough introduction can be found in respective text books.16
The proposition that a phrase ğ´ has a respective type ğ‘‡ is written ğ´ : ğ‘‡ . In general, however, typing is dependent
on a context ğ¶. To express this explicitly, the complete form is a judgement ğ¶ âŠ¢ ğ´ : ğ‘‡ , which says that ğ´ : ğ‘‡
holds under the assumptions encoded in ğ¶.
16 For example: Benjamin Pierce. Types and Programming Languages17 . The MIT Press 2002
17 https://www.cis.upenn.edu/~bcpierce/tapl/

3.1. Conventions

31

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

The formal typing rules use a standard approach for specifying type systems, rendering them into deduction rules.
Every rule has the following general form:
premise 1

premise 2
...
conclusion

premise ğ‘›

Such a rule is read as a big implication: if all premises hold, then the conclusion holds. Some rules have no
premises; they are axioms whose conclusion holds unconditionally. The conclusion always is a judgment ğ¶ âŠ¢ ğ´ :
ğ‘‡ , and there is one respective rule for each relevant construct ğ´ of the abstract syntax.
Ã² Note
For example, the typing rule for the i32.add instruction can be given as an axiom:
ğ¶ âŠ¢ i32.add : [i32 i32] â†’ [i32]
The instruction is always valid with type [i32 i32] â†’ [i32] (saying that it consumes two i32 values and produces
one), independent of any side conditions.
An instruction like local.get can be typed as follows:
ğ¶.globals[ğ‘¥] = mut ğ‘¡
ğ¶ âŠ¢ global.get ğ‘¥ : [] â†’ [ğ‘¡]
Here, the premise enforces that the immediate global index ğ‘¥ exists in the context. The instruction produces a
value of its respective type ğ‘¡ (and does not consume any values). If ğ¶.globals[ğ‘¥] does not exist then the premise
does not hold, and the instruction is ill-typed.
Finally, a structured instruction requires a recursive rule, where the premise is itself a typing judgement:
ğ¶, label [ğ‘¡*2 ] âŠ¢ instr * : [ğ‘¡*1 ] â†’ [ğ‘¡*2 ]
ğ¶ âŠ¢ blocktype : [ğ‘¡*1 ] â†’ [ğ‘¡*2 ]
ğ¶ âŠ¢ block blocktype instr * end : [ğ‘¡*1 ] â†’ [ğ‘¡*2 ]
A block instruction is only valid when the instruction sequence in its body is. Moreover, the result type must
match the blockâ€™s annotation blocktype. If so, then the block instruction has the same type as the body. Inside
the body an additional label of the corresponding result type is available, which is expressed by extending the
context ğ¶ with the additional label information for the premise.

3.2 Types
Simple types, such as number types are universally valid. However, restrictions apply to most other types, such
as reference types, function types, as well as the limits of table types and memory types, which must be checked
during validation.
Moreover, block types are converted to plain function types for ease of processing.

3.2.1 Number Types
Number types are always valid.
ğ¶ âŠ¢ numtype ok

3.2.2 Vector Types
Vector types are always valid.
ğ¶ âŠ¢ vectype ok

32

Chapter 3. Validation

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

3.2.3 Heap Types
Concrete heap types are only valid when the type index is, while abstract ones are vacuously valid.
absheaptype
â€¢ The heap type is valid.
ğ¶ âŠ¢ absheaptype ok
typeidx
â€¢ The type ğ¶.types[typeidx ] must be defined in the context.
â€¢ Then the heap type is valid.
ğ¶.types[typeidx ] = deftype
ğ¶ âŠ¢ typeidx ok

3.2.4 Reference Types
Reference types are valid when the referenced heap type is.
ref null? heaptype
â€¢ The heap type heaptype must be valid.
â€¢ Then the reference type is valid.
ğ¶ âŠ¢ heaptype ok
ğ¶ âŠ¢ ref null? heaptype ok

3.2.5 Value Types
Valid value types are either valid number types, valid vector types, or valid reference types.

3.2.6 Block Types
Block types may be expressed in one of two forms, both of which are converted to instruction types by the following
rules.
typeidx
â€¢ The type ğ¶.types[typeidx ] must be defined in the context.
â€¢ The expansion of ğ¶.funcs[typeidx ] must be a function type func [ğ‘¡*1 ] â†’ [ğ‘¡*2 ].
â€¢ Then the block type is valid as instruction type [ğ‘¡*1 ] â†’ [ğ‘¡*2 ].
expand(ğ¶.types[typeidx ]) = func [ğ‘¡*1 ] â†’ [ğ‘¡*2 ]
ğ¶ âŠ¢ typeidx : [ğ‘¡*1 ] â†’ [ğ‘¡*2 ]
[valtype ? ]
â€¢ The value type valtype must either be absent, or valid.
â€¢ Then the block type is valid as instruction type [] â†’ [valtype ? ].
(ğ¶ âŠ¢ valtype ok)?
ğ¶ âŠ¢ [valtype ? ] : [] â†’ [valtype ? ]

3.2. Types

33

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

3.2.7 Result Types
[ğ‘¡* ]
â€¢ Each value type ğ‘¡ğ‘– in the type sequence ğ‘¡* must be valid.
â€¢ Then the result type is valid.
(ğ¶ âŠ¢ ğ‘¡ ok)*
ğ¶ âŠ¢ [ğ‘¡* ] ok

3.2.8 Instruction Types
[ğ‘¡*1 ] â†’ğ‘¥* [ğ‘¡*2 ]
â€¢ The result type [ğ‘¡*1 ] must be valid.
â€¢ The result type [ğ‘¡*2 ] must be valid.
â€¢ Each local index ğ‘¥ğ‘– in ğ‘¥* must be defined in the context.
â€¢ Then the instruction type is valid.
ğ¶ âŠ¢ [ğ‘¡*1 ] ok

ğ¶ âŠ¢ [ğ‘¡*2 ] ok
(ğ¶.locals[ğ‘¥] = localtype)*
*
ğ¶ âŠ¢ [ğ‘¡1 ] â†’ğ‘¥* [ğ‘¡*2 ] ok

3.2.9 Function Types
[ğ‘¡*1 ] â†’ [ğ‘¡*2 ]
â€¢ The result type [ğ‘¡*1 ] must be valid.
â€¢ The result type [ğ‘¡*2 ] must be valid.
â€¢ Then the function type is valid.
ğ¶ âŠ¢ [ğ‘¡*1 ] ok
ğ¶ âŠ¢ [ğ‘¡*2 ] ok
ğ¶ âŠ¢ [ğ‘¡*1 ] â†’ [ğ‘¡*2 ] ok

3.2.10 Composite Types
func functype
â€¢ The function type functype must be valid.
â€¢ Then the composite type is valid.
ğ¶ âŠ¢ functype ok
ğ¶ âŠ¢ func functype ok
struct fieldtype *
â€¢ For each field type fieldtype ğ‘– in fieldtype * :
â€“ The field type fieldtype ğ‘– must be valid.
â€¢ Then the composite type is valid.
(ğ¶ âŠ¢ ft ok)*
ğ¶ âŠ¢ struct ft * ok

34

Chapter 3. Validation

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

array fieldtype
â€¢ The field type fieldtype must be valid.
â€¢ Then the composite type is valid.
ğ¶ âŠ¢ ft ok
ğ¶ âŠ¢ array ft ok

3.2.11 Field Types
mut storagetype
â€¢ The storage type storagetype must be valid.
â€¢ Then the field type is valid.
ğ¶ âŠ¢ st ok
ğ¶ âŠ¢ mut st ok
packedtype
â€¢ The packed type is valid.
ğ¶ âŠ¢ packedtype ok

3.2.12 Recursive Types
Recursive types are validated for a specific type index that denotes the index of the type defined by the recursive
group.
rec subtype *
â€¢ Either the sequence subtype * is empty.
â€¢ Or:
â€“ The first sub type of the sequence subtype * must be valid for the type index ğ‘¥.
â€“ The remaining sequence subtype * must be valid for the type index ğ‘¥ + 1.
â€¢ Then the recursive type is valid for the type index ğ‘¥.
*

ğ¶ âŠ¢ rec ğœ– ok(ğ‘¥)

ğ¶ âŠ¢ subtype ok(ğ‘¥)
ğ¶ âŠ¢ rec subtype â€² ok(ğ‘¥ + 1)
ğ¶ âŠ¢ rec subtype subtype â€² * ok(ğ‘¥)

sub final? ğ‘¦ * comptype
â€¢ The composite type comptype must be valid.
â€¢ The sequence ğ‘¦ * may be no longer than 1.
â€¢ For every type index ğ‘¦ğ‘– in ğ‘¦ * :
â€“ The type index ğ‘¦ğ‘– must be smaller than ğ‘¥.
â€“ The type index ğ‘¦ğ‘– must exist in the context ğ¶.
â€“ Let subtype ğ‘– be the unrolling of the defined type ğ¶.types[ğ‘¦ğ‘– ].
â€“ The sub type subtype ğ‘– must not contain final.
â€“ Let comptype â€²ğ‘– be the composite type in subtype ğ‘– .
â€“ The composite type comptype must match comptype â€²ğ‘– .
â€¢ Then the sub type is valid for the type index ğ‘¥.
3.2. Types

35

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)
*

|ğ‘¦ * | â‰¤ 1
(ğ‘¦ < ğ‘¥)*
(unroll(ğ¶.types[ğ‘¦]) = sub ğ‘¦ â€² comptype â€² )*
ğ¶ âŠ¢ comptype ok
(ğ¶ âŠ¢ comptype â‰¤ comptype â€² )*
ğ¶ âŠ¢ sub final? ğ‘¦ * comptype ok(ğ‘¥)
Ã² Note
The side condition on the index ensures that a declared supertype is a previously defined types, preventing
cyclic subtype hierarchies.
Future versions of WebAssembly may allow more than one supertype.

3.2.13 Defined Types
rectype.ğ‘–
â€¢ The recursive type rectype must be valid for some type index ğ‘¥.
â€¢ Let rec subtype * be the defined type rectype.
â€¢ The number ğ‘– must be smaller than the length of the sequence subtype * of sub types.
â€¢ Then the defined type is valid.
ğ¶ âŠ¢ rectype ok(ğ‘¥)

rectype = rec subtype ğ‘›
ğ¶ âŠ¢ rectype.ğ‘– ok

ğ‘–<ğ‘›

3.2.14 Limits
Limits must have meaningful bounds that are within a given range.
{min ğ‘›, max ğ‘š? }
â€¢ The value of ğ‘› must not be larger than ğ‘˜.
â€¢ If the maximum ğ‘š? is not empty, then:
â€“ Its value must not be larger than ğ‘˜.
â€“ Its value must not be smaller than ğ‘›.
â€¢ Then the limit is valid within range ğ‘˜.
ğ‘›â‰¤ğ‘˜
(ğ‘š â‰¤ ğ‘˜)?
(ğ‘› â‰¤ ğ‘š)?
?
ğ¶ âŠ¢ {min ğ‘›, max ğ‘š } : ğ‘˜

3.2.15 Table Types
addrtype limits reftype
â€¢ The limits limits must be valid within range 2|addrtype| âˆ’ 1.
â€¢ The reference type reftype must be valid.
â€¢ Then the table type is valid.
ğ¶ âŠ¢ limits : 2|addrtype| âˆ’ 1
ğ¶ âŠ¢ reftype ok
ğ¶ âŠ¢ addrtype limits reftype ok

36

Chapter 3. Validation

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

3.2.16 Memory Types
addrtype limits
â€¢ The limits limits must be valid within range 2|addrtype|âˆ’16 .
â€¢ Then the memory type is valid.
ğ¶ âŠ¢ limits : 2|addrtype|âˆ’16
ğ¶ âŠ¢ addrtype limits ok

3.2.17 Tag Types
deftype
â€¢ The defined type deftype must be valid.
â€¢ The expansion of deftype must be a function type func [ğ‘¡ğ‘›1 ] â†’ [ğ‘¡ğ‘š
2 ].
â€¢ The type sequence ğ‘¡ğ‘š
2 must be empty.
â€¢ Then the tag type is valid.
ğ¶ âŠ¢ deftype ok

expand(deftype) = func [ğ‘¡* ] â†’ []
ğ¶ âŠ¢ deftype ok

3.2.18 Global Types
mut valtype
â€¢ The value type valtype must be valid.
â€¢ Then the global type is valid.
ğ¶ âŠ¢ valtype ok
ğ¶ âŠ¢ mut valtype ok

3.2.19 External Types
func deftype
â€¢ The defined type deftype must be valid.
â€¢ The defined type deftype must be a function type.
â€¢ Then the external type is valid.
ğ¶ âŠ¢ deftype ok

expand(deftype) = func functype
ğ¶ âŠ¢ func deftype

table tabletype
â€¢ The table type tabletype must be valid.
â€¢ Then the external type is valid.
ğ¶ âŠ¢ tabletype ok
ğ¶ âŠ¢ table tabletype ok

3.2. Types

37

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

mem memtype
â€¢ The memory type memtype must be valid.
â€¢ Then the external type is valid.
ğ¶ âŠ¢ memtype ok
ğ¶ âŠ¢ mem memtype ok
tag tagtype
â€¢ The tag type tagtype must be valid.
â€¢ Then the external type is valid.
âŠ¢ tagtype ok
âŠ¢ tag tagtype ok
global globaltype
â€¢ The global type globaltype must be valid.
â€¢ Then the external type is valid.
ğ¶ âŠ¢ globaltype ok
ğ¶ âŠ¢ global globaltype ok

3.2.20 Defaultable Types
A type is defaultable if it has a default value for initialization.
Value Types
â€¢ A defaultable value type ğ‘¡ must be:
â€“ either a number type,
â€“ or a vector type,
â€“ or a nullable reference type.
ğ¶ âŠ¢ numtype defaultable
ğ¶ âŠ¢ vectype defaultable
ğ¶ âŠ¢ (ref null heaptype) defaultable

3.3 Matching
On most types, a notion of subtyping is defined that is applicable in validation rules, during module instantiation
when checking the types of imports, or during execution, when performing casts.

3.3.1 Number Types
A number type numtype 1 matches a number type numtype 2 if and only if:
â€¢ Both numtype 1 and numtype 2 are the same.
ğ¶ âŠ¢ numtype â‰¤ numtype

38

Chapter 3. Validation

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

3.3.2 Vector Types
A vector type vectype 1 matches a vector type vectype 2 if and only if:
â€¢ Both vectype 1 and vectype 2 are the same.
ğ¶ âŠ¢ vectype â‰¤ vectype

3.3.3 Heap Types
A heap type heaptype 1 matches a heap type heaptype 2 if and only if:
â€¢ Either both heaptype 1 and heaptype 2 are the same.
â€¢ Or there exists a valid heap type heaptype â€² , such that heaptype 1 matches heaptype â€² and heaptype â€² matches
heaptype 2 .
â€¢ Or heaptype 1 is eq and heaptype 2 is any.
â€¢ Or heaptype 1 is one of i31, struct, or array and heaptype 2 is eq.
â€¢ Or heaptype 1 is a defined type which expands to a structure type and heaptype 2 is struct.
â€¢ Or heaptype 1 is a defined type which expands to an array type and heaptype 2 is array.
â€¢ Or heaptype 1 is a defined type which expands to a function type and heaptype 2 is func.
â€¢ Or heaptype 1 is a defined type deftype 1 and heaptype 2 is a defined type deftype 2 , and deftype 1 matches
deftype 2 .
â€¢ Or heaptype 1 is a type index ğ‘¥1 , and the defined type ğ¶.types[ğ‘¥1 ] matches heaptype 2 .
â€¢ Or heaptype 2 is a type index ğ‘¥2 , and heaptype 1 matches the defined type ğ¶.types[ğ‘¥2 ].
â€¢ Or heaptype 1 is none and heaptype 2 matches any.
â€¢ Or heaptype 1 is nofunc and heaptype 2 matches func.
â€¢ Or heaptype 1 is noexn and heaptype 2 is exn.
â€¢ Or heaptype 1 is noextern and heaptype 2 is extern.
â€¢ Or heaptype 1 is bot.
ğ¶ âŠ¢ heaptype â€² ok
ğ¶ âŠ¢ heaptype â‰¤ heaptype

ğ¶ âŠ¢ eq â‰¤ any
expand(deftype) = struct st
ğ¶ âŠ¢ deftype â‰¤ struct

ğ¶ âŠ¢ i31 â‰¤ eq

ğ¶ âŠ¢ struct â‰¤ eq

expand(deftype) = array at
ğ¶ âŠ¢ deftype â‰¤ array

ğ¶ âŠ¢ ğ¶.types[typeidx 1 ] â‰¤ heaptype 2
ğ¶ âŠ¢ typeidx 1 â‰¤ heaptype 2
ğ¶ âŠ¢ ht â‰¤ any
ğ¶ âŠ¢ none â‰¤ ht

ğ¶ âŠ¢ heaptype 1 â‰¤ heaptype â€²
ğ¶ âŠ¢ heaptype â€² â‰¤ heaptype 2
ğ¶ âŠ¢ heaptype 1 â‰¤ heaptype 2

ğ¶ âŠ¢ ht â‰¤ func
ğ¶ âŠ¢ nofunc â‰¤ ht

ğ¶ âŠ¢ array â‰¤ eq
expand(deftype) = func ft
ğ¶ âŠ¢ deftype â‰¤ func

ğ¶ âŠ¢ heaptype 1 â‰¤ ğ¶.types[typeidx 2 ]
ğ¶ âŠ¢ heaptype 1 â‰¤ typeidx 2

ğ¶ âŠ¢ noexn â‰¤ exn

ğ¶ âŠ¢ noextern â‰¤ extern

ğ¶ âŠ¢ bot â‰¤ heaptype

3.3. Matching

39

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

3.3.4 Reference Types
A reference type ref null?1 heaptype 1 matches a reference type ref null?2 heaptype 2 if and only if:
â€¢ The heap type heaptype 1 matches heaptype 2 .
â€¢ null1 is absent or null2 is present.
ğ¶ âŠ¢ heaptype 1 â‰¤ heaptype 2
ğ¶ âŠ¢ ref heaptype 1 â‰¤ ref heaptype 2

ğ¶ âŠ¢ heaptype 1 â‰¤ heaptype 2
ğ¶ âŠ¢ ref null? heaptype 1 â‰¤ ref null heaptype 2

3.3.5 Value Types
A value type valtype 1 matches a value type valtype 2 if and only if:
â€¢ Either both valtype 1 and valtype 2 are number types and valtype 1 matches valtype 2 .
â€¢ Or both valtype 1 and valtype 2 are reference types and valtype 1 matches valtype 2 .
â€¢ Or valtype 1 is bot.
ğ¶ âŠ¢ bot â‰¤ valtype

3.3.6 Result Types
Subtyping is lifted to result types in a pointwise manner. That is, a result type [ğ‘¡*1 ] matches a result type [ğ‘¡*2 ] if and
only if:
â€¢ Every value type ğ‘¡1 in [ğ‘¡*1 ] matches the corresponding value type ğ‘¡2 in [ğ‘¡*2 ].
(ğ¶ âŠ¢ ğ‘¡1 â‰¤ ğ‘¡2 )*
ğ¶ âŠ¢ [ğ‘¡*1 ] â‰¤ [ğ‘¡*2 ]

3.3.7 Instruction Types
Subtyping is further lifted to instruction types. An instruction type [ğ‘¡*11 ] â†’ğ‘¥*1 [ğ‘¡*12 ] matches a type [ğ‘¡*21 ] â†’ğ‘¥*2 [ğ‘¡*22 ]
if and only if:
*

*

â€¢ There is a common sequence of value types ğ‘¡* such that ğ‘¡*21 equals ğ‘¡* ğ‘¡â€²21 and ğ‘¡*22 equals ğ‘¡* ğ‘¡â€²22 .
*

â€¢ The result type [ğ‘¡â€²21 ] matches [ğ‘¡*11 ].
*

â€¢ The result type [ğ‘¡*12 ] matches [ğ‘¡â€²22 ].
â€¢ For every local index ğ‘¥ that is in ğ‘¥*2 but not in ğ‘¥*1 , the local type ğ¶.locals[ğ‘¥] is set ğ‘¡ğ‘¥ for some value type ğ‘¡ğ‘¥ .
{ğ‘¥* } = {ğ‘¥*2 } âˆ– {ğ‘¥*1 }
ğ¶ âŠ¢ [ğ‘¡*21 ] â‰¤ [ğ‘¡*11 ]
*
*
(ğ¶.locals[ğ‘¥] = set ğ‘¡ğ‘¥ )*
ğ¶ âŠ¢ [ğ‘¡12 ] â‰¤ [ğ‘¡22 ]
ğ¶ âŠ¢ [ğ‘¡*11 ] â†’ğ‘¥*1 [ğ‘¡*12 ] â‰¤ [ğ‘¡* ğ‘¡*21 ] â†’ğ‘¥*2 [ğ‘¡* ğ‘¡*22 ]
Ã² Note
Instruction types are contravariant in their input and covariant in their output. Subtyping also incorporates a
sort of â€œframeâ€ condition, which allows adding arbitrary invariant stack elements on both sides in the super
type.
Finally, the supertype may ignore variables from the init set ğ‘¥*1 . It may also add variables to the init set,
provided these are already set in the context, i.e., are vacuously initialized.

40

Chapter 3. Validation

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

3.3.8 Function Types
A function type [ğ‘¡*11 ] â†’ [ğ‘¡*12 ] matches a type [ğ‘¡*21 ] â†’ [ğ‘¡*22 ] if and only if:
â€¢ The result type [ğ‘¡*21 ] matches [ğ‘¡*11 ].
â€¢ The result type [ğ‘¡*12 ] matches [ğ‘¡*22 ].
ğ¶ âŠ¢ [ğ‘¡*21 ] â‰¤ [ğ‘¡*11 ]
ğ¶ âŠ¢ [ğ‘¡*12 ] â‰¤ [ğ‘¡*22 ]
*
*
ğ¶ âŠ¢ [ğ‘¡11 ] â†’ [ğ‘¡12 ] â‰¤ [ğ‘¡*21 ] â†’ [ğ‘¡*22 ]

3.3.9 Composite Types
A composite type comptype 1 matches a type comptype 2 if and only if:
â€¢ Either the composite type comptype 1 is func functype 1 and comptype 2 is func functype 2 and:
â€“ The function type functype 1 matches functype 2 .
â€¢ Or the composite type comptype 1 is struct fieldtype ğ‘›1 1 and comptype 2 is struct fieldtype ğ‘›2 2 and:
â€“ The arity ğ‘›1 is greater than or equal to ğ‘›2 .
â€“ For every field type fieldtype 2ğ‘– in fieldtype ğ‘›2 2 and corresponding fieldtype 1ğ‘– in fieldtype ğ‘›1 1
âˆ— The field type fieldtype 1ğ‘– matches fieldtype 2ğ‘– .
â€¢ Or the composite type comptype 1 is array fieldtype 1 and comptype 2 is array fieldtype 2 and:
â€“ The field type fieldtype 1 matches fieldtype 2 .
ğ¶ âŠ¢ functype 1 â‰¤ functype 2
ğ¶ âŠ¢ func functype 1 â‰¤ func functype 2
(ğ¶ âŠ¢ fieldtype 1 â‰¤ fieldtype 2 )*
ğ¶ âŠ¢ struct fieldtype *1 fieldtype â€² *1 â‰¤ struct fieldtype *2
ğ¶ âŠ¢ fieldtype 1 â‰¤ fieldtype 2
ğ¶ âŠ¢ array fieldtype 1 â‰¤ array fieldtype 2

3.3.10 Field Types
A field type mut 1 storagetype 1 matches a type mut 2 storagetype 2 if and only if:
â€¢ Storage type storagetype 1 matches storagetype 2 .
â€¢ Either both mut 1 and mut 2 are const.
â€¢ Or both mut 1 and mut 2 are var and storagetype 2 matches storagetype 1 as well.

ğ¶ âŠ¢ storagetype 1 â‰¤ storagetype 2
ğ¶ âŠ¢ const storagetype 1 â‰¤ const storagetype 2

ğ¶ âŠ¢ storagetype 1 â‰¤ storagetype 2
ğ¶ âŠ¢ storagetype 2 â‰¤ storagetype 1
ğ¶ âŠ¢ var storagetype 1 â‰¤ var storagetype 2

A storage type storagetype 1 matches a type storagetype 2 if and only if:
â€¢ Either storagetype 1 is a value type valtype 1 and storagetype 2 is a value type valtype 2 and valtype 1 matches
valtype 2 .
â€¢ Or storagetype 1 is a packed type packedtype 1 and storagetype 2 is a packed type packedtype 2 and
packedtype 1 matches packedtype 2 .
A packed type packedtype 1 matches a type packedtype 2 if and only if:

3.3. Matching

41

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

â€¢ The packed type packedtype 1 is the same as packedtype 2 .
ğ¶ âŠ¢ packedtype â‰¤ packedtype

3.3.11 Defined Types
A defined type deftype 1 matches a type deftype 2 if and only if:
â€¢ Either deftype 1 and deftype 2 are equal when closed under context ğ¶.
â€¢ Or:
â€“ Let the sub type sub final? heaptype * comptype be the result of unrolling deftype 1 .
â€“ Then there must exist a heap type heaptype ğ‘– in heaptype * that matches deftype 2 .
closğ¶ (deftype 1 ) = closğ¶ (deftype 2 )
ğ¶ âŠ¢ deftype 1 â‰¤ deftype 2
unroll(deftype 1 ) = sub final? heaptype * comptype
ğ¶ âŠ¢ heaptype * [ğ‘–] â‰¤ deftype 2
ğ¶ âŠ¢ deftype 1 â‰¤ deftype 2
Ã² Note
Note that there is no explicit definition of type equivalence, since it coincides with syntactic equality, as used
in the premise of the former rule above.

3.3.12 Limits
Limits {min ğ‘›1 , max ğ‘š?1 } match limits {min ğ‘›2 , max ğ‘š?2 } if and only if:
â€¢ ğ‘›1 is larger than or equal to ğ‘›2 .
â€¢ Either:
â€“ ğ‘š?2 is empty.
â€¢ Or:
â€“ Both ğ‘š?1 and ğ‘š?2 are non-empty.
â€“ ğ‘š1 is smaller than or equal to ğ‘š2 .
ğ‘›1 â‰¥ ğ‘›2
ğ¶ âŠ¢ {min ğ‘›1 , max ğ‘š?1 } â‰¤ {min ğ‘›2 , max ğœ–}

ğ‘›1 â‰¥ ğ‘›2
ğ‘š1 â‰¤ ğ‘š2
ğ¶ âŠ¢ {min ğ‘›1 , max ğ‘š1 } â‰¤ {min ğ‘›2 , max ğ‘š2 }

3.3.13 Table Types
A table type (addrtype 1 limits 1 reftype 1 ) matches (addrtype 2 limits 2 reftype 2 ) if and only if:
â€¢ Address types addrtype 1 and addrtype 2 are the same.
â€¢ Limits limits 1 match limits 2 .
â€¢ The reference type reftype 1 matches reftype 2 , and vice versa.
ğ¶ âŠ¢ limits 1 â‰¤ limits 2
ğ¶ âŠ¢ reftype 1 â‰¤ reftype 2
ğ¶ âŠ¢ reftype 2 â‰¤ reftype 1
ğ¶ âŠ¢ addrtype limits 1 reftype 1 â‰¤ addrtype limits 2 reftype 2

42

Chapter 3. Validation

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

3.3.14 Memory Types
A memory type (addrtype 1 limits 1 ) matches (addrtype 2 limits 2 ) if and only if:
â€¢ Address types addrtype 1 and addrtype 2 are the same.
â€¢ Limits limits 1 match limits 2 .
ğ¶ âŠ¢ limits 1 â‰¤ limits 2
ğ¶ âŠ¢ addrtype limits 1 â‰¤ addrtype limits 2

3.3.15 Global Types
A global type (mut 1 ğ‘¡1 ) matches (mut 2 ğ‘¡2 ) if and only if:
â€¢ Either both mut 1 and mut 2 are var and ğ‘¡1 matches ğ‘¡2 and vice versa.
â€¢ Or both mut 1 and mut 2 are const and ğ‘¡1 matches ğ‘¡2 .
ğ¶ âŠ¢ ğ‘¡1 â‰¤ ğ‘¡2
ğ¶ âŠ¢ ğ‘¡2 â‰¤ ğ‘¡1
ğ¶ âŠ¢ var ğ‘¡1 â‰¤ var ğ‘¡2

ğ¶ âŠ¢ ğ‘¡1 â‰¤ ğ‘¡2
ğ¶ âŠ¢ const ğ‘¡1 â‰¤ const ğ‘¡2

3.3.16 Tag Types
A tag type deftype 1 matches deftype 2 if and only if the defined type deftype 1 matches deftype 2 , and vice versa.
ğ¶ âŠ¢ deftype 1 â‰¤ deftype 2
ğ¶ âŠ¢ deftype 2 â‰¤ deftype 1
ğ¶ âŠ¢ deftype 1 â‰¤ deftype 2

Ã² Note
Although the conclusion of this rule looks identical to its premise, they in fact describe different relations: the
premise invokes subtyping on defined types, while the conclusion defines it on tag types that happen to be
expressed as defined types.

3.3.17 External Types
Functions
An external type func deftype 1 matches func deftype 2 if and only if:
â€¢ The defined type deftype 1 matches deftype 2 .
ğ¶ âŠ¢ deftype 1 â‰¤ deftype 2
ğ¶ âŠ¢ func deftype 1 â‰¤ func deftype 2
Tables
An external type table tabletype 1 matches table tabletype 2 if and only if:
â€¢ Table type tabletype 1 matches tabletype 2 .
ğ¶ âŠ¢ tabletype 1 â‰¤ tabletype 2
ğ¶ âŠ¢ table tabletype 1 â‰¤ table tabletype 2

3.3. Matching

43

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

Memories
An external type mem memtype 1 matches mem memtype 2 if and only if:
â€¢ Memory type memtype 1 matches memtype 2 .
ğ¶ âŠ¢ memtype 1 â‰¤ memtype 2
ğ¶ âŠ¢ mem memtype 1 â‰¤ mem memtype 2
Globals
An external type global globaltype 1 matches global globaltype 2 if and only if:
â€¢ Global type globaltype 1 matches globaltype 2 .
ğ¶ âŠ¢ globaltype 1 â‰¤ globaltype 2
ğ¶ âŠ¢ global globaltype 1 â‰¤ global globaltype 2
Tags
An external type tag tagtype 1 matches tag tagtype 2 if and only if:
â€¢ Tag type tagtype 1 matches tagtype 2 .
ğ¶ âŠ¢ tagtype 1 â‰¤ tagtype 2
ğ¶ âŠ¢ tag tagtype 1 â‰¤ tag tagtype 2

3.4 Instructions
Instructions are classified by instruction types that describe how they manipulate the operand stack and initialize
locals: A type [ğ‘¡*1 ] â†’ğ‘¥* [ğ‘¡*2 ] describes the required input stack with argument values of types ğ‘¡*1 that an instruction
pops off and the provided output stack with result values of types ğ‘¡*2 that it pushes back. Moreover, it enumerates
the indices ğ‘¥* of locals that have been set by the instruction. In most cases, this is empty.
Ã² Note
For example, the instruction i32.add has type [i32 i32] â†’ [i32], consuming two i32 values and producing one.
The instruction local.set ğ‘¥ has type [ğ‘¡] â†’ğ‘¥ [], provided ğ‘¡ is the type declared for the local ğ‘¥.
Typing extends to instruction sequences instr * . Such a sequence has an instruction type [ğ‘¡*1 ] â†’ğ‘¥* [ğ‘¡*2 ] if the
accumulative effect of executing the instructions is consuming values of types ğ‘¡*1 off the operand stack, pushing
new values of types ğ‘¡*2 , and setting all locals ğ‘¥* .
For some instructions, the typing rules do not fully constrain the type, and therefore allow for multiple types. Such
instructions are called polymorphic. Two degrees of polymorphism can be distinguished:
â€¢ value-polymorphic: the value type ğ‘¡ of one or several individual operands is unconstrained. That is the case
for all parametric instructions like drop and select.
â€¢ stack-polymorphic: the entire (or most of the) instruction type [ğ‘¡*1 ] â†’ [ğ‘¡*2 ] of the instruction is unconstrained. That is the case for all control instructions that perform an unconditional control transfer, such
as unreachable, br, br_table, and return.
In both cases, the unconstrained types or type sequences can be chosen arbitrarily, as long as they meet the constraints imposed for the surrounding parts of the program.

44

Chapter 3. Validation

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

Ã² Note
For example, the select instruction is valid with type [ğ‘¡ ğ‘¡ i32] â†’ [ğ‘¡], for any possible number type ğ‘¡. Consequently, both instruction sequences
(i32.const 1) (i32.const 2) (i32.const 3) select
and
(f64.const 1.0) (f64.const 2.0) (i32.const 3) select
are valid, with ğ‘¡ in the typing of select being instantiated to i32 or f64, respectively.
The unreachable instruction is stack-polymorphic, and hence valid with type [ğ‘¡*1 ] â†’ [ğ‘¡*2 ] for any possible
sequences of value types ğ‘¡*1 and ğ‘¡*2 . Consequently,
unreachable i32.add
is valid by assuming type [] â†’ [i32] for the unreachable instruction. In contrast,
unreachable (i64.const 0) i32.add
is invalid, because there is no possible type to pick for the unreachable instruction that would make the sequence
well-typed.
The Appendix describes a type checking algorithm that efficiently implements validation of instruction sequences
as prescribed by the rules given here.

3.4.1 Numeric Instructions
ğ‘¡.const ğ‘
â€¢ The instruction is valid with type [] â†’ [ğ‘¡].
ğ¶ âŠ¢ ğ‘¡.const ğ‘ : [] â†’ [ğ‘¡]
ğ‘¡.unop
â€¢ The instruction is valid with type [ğ‘¡] â†’ [ğ‘¡].
ğ¶ âŠ¢ ğ‘¡.unop : [ğ‘¡] â†’ [ğ‘¡]
ğ‘¡.binop
â€¢ The instruction is valid with type [ğ‘¡ ğ‘¡] â†’ [ğ‘¡].
ğ¶ âŠ¢ ğ‘¡.binop : [ğ‘¡ ğ‘¡] â†’ [ğ‘¡]
ğ‘¡.testop
â€¢ The instruction is valid with type [ğ‘¡] â†’ [i32].
ğ¶ âŠ¢ ğ‘¡.testop : [ğ‘¡] â†’ [i32]

3.4. Instructions

45

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

ğ‘¡.relop
â€¢ The instruction is valid with type [ğ‘¡ ğ‘¡] â†’ [i32].
ğ¶ âŠ¢ ğ‘¡.relop : [ğ‘¡ ğ‘¡] â†’ [i32]
ğ‘¡2 .cvtop_ğ‘¡1 _sx ?
â€¢ The instruction is valid with type [ğ‘¡1 ] â†’ [ğ‘¡2 ].
ğ¶ âŠ¢ ğ‘¡2 .cvtop_ğ‘¡1 _sx ? : [ğ‘¡1 ] â†’ [ğ‘¡2 ]

3.4.2 Reference Instructions
ref.null ht
â€¢ The heap type ht must be valid.
â€¢ Then the instruction is valid with type [] â†’ [(ref null ht)].
ğ¶ âŠ¢ ht ok
ğ¶ âŠ¢ ref.null ht : [] â†’ [(ref null ht)]
ref.func ğ‘¥
â€¢ The function ğ¶.funcs[ğ‘¥] must be defined in the context.
â€¢ Let dt be the defined type ğ¶.funcs[ğ‘¥].
â€¢ The function index ğ‘¥ must be contained in ğ¶.refs.
â€¢ The instruction is valid with type [] â†’ [(ref dt)].
ğ¶.funcs[ğ‘¥] = dt
ğ‘¥ âˆˆ ğ¶.refs
ğ¶ âŠ¢ ref.func ğ‘¥ : [] â†’ [(ref dt)]
ref.is_null
â€¢ The instruction is valid with type [(ref null ht)] â†’ [i32], for any valid heap type ht.
ğ¶ âŠ¢ ht ok
ğ¶ âŠ¢ ref.is_null : [(ref null ht)] â†’ [i32]
ref.as_non_null
â€¢ The instruction is valid with type [(ref null ht)] â†’ [(ref ht)], for any valid heap type ht.
ğ¶ âŠ¢ ht ok
ğ¶ âŠ¢ ref.as_non_null : [(ref null ht)] â†’ [(ref ht)]
ref.eq
â€¢ The instruction is valid with type [(ref null eq)(ref null eq)] â†’ [i32].
ğ¶ âŠ¢ ref.eq : [(ref null eq) (ref null eq)] â†’ [i32]

46

Chapter 3. Validation

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

ref.test rt
â€¢ The reference type rt must be valid.
â€¢ Then the instruction is valid with type [rt â€² ] â†’ [i32] for any valid reference type rt â€² for which rt matches rt â€² .
ğ¶ âŠ¢ rt ok
ğ¶ âŠ¢ rt â€² ok
ğ¶ âŠ¢ rt â‰¤ rt â€²
ğ¶ âŠ¢ ref.test rt : [rt â€² ] â†’ [i32]
Ã² Note
The liberty to pick a supertype rt â€² allows typing the instruction with the least precise super type of rt as input,
that is, the top type in the corresponding heap subtyping hierarchy.
ref.cast rt
â€¢ The reference type rt must be valid.
â€¢ Then the instruction is valid with type [rt â€² ] â†’ [rt] for any valid reference type rt â€² for which rt matches rt â€² .
ğ¶ âŠ¢ rt ok
ğ¶ âŠ¢ rt â€² ok
ğ¶ âŠ¢ rt â‰¤ rt â€²
â€²
ğ¶ âŠ¢ ref.cast rt : [rt ] â†’ [rt]
Ã² Note
The liberty to pick a supertype rt â€² allows typing the instruction with the least precise super type of rt as input,
that is, the top type in the corresponding heap subtyping hierarchy.

3.4.3 Aggregate Reference Instructions
struct.new ğ‘¥
â€¢ The defined type ğ¶.types[ğ‘¥] must exist.
â€¢ The expansion of ğ¶.types[ğ‘¥] must be a structure type struct fieldtype * .
â€¢ For each field type fieldtype ğ‘– in fieldtype * :
â€“ Let fieldtype ğ‘– be mut storagetype ğ‘– .
â€“ Let ğ‘¡ğ‘– be the value type unpack(storagetype ğ‘– ).
â€¢ Let ğ‘¡* be the concatenation of all ğ‘¡ğ‘– .
â€¢ Then the instruction is valid with type [ğ‘¡* ] â†’ [(ref ğ‘¥)].
expand(ğ¶.types[ğ‘¥]) = struct (mut st)*
ğ¶ âŠ¢ struct.new ğ‘¥ : [(unpack(st))* ] â†’ [(ref ğ‘¥)]
struct.new_default ğ‘¥
â€¢ The defined type ğ¶.types[ğ‘¥] must exist.
â€¢ The expansion of ğ¶.types[ğ‘¥] must be a structure type struct fieldtype * .
â€¢ For each field type fieldtype ğ‘– in fieldtype * :
â€“ Let fieldtype ğ‘– be mut storagetype ğ‘– .
â€“ Let ğ‘¡ğ‘– be the value type unpack(storagetype ğ‘– ).
â€“ The type ğ‘¡ğ‘– must be defaultable.
â€¢ Let ğ‘¡* be the concatenation of all ğ‘¡ğ‘– .

3.4. Instructions

47

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

â€¢ Then the instruction is valid with type [] â†’ [(ref ğ‘¥)].
expand(ğ¶.types[ğ‘¥]) = struct (mut st)*
(ğ¶ âŠ¢ unpack(st) defaultable)*
ğ¶ âŠ¢ struct.new_default ğ‘¥ : [] â†’ [(ref ğ‘¥)]
struct.get_sx ? ğ‘¥ ğ‘¦
â€¢ The defined type ğ¶.types[ğ‘¥] must exist.
â€¢ The expansion of ğ¶.types[ğ‘¥] must be a structure type struct fieldtype * .
â€¢ Let the field type mut storagetype be fieldtype * [ğ‘¦].
â€¢ Let ğ‘¡ be the value type unpack(storagetype).
â€¢ The extension sx must be present if and only if storagetype is a packed type.
â€¢ Then the instruction is valid with type [(ref null ğ‘¥)] â†’ [ğ‘¡].
expand(ğ¶.types[ğ‘¥]) = struct ft *
ft * [ğ‘¦] = mut st
sx ? = ğœ– â‡” st = unpack(st)
?
ğ¶ âŠ¢ struct.get_sx ğ‘¥ ğ‘¦ : [(ref null ğ‘¥)] â†’ [unpack(st)]
struct.set ğ‘¥ ğ‘¦
â€¢ The defined type ğ¶.types[ğ‘¥] must exist.
â€¢ The expansion of ğ¶.types[ğ‘¥] must be a structure type struct fieldtype * .
â€¢ Let the field type mut storagetype be fieldtype * [ğ‘¦].
â€¢ The prefix mut must be var.
â€¢ Let ğ‘¡ be the value type unpack(storagetype).
â€¢ Then the instruction is valid with type [(ref null ğ‘¥) ğ‘¡] â†’ [].
expand(ğ¶.types[ğ‘¥]) = struct ft *
ft * [ğ‘¦] = var st
ğ¶ âŠ¢ struct.set ğ‘¥ ğ‘¦ : [(ref null ğ‘¥) unpack(st)] â†’ []
array.new ğ‘¥
â€¢ The defined type ğ¶.types[ğ‘¥] must exist.
â€¢ The expansion of ğ¶.types[ğ‘¥] must be an array type array fieldtype.
â€¢ Let fieldtype be mut storagetype.
â€¢ Let ğ‘¡ be the value type unpack(storagetype).
â€¢ Then the instruction is valid with type [ğ‘¡ i32] â†’ [(ref ğ‘¥)].
expand(ğ¶.types[ğ‘¥]) = array (mut st)
ğ¶ âŠ¢ array.new ğ‘¥ : [unpack(st) i32] â†’ [(ref ğ‘¥)]
array.new_default ğ‘¥
â€¢ The defined type ğ¶.types[ğ‘¥] must exist.
â€¢ The expansion of ğ¶.types[ğ‘¥] must be an array type array fieldtype.
â€¢ Let fieldtype be mut storagetype.
â€¢ Let ğ‘¡ be the value type unpack(storagetype).
â€¢ The type ğ‘¡ must be defaultable.
â€¢ Then the instruction is valid with type [i32] â†’ [(ref ğ‘¥)].
expand(ğ¶.types[ğ‘¥]) = array (mut st)
ğ¶ âŠ¢ unpack(st) defaultable
ğ¶ âŠ¢ array.new_default ğ‘¥ : [i32] â†’ [(ref ğ‘¥)]

48

Chapter 3. Validation

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

array.new_fixed ğ‘¥ ğ‘›
â€¢ The defined type ğ¶.types[ğ‘¥] must exist.
â€¢ The expansion of ğ¶.types[ğ‘¥] must be an array type array fieldtype.
â€¢ Let fieldtype be mut storagetype.
â€¢ Let ğ‘¡ be the value type unpack(storagetype).
â€¢ Then the instruction is valid with type [ğ‘¡ğ‘› ] â†’ [(ref ğ‘¥)].
expand(ğ¶.types[ğ‘¥]) = array (mut st)
ğ¶ âŠ¢ array.new_fixed ğ‘¥ ğ‘› : [unpack(st)ğ‘› ] â†’ [(ref ğ‘¥)]
array.new_elem ğ‘¥ ğ‘¦
â€¢ The defined type ğ¶.types[ğ‘¥] must exist.
â€¢ The expansion of ğ¶.types[ğ‘¥] must be an array type array fieldtype.
â€¢ Let fieldtype be mut storagetype.
â€¢ The storage type storagetype must be a reference type rt.
â€¢ The element segment ğ¶.elems[ğ‘¦] must exist.
â€¢ Let rt â€² be the reference type ğ¶.elems[ğ‘¦].
â€¢ The reference type rt â€² must match rt.
â€¢ Then the instruction is valid with type [i32 i32] â†’ [(ref ğ‘¥)].
expand(ğ¶.types[ğ‘¥]) = array (mut rt)
ğ¶ âŠ¢ ğ¶.elems[ğ‘¦] â‰¤ rt
ğ¶ âŠ¢ array.new_elem ğ‘¥ ğ‘¦ : [i32 i32] â†’ [(ref ğ‘¥)]
array.new_data ğ‘¥ ğ‘¦
â€¢ The defined type ğ¶.types[ğ‘¥] must exist.
â€¢ The expansion of ğ¶.types[ğ‘¥] must be an array type array fieldtype.
â€¢ Let fieldtype be mut storagetype.
â€¢ Let ğ‘¡ be the value type unpack(storagetype).
â€¢ The type ğ‘¡ must be a numeric type or a vector type.
â€¢ The data segment ğ¶.datas[ğ‘¦] must exist.
â€¢ Then the instruction is valid with type [i32 i32] â†’ [(ref ğ‘¥)].
expand(ğ¶.types[ğ‘¥]) = array (mut st)
unpack(st) = numtype âˆ¨ unpack(st) = vectype
ğ¶ âŠ¢ array.new_data ğ‘¥ ğ‘¦ : [i32 i32] â†’ [(ref ğ‘¥)]

ğ¶.datas[ğ‘¦] = ok

array.get_sx ? ğ‘¥
â€¢ The defined type ğ¶.types[ğ‘¥] must exist.
â€¢ The expansion of ğ¶.types[ğ‘¥] must be an array type array fieldtype.
â€¢ Let the field type mut storagetype be fieldtype.
â€¢ Let ğ‘¡ be the value type unpack(storagetype).
â€¢ The extension sx must be present if and only if storagetype is a packed type.
â€¢ Then the instruction is valid with type [(ref null ğ‘¥) i32] â†’ [ğ‘¡].
expand(ğ¶.types[ğ‘¥]) = array (mut st)
sx ? = ğœ– â‡” st = unpack(st)
?
ğ¶ âŠ¢ array.get_sx ğ‘¥ : [(ref null ğ‘¥) i32] â†’ [unpack(st)]

3.4. Instructions

49

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

array.set ğ‘¥
â€¢ The defined type ğ¶.types[ğ‘¥] must exist.
â€¢ The expansion of ğ¶.types[ğ‘¥] must be an array type array fieldtype.
â€¢ Let the field type mut storagetype be fieldtype.
â€¢ The prefix mut must be var.
â€¢ Let ğ‘¡ be the value type unpack(storagetype).
â€¢ Then the instruction is valid with type [(ref null ğ‘¥) i32 ğ‘¡] â†’ [].
expand(ğ¶.types[ğ‘¥]) = array (var st)
ğ¶ âŠ¢ array.set ğ‘¥ : [(ref null ğ‘¥) i32 unpack(st)] â†’ []
array.len
â€¢ The the instruction is valid with type [(ref null array)] â†’ [i32].
ğ¶ âŠ¢ array.len : [(ref null array)] â†’ [i32]
array.fill ğ‘¥
â€¢ The defined type ğ¶.types[ğ‘¥] must exist.
â€¢ The expansion of ğ¶.types[ğ‘¥] must be an array type array fieldtype.
â€¢ Let the field type mut storagetype be fieldtype.
â€¢ The prefix mut must be var.
â€¢ Let ğ‘¡ be the value type unpack(storagetype).
â€¢ Then the instruction is valid with type [(ref null ğ‘¥) i32 ğ‘¡ i32] â†’ [].
expand(ğ¶.types[ğ‘¥]) = array (var st)
ğ¶ âŠ¢ array.fill ğ‘¥ : [(ref null ğ‘¥) i32 unpack(st) i32] â†’ []
array.copy ğ‘¥ ğ‘¦
â€¢ The defined type ğ¶.types[ğ‘¥] must exist.
â€¢ The expansion of ğ¶.types[ğ‘¥] must be an array type array fieldtype 1 .
â€¢ Let the field type mut 1 storagetype 1 be fieldtype 1 .
â€¢ The prefix mut 1 must be var.
â€¢ The defined type ğ¶.types[ğ‘¦] must exist.
â€¢ The expansion of ğ¶.types[ğ‘¦] must be an array type array fieldtype 2 .
â€¢ Let the field type mut 2 storagetype 2 be fieldtype 2 .
â€¢ The storage type storagetype 2 must match storagetype 1 .
â€¢ Then the instruction is valid with type [(ref null ğ‘¥) i32 (ref null ğ‘¦) i32 i32] â†’ [].
expand(ğ¶.types[ğ‘¥]) = array (var st1 )
expand(ğ¶.types[ğ‘¦]) = array (mut st2 )
ğ¶ âŠ¢ array.copy ğ‘¥ ğ‘¦ : [(ref null ğ‘¥) i32 (ref null ğ‘¦) i32 i32] â†’ []

ğ¶ âŠ¢ st2 â‰¤ st1

array.init_data ğ‘¥ ğ‘¦
â€¢ The defined type ğ¶.types[ğ‘¥] must exist.
â€¢ The expansion of ğ¶.types[ğ‘¥] must be an array type array fieldtype.
â€¢ Let the field type mut storagetype be fieldtype.
â€¢ The prefix mut must be var.
50

Chapter 3. Validation

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

â€¢ Let ğ‘¡ be the value type unpack(storagetype).
â€¢ The value type ğ‘¡ must be a numeric type or a vector type.
â€¢ The data segment ğ¶.datas[ğ‘¦] must exist.
â€¢ Then the instruction is valid with type [(ref null ğ‘¥) i32 i32 i32] â†’ [].
expand(ğ¶.types[ğ‘¥]) = array (var st)
unpack(st) = numtype âˆ¨ unpack(st) = vectype
ğ¶ âŠ¢ array.init_data ğ‘¥ ğ‘¦ : [(ref null ğ‘¥) i32 i32 i32] â†’ []

ğ¶.datas[ğ‘¦] = ok

array.init_elem ğ‘¥ ğ‘¦
â€¢ The defined type ğ¶.types[ğ‘¥] must exist.
â€¢ The expansion of ğ¶.types[ğ‘¥] must be an array type array fieldtype.
â€¢ Let the field type mut storagetype be fieldtype.
â€¢ The prefix mut must be var.
â€¢ The storage type storagetype must be a reference type rt.
â€¢ The element segment ğ¶.elems[ğ‘¦] must exist.
â€¢ Let rt â€² be the reference type ğ¶.elems[ğ‘¦].
â€¢ The reference type rt â€² must match rt.
â€¢ Then the instruction is valid with type [(ref null ğ‘¥) i32 i32 i32] â†’ [].
expand(ğ¶.types[ğ‘¥]) = array (var rt)
ğ¶ âŠ¢ ğ¶.elems[ğ‘¦] â‰¤ rt
ğ¶ âŠ¢ array.init_elem ğ‘¥ ğ‘¦ : [(ref null ğ‘¥) i32 i32 i32] â†’ []

3.4.4 Scalar Reference Instructions
ref.i31
â€¢ The instruction is valid with type [i32] â†’ [(ref i31)].
ğ¶ âŠ¢ ref.i31 : [i32] â†’ [(ref i31)]
i31.get_sx
â€¢ The instruction is valid with type [(ref null i31)] â†’ [i32].
ğ¶ âŠ¢ i31.get_sx : [(ref null i31)] â†’ [i32]

3.4.5 External Reference Instructions
any.convert_extern
â€¢ The instruction is valid with type [(ref null?1 extern)] â†’ [(ref null?2 any)] for any null?1 that equals null?2 .
null?1 = null?2
ğ¶ âŠ¢ any.convert_extern : [(ref null?1 extern)] â†’ [(ref null?2 any)]
extern.convert_any
â€¢ The instruction is valid with type [(ref null?1 any)] â†’ [(ref null?2 extern)] for any null?1 that equals null?2 .
null?1 = null?2
ğ¶ âŠ¢ extern.convert_any : [(ref null?1 any)] â†’ [(ref null?2 extern)]

3.4. Instructions

51

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

3.4.6 Vector Instructions
Vector instructions can have a prefix to describe the shape of the operand. Packed numeric types, i8 and i16, are
not value types. An auxiliary function maps such packed type shapes to value types:
unpack(ğ‘¡xğ‘ )

=

unpack(ğ‘¡)

The following auxiliary function denotes the number of lanes in a vector shape, i.e., its dimension:

dim(ğ‘¡xğ‘ )

= ğ‘

v128.const ğ‘
â€¢ The instruction is valid with type [] â†’ [v128].
ğ¶ âŠ¢ v128.const ğ‘ : [] â†’ [v128]
v128.vvunop
â€¢ The instruction is valid with type [v128] â†’ [v128].
ğ¶ âŠ¢ v128.vvunop : [v128] â†’ [v128]
v128.vvbinop
â€¢ The instruction is valid with type [v128 v128] â†’ [v128].
ğ¶ âŠ¢ v128.vvbinop : [v128 v128] â†’ [v128]
v128.vvternop
â€¢ The instruction is valid with type [v128 v128 v128] â†’ [v128].
ğ¶ âŠ¢ v128.vvternop : [v128 v128 v128] â†’ [v128]
v128.vvtestop
â€¢ The instruction is valid with type [v128] â†’ [i32].
ğ¶ âŠ¢ v128.vvtestop : [v128] â†’ [i32]
i8x16.swizzle
â€¢ The instruction is valid with type [v128 v128] â†’ [v128].
ğ¶ âŠ¢ i8x16.swizzle : [v128 v128] â†’ [v128]
i8x16.relaxed_swizzle
â€¢ The instruction is valid with type [v128 v128] â†’ [v128].
ğ¶ âŠ¢ i8x16.relaxed_swizzle : [v128 v128] â†’ [v128]
i8x16.shuffle laneidx 16
â€¢ For all laneidx ğ‘– , in laneidx 16 , laneidx ğ‘– must be smaller than 32.
â€¢ The instruction is valid with type [v128 v128] â†’ [v128].
(laneidx < 32)16
ğ¶ âŠ¢ i8x16.shuffle laneidx 16 : [v128 v128] â†’ [v128]
52

Chapter 3. Validation

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

shape.splat
â€¢ Let ğ‘¡ be unpack(shape).
â€¢ The instruction is valid with type [ğ‘¡] â†’ [v128].
ğ¶ âŠ¢ shape.splat : [unpack(shape)] â†’ [v128]
shape.extract_lane_sx ? laneidx
â€¢ The lane index laneidx must be smaller than dim(shape).
â€¢ The instruction is valid with type [v128] â†’ [unpack(shape)].
laneidx < dim(shape)
ğ¶ âŠ¢ shape.extract_lane_sx ? laneidx : [v128] â†’ [unpack(shape)]
shape.replace_lane laneidx
â€¢ The lane index laneidx must be smaller than dim(shape).
â€¢ Let ğ‘¡ be unpack(shape).
â€¢ The instruction is valid with type [v128 ğ‘¡] â†’ [v128].
laneidx < dim(shape)
ğ¶ âŠ¢ shape.replace_lane laneidx : [v128 unpack(shape)] â†’ [v128]
shape.vunop
â€¢ The instruction is valid with type [v128] â†’ [v128].
ğ¶ âŠ¢ shape.vunop : [v128] â†’ [v128]
shape.vbinop
â€¢ The instruction is valid with type [v128 v128] â†’ [v128].
ğ¶ âŠ¢ shape.vbinop : [v128 v128] â†’ [v128]
shape.vternop
â€¢ The instruction is valid with type [v128 v128 v128] â†’ [v128].
ğ¶ âŠ¢ shape.vternop : [v128 v128 v128] â†’ [v128]
shape.relaxed_laneselect
â€¢ The instruction is valid with type [v128 v128 v128] â†’ [v128].
ğ¶ âŠ¢ shape.relaxed_laneselect : [v128 v128 v128] â†’ [v128]
shape.vrelop
â€¢ The instruction is valid with type [v128 v128] â†’ [v128].
ğ¶ âŠ¢ shape.vrelop : [v128 v128] â†’ [v128]
ishape.vishiftop
â€¢ The instruction is valid with type [v128 i32] â†’ [v128].
ğ¶ âŠ¢ ishape.vishiftop : [v128 i32] â†’ [v128]

3.4. Instructions

53

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

shape.vtestop
â€¢ The instruction is valid with type [v128] â†’ [i32].
ğ¶ âŠ¢ shape.vtestop : [v128] â†’ [i32]
shape.vcvtop_half ? _shape_sx ? _zero?
â€¢ The instruction is valid with type [v128] â†’ [v128].
ğ¶ âŠ¢ shape.vcvtop_half ? _shape_sx ? _zero? : [v128] â†’ [v128]
ishape 1 .narrow_ishape 2 _sx
â€¢ The instruction is valid with type [v128 v128] â†’ [v128].
ğ¶ âŠ¢ ishape 1 .narrow_ishape 2 _sx : [v128 v128] â†’ [v128]
ishape.bitmask
â€¢ The instruction is valid with type [v128] â†’ [i32].
ğ¶ âŠ¢ ishape.bitmask : [v128] â†’ [i32]
ishape 1 .dot_ishape 2 _s
â€¢ The instruction is valid with type [v128 v128] â†’ [v128].
ğ¶ âŠ¢ ishape 1 .dot_ishape 2 _s : [v128 v128] â†’ [v128]
ishape 1 .dot_ishape 2 _i7x16_s
â€¢ The instruction is valid with type [v128 v128] â†’ [v128].
ğ¶ âŠ¢ ishape 1 .dot_ishape 2 _i7x16_s : [v128 v128] â†’ [v128]
ishape 1 .dot_ishape 2 _i7x16_add__s
â€¢ The instruction is valid with type [v128 v128 v128] â†’ [v128].
ğ¶ âŠ¢ ishape 1 .dot_ishape 2 _i7x16_add__s : [v128 v128 v128] â†’ [v128]
ishape 1 .extmul_half _ishape 2 _sx
â€¢ The instruction is valid with type [v128 v128] â†’ [v128].
ğ¶ âŠ¢ ishape 1 .extmul_half _ishape 2 _sx : [v128 v128] â†’ [v128]
ishape 1 .extadd_pairwise_ishape 2 _sx
â€¢ The instruction is valid with type [v128] â†’ [v128].
ğ¶ âŠ¢ ishape 1 .extadd_pairwise_ishape 2 _sx : [v128] â†’ [v128]

54

Chapter 3. Validation

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

3.4.7 Parametric Instructions
drop
â€¢ The instruction is valid with type [ğ‘¡] â†’ [], for any valid value type ğ‘¡.
ğ¶ âŠ¢ ğ‘¡ ok
ğ¶ âŠ¢ drop : [ğ‘¡] â†’ []
Ã² Note
Both drop and select without annotation are value-polymorphic instructions.
select (ğ‘¡* )?
â€¢ If ğ‘¡* is present, then:
â€“ The result type [ğ‘¡* ] must be valid.
â€“ The length of ğ‘¡* must be 1.
â€“ Then the instruction is valid with type [ğ‘¡* ğ‘¡* i32] â†’ [ğ‘¡* ].
â€¢ Else:
â€“ The instruction is valid with type [ğ‘¡ ğ‘¡ i32] â†’ [ğ‘¡], for any valid value type ğ‘¡ that matches some number
type or vector type.
ğ¶ âŠ¢ [ğ‘¡] ok
ğ¶ âŠ¢ select ğ‘¡ : [ğ‘¡ ğ‘¡ i32] â†’ [ğ‘¡]

ğ¶ âŠ¢ [ğ‘¡] ok
ğ¶ âŠ¢ [ğ‘¡] â‰¤ [numtype]
ğ¶ âŠ¢ select : [ğ‘¡ ğ‘¡ i32] â†’ [ğ‘¡]

ğ¶ âŠ¢ [ğ‘¡] ok
ğ¶ âŠ¢ ğ‘¡ â‰¤ vectype
ğ¶ âŠ¢ select : [ğ‘¡ ğ‘¡ i32] â†’ [ğ‘¡]

Ã² Note
In future versions of WebAssembly, select may allow more than one value per choice.

3.4.8 Variable Instructions
local.get ğ‘¥
â€¢ The local ğ¶.locals[ğ‘¥] must be defined in the context.
â€¢ Let init ğ‘¡ be the local type ğ¶.locals[ğ‘¥].
â€¢ The initialization status init must be set.
â€¢ Then the instruction is valid with type [] â†’ [ğ‘¡].
ğ¶.locals[ğ‘¥] = set ğ‘¡
ğ¶ âŠ¢ local.get ğ‘¥ : [] â†’ [ğ‘¡]
local.set ğ‘¥
â€¢ The local ğ¶.locals[ğ‘¥] must be defined in the context.
â€¢ Let init ğ‘¡ be the local type ğ¶.locals[ğ‘¥].
â€¢ Then the instruction is valid with type [ğ‘¡] â†’ğ‘¥ [].
ğ¶.locals[ğ‘¥] = init ğ‘¡
ğ¶ âŠ¢ local.set ğ‘¥ : [ğ‘¡] â†’ğ‘¥ []

3.4. Instructions

55

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

local.tee ğ‘¥
â€¢ The local ğ¶.locals[ğ‘¥] must be defined in the context.
â€¢ Let init ğ‘¡ be the local type ğ¶.locals[ğ‘¥].
â€¢ Then the instruction is valid with type [ğ‘¡] â†’ğ‘¥ [ğ‘¡].
ğ¶.locals[ğ‘¥] = init ğ‘¡
ğ¶ âŠ¢ local.tee ğ‘¥ : [ğ‘¡] â†’ğ‘¥ [ğ‘¡]
global.get ğ‘¥
â€¢ The global ğ¶.globals[ğ‘¥] must be defined in the context.
â€¢ Let mut ğ‘¡ be the global type ğ¶.globals[ğ‘¥].
â€¢ Then the instruction is valid with type [] â†’ [ğ‘¡].
ğ¶.globals[ğ‘¥] = mut ğ‘¡
ğ¶ âŠ¢ global.get ğ‘¥ : [] â†’ [ğ‘¡]
global.set ğ‘¥
â€¢ The global ğ¶.globals[ğ‘¥] must be defined in the context.
â€¢ Let mut ğ‘¡ be the global type ğ¶.globals[ğ‘¥].
â€¢ The mutability mut must be var.
â€¢ Then the instruction is valid with type [ğ‘¡] â†’ [].
ğ¶.globals[ğ‘¥] = var ğ‘¡
ğ¶ âŠ¢ global.set ğ‘¥ : [ğ‘¡] â†’ []

3.4.9 Table Instructions
table.get ğ‘¥
â€¢ The table ğ¶.tables[ğ‘¥] must be defined in the context.
â€¢ Let at limits ğ‘¡ be the table type ğ¶.tables[ğ‘¥].
â€¢ Then the instruction is valid with type [at] â†’ [ğ‘¡].
ğ¶.tables[ğ‘¥] = at limits ğ‘¡
ğ¶ âŠ¢ table.get ğ‘¥ : [at] â†’ [ğ‘¡]
table.set ğ‘¥
â€¢ The table ğ¶.tables[ğ‘¥] must be defined in the context.
â€¢ Let at limits ğ‘¡ be the table type ğ¶.tables[ğ‘¥].
â€¢ Then the instruction is valid with type [at ğ‘¡] â†’ [].
ğ¶.tables[ğ‘¥] = at limits ğ‘¡
ğ¶ âŠ¢ table.set ğ‘¥ : [at ğ‘¡] â†’ []
table.size ğ‘¥
â€¢ The table ğ¶.tables[ğ‘¥] must be defined in the context.
â€¢ Let at limits ğ‘¡ be the table type ğ¶.tables[ğ‘¥].
â€¢ Then the instruction is valid with type [] â†’ [at].
ğ¶.tables[ğ‘¥] = at limits ğ‘¡
ğ¶ âŠ¢ table.size ğ‘¥ : [] â†’ [at]
56

Chapter 3. Validation

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

table.grow ğ‘¥
â€¢ The table ğ¶.tables[ğ‘¥] must be defined in the context.
â€¢ Let at limits ğ‘¡ be the table type ğ¶.tables[ğ‘¥].
â€¢ Then the instruction is valid with type [ğ‘¡ at] â†’ [at].
ğ¶.tables[ğ‘¥] = at limits ğ‘¡
ğ¶ âŠ¢ table.grow ğ‘¥ : [ğ‘¡ at] â†’ [at]
table.fill ğ‘¥
â€¢ The table ğ¶.tables[ğ‘¥] must be defined in the context.
â€¢ Let at limits ğ‘¡ be the table type ğ¶.tables[ğ‘¥].
â€¢ Then the instruction is valid with type [at ğ‘¡ at] â†’ [].
ğ¶.tables[ğ‘¥] = at limits ğ‘¡
ğ¶ âŠ¢ table.fill ğ‘¥ : [at ğ‘¡ at] â†’ []
table.copy ğ‘¥ ğ‘¦
â€¢ The table ğ¶.tables[ğ‘¥] must be defined in the context.
â€¢ Let at 1 limits 1 ğ‘¡1 be the table type ğ¶.tables[ğ‘¥].
â€¢ The table ğ¶.tables[ğ‘¦] must be defined in the context.
â€¢ Let at 2 limits 2 ğ‘¡2 be the table type ğ¶.tables[ğ‘¦].
â€¢ The reference type ğ‘¡2 must match ğ‘¡1 .
â€¢ Let at be the minimum of at 1 and at 2
â€¢ Then the instruction is valid with type [at 1 at 2 at] â†’ [].
ğ¶.tables[ğ‘¥] = at limits 1 ğ‘¡1
ğ¶.tables[ğ‘¦] = at limits 2 ğ‘¡2
ğ¶ âŠ¢ ğ‘¡2 â‰¤ ğ‘¡1
ğ¶ âŠ¢ table.copy ğ‘¥ ğ‘¦ : [at 1 at 2 min(at 1 , at 2 )] â†’ []
table.init ğ‘¥ ğ‘¦
â€¢ The table ğ¶.tables[ğ‘¥] must be defined in the context.
â€¢ Let at limits ğ‘¡1 be the table type ğ¶.tables[ğ‘¥].
â€¢ The element segment ğ¶.elems[ğ‘¦] must be defined in the context.
â€¢ Let ğ‘¡2 be the reference type ğ¶.elems[ğ‘¦].
â€¢ The reference type ğ‘¡2 must match ğ‘¡1 .
â€¢ Then the instruction is valid with type [at i32 i32] â†’ [].
ğ¶.tables[ğ‘¥] = at limits ğ‘¡1
ğ¶.elems[ğ‘¦] = ğ‘¡2
ğ¶ âŠ¢ ğ‘¡2 â‰¤ ğ‘¡1
ğ¶ âŠ¢ table.init ğ‘¥ ğ‘¦ : [at i32 i32] â†’ []
elem.drop ğ‘¥
â€¢ The element segment ğ¶.elems[ğ‘¥] must be defined in the context.
â€¢ Then the instruction is valid with type [] â†’ [].
ğ¶.elems[ğ‘¥] = ğ‘¡
ğ¶ âŠ¢ elem.drop ğ‘¥ : [] â†’ []

3.4. Instructions

57

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

3.4.10 Memory Instructions
ğ‘¡.load ğ‘¥ memarg
â€¢ The memory ğ¶.mems[ğ‘¥] must be defined in the context.
â€¢ Let at limits be the memory type ğ¶.mems[ğ‘¥].
â€¢ The offset memarg.offset must be less than 2|at| .
â€¢ The alignment 2memarg.align must not be larger than the bit width of ğ‘¡ divided by 8.
â€¢ Then the instruction is valid with type [at] â†’ [ğ‘¡].
ğ¶.mems[ğ‘¥] = at limits
memarg.offset < 2|at|
2memarg.align â‰¤ |ğ‘¡|/8
ğ¶ âŠ¢ ğ‘¡.load ğ‘¥ memarg : [at] â†’ [ğ‘¡]
ğ‘¡.loadğ‘ _sx ğ‘¥ memarg
â€¢ The memory ğ¶.mems[ğ‘¥] must be defined in the context.
â€¢ Let at limits be the memory type ğ¶.mems[ğ‘¥].
â€¢ The offset memarg.offset must be less than 2|at| .
â€¢ The alignment 2memarg.align must not be larger than ğ‘/8.
â€¢ Then the instruction is valid with type [at] â†’ [ğ‘¡].
ğ¶.mems[ğ‘¥] = at limits
memarg.offset < 2|at|
2memarg.align â‰¤ ğ‘/8
ğ¶ âŠ¢ ğ‘¡.loadğ‘ _sx ğ‘¥ memarg : [at] â†’ [ğ‘¡]
ğ‘¡.store ğ‘¥ memarg
â€¢ The memory ğ¶.mems[ğ‘¥] must be defined in the context.
â€¢ Let at limits be the memory type ğ¶.mems[ğ‘¥].
â€¢ The offset memarg.offset must be less than 2|at| .
â€¢ The alignment 2memarg.align must not be larger than the bit width of ğ‘¡ divided by 8.
â€¢ Then the instruction is valid with type [at ğ‘¡] â†’ [].
ğ¶.mems[ğ‘¥] = at limits
memarg.offset < 2|at|
2memarg.align â‰¤ |ğ‘¡|/8
ğ¶ âŠ¢ ğ‘¡.store ğ‘¥ memarg : [at ğ‘¡] â†’ []
ğ‘¡.storeğ‘ ğ‘¥ memarg
â€¢ The memory ğ¶.mems[ğ‘¥] must be defined in the context.
â€¢ Let at limits be the memory type ğ¶.mems[ğ‘¥].
â€¢ The offset memarg.offset must be less than 2|at| .
â€¢ The alignment 2memarg.align must not be larger than ğ‘/8.
â€¢ Then the instruction is valid with type [at ğ‘¡] â†’ [].
ğ¶.mems[ğ‘¥] = at limits
memarg.offset < 2|at|
2memarg.align â‰¤ ğ‘/8
ğ¶ âŠ¢ ğ‘¡.storeğ‘ ğ‘¥ memarg : [at ğ‘¡] â†’ []
v128.loadğ‘ xğ‘€ _sx ğ‘¥ memarg
â€¢ The memory ğ¶.mems[ğ‘¥] must be defined in the context.
â€¢ Let at limits be the memory type ğ¶.mems[ğ‘¥].
â€¢ The offset memarg.offset must be less than 2|at| .
â€¢ The alignment 2memarg.align must not be larger than ğ‘/8 Â· ğ‘€ .
58

Chapter 3. Validation

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

â€¢ Then the instruction is valid with type [at] â†’ [v128].
ğ¶.mems[ğ‘¥] = at limits
memarg.offset < 2|at|
2memarg.align â‰¤ ğ‘/8 Â· ğ‘€
ğ¶ âŠ¢ v128.loadğ‘ xğ‘€ _sx ğ‘¥ memarg : [at] â†’ [v128]
v128.loadğ‘ _splat ğ‘¥ memarg
â€¢ The memory ğ¶.mems[ğ‘¥] must be defined in the context.
â€¢ Let at limits be the memory type ğ¶.mems[ğ‘¥].
â€¢ The offset memarg.offset must be less than 2|at| .
â€¢ The alignment 2memarg.align must not be larger than ğ‘/8.
â€¢ Then the instruction is valid with type [at] â†’ [v128].
ğ¶.mems[ğ‘¥] = at limits
memarg.offset < 2|at|
2memarg.align â‰¤ ğ‘/8
ğ¶ âŠ¢ v128.loadğ‘ _splat ğ‘¥ memarg : [at] â†’ [v128]
v128.loadğ‘ _zero ğ‘¥ memarg
â€¢ The memory ğ¶.mems[ğ‘¥] must be defined in the context.
â€¢ Let at limits be the memory type ğ¶.mems[ğ‘¥].
â€¢ The offset memarg.offset must be less than 2|at| .
â€¢ The alignment 2memarg.align must not be larger than ğ‘/8.
â€¢ Then the instruction is valid with type [at] â†’ [v128].
ğ¶.mems[ğ‘¥] = at limits
memarg.offset < 2|at|
2memarg.align â‰¤ ğ‘/8
ğ¶ âŠ¢ v128.loadğ‘ _zero ğ‘¥ memarg : [at] â†’ [v128]
v128.loadğ‘ _lane ğ‘¥ memarg laneidx
â€¢ The memory ğ¶.mems[ğ‘¥] must be defined in the context.
â€¢ Let at limits be the memory type ğ¶.mems[ğ‘¥].
â€¢ The offset memarg.offset must be less than 2|at| .
â€¢ The alignment 2memarg.align must not be larger than ğ‘/8.
â€¢ The lane index laneidx must be smaller than 128/ğ‘ .
â€¢ Then the instruction is valid with type [at v128] â†’ [v128].
ğ¶.mems[ğ‘¥] = at limits
memarg.offset < 2|at|
2memarg.align â‰¤ ğ‘/8
laneidx < 128/ğ‘
ğ¶ âŠ¢ v128.loadğ‘ _lane ğ‘¥ memarg laneidx : [at v128] â†’ [v128]
v128.storeğ‘ _lane ğ‘¥ memarg laneidx
â€¢ The memory ğ¶.mems[ğ‘¥] must be defined in the context.
â€¢ Let at limits be the memory type ğ¶.mems[ğ‘¥].
â€¢ The offset memarg.offset must be less than 2|at| .
â€¢ The alignment 2memarg.align must not be larger than ğ‘/8.
â€¢ The lane index laneidx must be smaller than 128/ğ‘ .
â€¢ Then the instruction is valid with type [at v128] â†’ [].
ğ¶.mems[ğ‘¥] = at limits
memarg.offset < 2|at|
2memarg.align â‰¤ ğ‘/8
laneidx < 128/ğ‘
ğ¶ âŠ¢ v128.storeğ‘ _lane ğ‘¥ memarg laneidx : [at v128] â†’ []

3.4. Instructions

59

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

memory.size ğ‘¥
â€¢ The memory ğ¶.mems[ğ‘¥] must be defined in the context.
â€¢ Let at limits be the memory type ğ¶.mems[ğ‘¥].
â€¢ Then the instruction is valid with type [] â†’ [at].
ğ¶.mems[ğ‘¥] = at limits
ğ¶ âŠ¢ memory.size ğ‘¥ : [] â†’ [at]
memory.grow ğ‘¥
â€¢ The memory ğ¶.mems[ğ‘¥] must be defined in the context.
â€¢ Let at limits be the memory type ğ¶.mems[ğ‘¥].
â€¢ Then the instruction is valid with type [at] â†’ [at].
ğ¶.mems[ğ‘¥] = at limits
ğ¶ âŠ¢ memory.grow ğ‘¥ : [at] â†’ [at]
memory.fill ğ‘¥
â€¢ The memory ğ¶.mems[ğ‘¥] must be defined in the context.
â€¢ Let at limits be the memory type ğ¶.mems[ğ‘¥].
â€¢ Then the instruction is valid with type [at i32 at] â†’ [].
ğ¶.mems[ğ‘¥] = at limits
ğ¶ âŠ¢ memory.fill ğ‘¥ : [at i32 at] â†’ []
memory.copy ğ‘¥ ğ‘¦
â€¢ The memory ğ¶.mems[ğ‘¥] must be defined in the context.
â€¢ The memory ğ¶.mems[ğ‘¦] must be defined in the context.
â€¢ Let at ğ‘¥ limits ğ‘¥ be the memory type ğ¶.mems[ğ‘¥].
â€¢ Let at ğ‘¦ limits ğ‘¦ be the memory type ğ¶.mems[ğ‘¦].
â€¢ Let at be the minimum of at ğ‘¥ and at ğ‘¦
â€¢ Then the instruction is valid with type [at ğ‘¥ at ğ‘¦ at] â†’ [].
ğ¶.mems[ğ‘¥] = at ğ‘¥ limits ğ‘¦
ğ¶.mems[ğ‘¦] = at ğ‘¦ limits ğ‘¦
ğ¶ âŠ¢ memory.copy ğ‘¥ ğ‘¦ : [at ğ‘¥ at ğ‘¦ min(at ğ‘¥ , at ğ‘¦ )] â†’ []
memory.init ğ‘¥ ğ‘¦
â€¢ The memory ğ¶.mems[ğ‘¥] must be defined in the context.
â€¢ Let at limits be the memory type ğ¶.mems[ğ‘¥].
â€¢ The data segment ğ¶.datas[ğ‘¦] must be defined in the context.
â€¢ Then the instruction is valid with type [at i32 i32] â†’ [].
ğ¶.mems[ğ‘¥] = at limits
ğ¶.datas[ğ‘¦] = ok
ğ¶ âŠ¢ memory.init ğ‘¥ ğ‘¦ : [at i32 i32] â†’ []

60

Chapter 3. Validation

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

data.drop ğ‘¥
â€¢ The data segment ğ¶.datas[ğ‘¥] must be defined in the context.
â€¢ Then the instruction is valid with type [] â†’ [].
ğ¶.datas[ğ‘¥] = ok
ğ¶ âŠ¢ data.drop ğ‘¥ : [] â†’ []

3.4.11 Control Instructions
nop
â€¢ The instruction is valid with type [] â†’ [].
ğ¶ âŠ¢ nop : [] â†’ []
unreachable
â€¢ The instruction is valid with any valid type of the form [ğ‘¡*1 ] â†’ [ğ‘¡*2 ].
ğ¶ âŠ¢ [ğ‘¡*1 ] â†’ [ğ‘¡*2 ] ok
ğ¶ âŠ¢ unreachable : [ğ‘¡*1 ] â†’ [ğ‘¡*2 ]
Ã² Note
The unreachable instruction is stack-polymorphic.
block blocktype instr * end
â€¢ The block type must be valid as some instruction type [ğ‘¡*1 ] â†’ [ğ‘¡*2 ].
â€¢ Let ğ¶ â€² be the same context as ğ¶, but with the result type [ğ‘¡*2 ] prepended to the labels vector.
â€¢ Under context ğ¶ â€² , the instruction sequence instr * must be valid with type [ğ‘¡*1 ] â†’ [ğ‘¡*2 ].
â€¢ Then the compound instruction is valid with type [ğ‘¡*1 ] â†’ [ğ‘¡*2 ].
ğ¶ âŠ¢ blocktype : [ğ‘¡*1 ] â†’ [ğ‘¡*2 ]
ğ¶, labels [ğ‘¡*2 ] âŠ¢ instr * : [ğ‘¡*1 ] â†’ [ğ‘¡*2 ]
ğ¶ âŠ¢ block blocktype instr * end : [ğ‘¡*1 ] â†’ [ğ‘¡*2 ]
Ã² Note
The notation ğ¶, labels [ğ‘¡* ] inserts the new label type at index 0, shifting all others.
loop blocktype instr * end
â€¢ The block type must be valid as some instruction type [ğ‘¡*1 ] â†’ [ğ‘¡*2 ].
â€¢ Let ğ¶ â€² be the same context as ğ¶, but with the result type [ğ‘¡*1 ] prepended to the labels vector.
â€¢ Under context ğ¶ â€² , the instruction sequence instr * must be valid with type [ğ‘¡*1 ] â†’ [ğ‘¡*2 ].
â€¢ Then the compound instruction is valid with type [ğ‘¡*1 ] â†’ [ğ‘¡*2 ].
ğ¶, labels [ğ‘¡*1 ] âŠ¢ instr * : [ğ‘¡*1 ] â†’ [ğ‘¡*2 ]
ğ¶ âŠ¢ blocktype : [ğ‘¡*1 ] â†’ [ğ‘¡*2 ]
ğ¶ âŠ¢ loop blocktype instr * end : [ğ‘¡*1 ] â†’ [ğ‘¡*2 ]
Ã² Note
The notation ğ¶, labels [ğ‘¡* ] inserts the new label type at index 0, shifting all others.

3.4. Instructions

61

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

if blocktype instr *1 else instr *2 end
â€¢ The block type must be valid as some instruction type [ğ‘¡*1 ] â†’ [ğ‘¡*2 ].
â€¢ Let ğ¶ â€² be the same context as ğ¶, but with the result type [ğ‘¡*2 ] prepended to the labels vector.
â€¢ Under context ğ¶ â€² , the instruction sequence instr *1 must be valid with type [ğ‘¡*1 ] â†’ [ğ‘¡*2 ].
â€¢ Under context ğ¶ â€² , the instruction sequence instr *2 must be valid with type [ğ‘¡*1 ] â†’ [ğ‘¡*2 ].
â€¢ Then the compound instruction is valid with type [ğ‘¡*1 i32] â†’ [ğ‘¡*2 ].
ğ¶ âŠ¢ blocktype : [ğ‘¡*1 ] â†’ [ğ‘¡*2 ]
ğ¶, labels [ğ‘¡*2 ] âŠ¢ instr *1 : [ğ‘¡*1 ] â†’ [ğ‘¡*2 ]
ğ¶, labels [ğ‘¡*2 ] âŠ¢ instr *2 : [ğ‘¡*1 ] â†’ [ğ‘¡*2 ]
*
*
*
ğ¶ âŠ¢ if blocktype instr 1 else instr 2 end : [ğ‘¡1 i32] â†’ [ğ‘¡*2 ]
Ã² Note
The notation ğ¶, labels [ğ‘¡* ] inserts the new label type at index 0, shifting all others.
try_table blocktype catch * instr * end
â€¢ The block type must be valid as some instruction type [ğ‘¡*1 ] â†’ [ğ‘¡*2 ].
â€¢ For every catch clause catch ğ‘– in catch * , catch ğ‘– must be valid.
â€¢ Let ğ¶ â€² be the same context as ğ¶, but with the result type [ğ‘¡*2 ] prepended to the labels vector.
â€¢ Under context ğ¶ â€² , the instruction sequence instr * must be valid with type [ğ‘¡*1 ] â†’ [ğ‘¡*2 ].
â€¢ Then the compound instruction is valid with type [ğ‘¡*1 ] â†’ [ğ‘¡*2 ].
ğ¶ âŠ¢ blocktype : [ğ‘¡*1 ] â†’ [ğ‘¡*2 ]
(ğ¶ âŠ¢ catch ok)*
ğ¶, labels [ğ‘¡*2 ] âŠ¢ instr * : [ğ‘¡*1 ] â†’ [ğ‘¡*2 ]
ğ¶ âŠ¢ try_table blocktype catch * instr * end : [ğ‘¡*1 ] â†’ [ğ‘¡*2 ]
Ã² Note
The notation ğ¶, labels [ğ‘¡* ] inserts the new label type at index 0, shifting all others.
catch ğ‘¥ ğ‘™
â€¢ The tag ğ¶.tags[ğ‘¥] must be defined in the context.
*

â€¢ Let [ğ‘¡* ] â†’ [ğ‘¡â€² ] be the expansion of the tag type ğ¶.tags[ğ‘¥].
*

â€¢ The result type [ğ‘¡â€² ] must be empty.
â€¢ The label ğ¶.labels[ğ‘™] must be defined in the context.
â€¢ The result type [ğ‘¡* ] must match ğ¶.labels[ğ‘™].
â€¢ Then the catch clause is valid.
expand(ğ¶.tags[ğ‘¥]) = [ğ‘¡* ] â†’ []
ğ¶ âŠ¢ [ğ‘¡* ] â‰¤ ğ¶.labels[ğ‘™]
ğ¶ âŠ¢ catch ğ‘¥ ğ‘™ ok
catch_ref ğ‘¥ ğ‘™
â€¢ The tag ğ¶.tags[ğ‘¥] must be defined in the context.
*

â€¢ Let [ğ‘¡* ] â†’ [ğ‘¡â€² ] be the expansion of the tag type ğ¶.tags[ğ‘¥].
*

â€¢ The result type [ğ‘¡â€² ] must be empty.
â€¢ The label ğ¶.labels[ğ‘™] must be defined in the context.
â€¢ The result type [ğ‘¡* (ref exn)] must match ğ¶.labels[ğ‘™].

62

Chapter 3. Validation

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

â€¢ Then the catch clause is valid.
expand(ğ¶.tags[ğ‘¥]) = [ğ‘¡* ] â†’ []
ğ¶ âŠ¢ [ğ‘¡* (ref exn)] â‰¤ ğ¶.labels[ğ‘™]
ğ¶ âŠ¢ catch_ref ğ‘¥ ğ‘™ ok
catch_all ğ‘™
â€¢ The label ğ¶.labels[ğ‘™] must be defined in the context.
â€¢ The result type [] must match ğ¶.labels[ğ‘™].
â€¢ Then the catch clause is valid.
ğ¶ âŠ¢ [] â‰¤ ğ¶.labels[ğ‘™]
ğ¶ âŠ¢ catch_all ğ‘™ ok
catch_all_ref ğ‘™
â€¢ The label ğ¶.labels[ğ‘™] must be defined in the context.
â€¢ The result type [(ref exn)] must match ğ¶.labels[ğ‘™].
â€¢ Then the catch clause is valid.
ğ¶ âŠ¢ [(ref exn)] â‰¤ ğ¶.labels[ğ‘™]
ğ¶ âŠ¢ catch_all_ref ğ‘™ ok
br ğ‘™
â€¢ The label ğ¶.labels[ğ‘™] must be defined in the context.
â€¢ Let [ğ‘¡* ] be the result type ğ¶.labels[ğ‘™].
â€¢ Then the instruction is valid with any valid type of the form [ğ‘¡*1 ğ‘¡* ] â†’ [ğ‘¡*2 ].
ğ¶.labels[ğ‘™] = [ğ‘¡* ]
ğ¶ âŠ¢ [ğ‘¡*1 ğ‘¡* ] â†’ [ğ‘¡*2 ] ok
ğ¶ âŠ¢ br ğ‘™ : [ğ‘¡*1 ğ‘¡* ] â†’ [ğ‘¡*2 ]
Ã² Note
The label index space in the context ğ¶ contains the most recent label type first, so that ğ¶.labels[ğ‘™] performs a
relative lookup as expected.
The br instruction is stack-polymorphic.
br_if ğ‘™
â€¢ The label ğ¶.labels[ğ‘™] must be defined in the context.
â€¢ Let [ğ‘¡* ] be the result type ğ¶.labels[ğ‘™].
â€¢ Then the instruction is valid with type [ğ‘¡* i32] â†’ [ğ‘¡* ].
ğ¶.labels[ğ‘™] = [ğ‘¡* ]
ğ¶ âŠ¢ br_if ğ‘™ : [ğ‘¡* i32] â†’ [ğ‘¡* ]
Ã² Note
The label index space in the context ğ¶ contains the most recent label type first, so that ğ¶.labels[ğ‘™] performs a
relative lookup as expected.

3.4. Instructions

63

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

br_table ğ‘™* ğ‘™ğ‘
â€¢ The label ğ¶.labels[ğ‘™ğ‘ ] must be defined in the context.
â€¢ For each label ğ‘™ğ‘– in ğ‘™* , the label ğ¶.labels[ğ‘™ğ‘– ] must be defined in the context.
â€¢ There must be a sequence ğ‘¡* of value types, such that:
â€“ The result type [ğ‘¡* ] matches ğ¶.labels[ğ‘™ğ‘ ].
â€“ For all ğ‘™ğ‘– in ğ‘™* , the result type [ğ‘¡* ] matches ğ¶.labels[ğ‘™ğ‘– ].
â€¢ Then the instruction is valid with any valid type of the form [ğ‘¡*1 ğ‘¡* i32] â†’ [ğ‘¡*2 ].
(ğ¶ âŠ¢ [ğ‘¡* ] â‰¤ ğ¶.labels[ğ‘™])*
ğ¶ âŠ¢ [ğ‘¡* ] â‰¤ ğ¶.labels[ğ‘™ğ‘ ]
ğ¶ âŠ¢ [ğ‘¡*1 ğ‘¡* i32] â†’ [ğ‘¡*2 ] ok
ğ¶ âŠ¢ br_table ğ‘™* ğ‘™ğ‘ : [ğ‘¡*1 ğ‘¡* i32] â†’ [ğ‘¡*2 ]
Ã² Note
The label index space in the context ğ¶ contains the most recent label first, so that ğ¶.labels[ğ‘™ğ‘– ] performs a relative
lookup as expected.
The br_table instruction is stack-polymorphic.
Furthermore, the result type [ğ‘¡* ] is also chosen non-deterministically in this rule. Although it may seem necessary to compute [ğ‘¡* ] as the greatest lower bound of all label types in practice, a simple linear algorithm does
not require this.
br_on_null ğ‘™
â€¢ The label ğ¶.labels[ğ‘™] must be defined in the context.
â€¢ Let [ğ‘¡* ] be the result type ğ¶.labels[ğ‘™].
â€¢ Then the instruction is valid with type [ğ‘¡* (ref null ht)] â†’ [ğ‘¡* (ref ht)] for any valid heap type ht.
ğ¶.labels[ğ‘™] = [ğ‘¡* ]
ğ¶ âŠ¢ ht ok
*
ğ¶ âŠ¢ br_on_null ğ‘™ : [ğ‘¡ (ref null ht)] â†’ [ğ‘¡* (ref ht)]
br_on_non_null ğ‘™
â€¢ The label ğ¶.labels[ğ‘™] must be defined in the context.
*

â€¢ Let [ğ‘¡â€² ] be the result type ğ¶.labels[ğ‘™].
*

â€¢ The result type [ğ‘¡â€² ] must contain at least one type.
*

â€¢ Let the value type ğ‘¡ğ‘™ be the last element in the sequence ğ‘¡â€² , and [ğ‘¡* ] the remainder of the sequence preceding
it.
â€¢ The value type ğ‘¡ğ‘™ must be a reference type of the form ref null? ht.
â€¢ Then the instruction is valid with type [ğ‘¡* (ref null ht)] â†’ [ğ‘¡* ].
ğ¶.labels[ğ‘™] = [ğ‘¡* (ref null? ht)]
ğ¶ âŠ¢ br_on_non_null ğ‘™ : [ğ‘¡* (ref null ht)] â†’ [ğ‘¡* ]
br_on_cast ğ‘™ rt 1 rt 2
â€¢ The label ğ¶.labels[ğ‘™] must be defined in the context.
â€¢ Let [ğ‘¡*ğ‘™ ] be the result type ğ¶.labels[ğ‘™].
â€¢ The type sequence ğ‘¡*ğ‘™ must be of the form ğ‘¡* rt â€² .
â€¢ The reference type rt 1 must be valid.
â€¢ The reference type rt 2 must be valid.

64

Chapter 3. Validation

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

â€¢ The reference type rt 2 must match rt 1 .
â€¢ The reference type rt 2 must match rt â€² .
â€¢ Let rt â€²1 be the type difference between rt 1 and rt 2 .
â€¢ Then the instruction is valid with type [ğ‘¡* rt 1 ] â†’ [ğ‘¡* rt â€²1 ].
ğ¶.labels[ğ‘™] = [ğ‘¡* rt]

ğ¶ âŠ¢ rt 1 ok
ğ¶ âŠ¢ rt 2 ok
ğ¶ âŠ¢ rt 2 â‰¤ rt 1
ğ¶ âŠ¢ br_on_cast ğ‘™ rt 1 rt 2 : [ğ‘¡* rt 1 ] â†’ [ğ‘¡* rt 1 âˆ– rt 2 ]

ğ¶ âŠ¢ rt 2 â‰¤ rt

br_on_cast_fail ğ‘™ rt 1 rt 2
â€¢ The label ğ¶.labels[ğ‘™] must be defined in the context.
â€¢ Let [ğ‘¡*ğ‘™ ] be the result type ğ¶.labels[ğ‘™].
â€¢ The type sequence ğ‘¡*ğ‘™ must be of the form ğ‘¡* rt â€² .
â€¢ The reference type rt 1 must be valid.
â€¢ The reference type rt 2 must be valid.
â€¢ The reference type rt 2 must match rt 1 .
â€¢ Let rt â€²1 be the type difference between rt 1 and rt 2 .
â€¢ The reference type rt â€²1 must match rt â€² .
â€¢ Then the instruction is valid with type [ğ‘¡* rt 1 ] â†’ [ğ‘¡* rt 2 ].
ğ¶.labels[ğ‘™] = [ğ‘¡* rt]

ğ¶ âŠ¢ rt 1 ok
ğ¶ âŠ¢ rt 2 ok
ğ¶ âŠ¢ rt 2 â‰¤ rt 1
*
ğ¶ âŠ¢ br_on_cast_fail ğ‘™ rt 1 rt 2 : [ğ‘¡ rt 1 ] â†’ [ğ‘¡* rt 2 ]

ğ¶ âŠ¢ rt 1 âˆ– rt 2 â‰¤ rt

return
â€¢ The return type ğ¶.return must not be absent in the context.
â€¢ Let [ğ‘¡* ] be the result type of ğ¶.return.
â€¢ Then the instruction is valid with any valid type of the form [ğ‘¡*1 ğ‘¡* ] â†’ [ğ‘¡*2 ].
ğ¶.return = [ğ‘¡* ]
ğ¶ âŠ¢ [ğ‘¡*1 ğ‘¡* ] â†’ [ğ‘¡*2 ] ok
ğ¶ âŠ¢ return : [ğ‘¡*1 ğ‘¡* ] â†’ [ğ‘¡*2 ]
Ã² Note
The return instruction is stack-polymorphic.
ğ¶.return is absent (set to ğœ–) when validating an expression that is not a function body. This differs from it being
set to the empty result type ([ğœ–]), which is the case for functions not returning anything.
call ğ‘¥
â€¢ The function ğ¶.funcs[ğ‘¥] must be defined in the context.
â€¢ The expansion of ğ¶.funcs[ğ‘¥] must be a function type func [ğ‘¡*1 ] â†’ [ğ‘¡*2 ].
â€¢ Then the instruction is valid with type [ğ‘¡*1 ] â†’ [ğ‘¡*2 ].
expand(ğ¶.funcs[ğ‘¥]) = func [ğ‘¡*1 ] â†’ [ğ‘¡*2 ]
ğ¶ âŠ¢ call ğ‘¥ : [ğ‘¡*1 ] â†’ [ğ‘¡*2 ]

3.4. Instructions

65

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

call_ref ğ‘¥
â€¢ The type ğ¶.types[ğ‘¥] must be defined in the context.
â€¢ The expansion of ğ¶.types[ğ‘¥] must be a function type func [ğ‘¡*1 ] â†’ [ğ‘¡*2 ].
â€¢ Then the instruction is valid with type [ğ‘¡*1 (ref null ğ‘¥)] â†’ [ğ‘¡*2 ].
expand(ğ¶.types[ğ‘¥]) = func [ğ‘¡*1 ] â†’ [ğ‘¡*2 ]
ğ¶ âŠ¢ call_ref ğ‘¥ : [ğ‘¡*1 (ref null ğ‘¥)] â†’ [ğ‘¡*2 ]
call_indirect ğ‘¥ ğ‘¦
â€¢ The table ğ¶.tables[ğ‘¥] must be defined in the context.
â€¢ Let at limits ğ‘¡ be the table type ğ¶.tables[ğ‘¥].
â€¢ The reference type ğ‘¡ must match type ref null func.
â€¢ The type ğ¶.types[ğ‘¦] must be defined in the context.
â€¢ The expansion of ğ¶.types[ğ‘¦] must be a function type func [ğ‘¡*1 ] â†’ [ğ‘¡*2 ].
â€¢ Then the instruction is valid with type [ğ‘¡*1 at] â†’ [ğ‘¡*2 ].
ğ¶.tables[ğ‘¥] = at limits ğ‘¡

ğ¶ âŠ¢ ğ‘¡ â‰¤ ref null func
expand(ğ¶.types[ğ‘¦]) = func [ğ‘¡*1 ] â†’ [ğ‘¡*2 ]
*
ğ¶ âŠ¢ call_indirect ğ‘¥ ğ‘¦ : [ğ‘¡1 at] â†’ [ğ‘¡*2 ]

return_call ğ‘¥
â€¢ The return type ğ¶.return must not be absent in the context.
â€¢ The function ğ¶.funcs[ğ‘¥] must be defined in the context.
â€¢ The expansion of ğ¶.funcs[ğ‘¥] must be a function type func [ğ‘¡*1 ] â†’ [ğ‘¡*2 ].
â€¢ The result type [ğ‘¡*2 ] must match ğ¶.return.
â€¢ Then the instruction is valid with any valid type [ğ‘¡*3 ğ‘¡*1 ] â†’ [ğ‘¡*4 ].
expand(ğ¶.funcs[ğ‘¥]) = func [ğ‘¡*1 ] â†’ [ğ‘¡*2 ]
ğ¶ âŠ¢ [ğ‘¡*2 ] â‰¤ ğ¶.return
ğ¶ âŠ¢ return_call ğ‘¥ : [ğ‘¡*3 ğ‘¡*1 ] â†’ [ğ‘¡*4 ]

ğ¶ âŠ¢ [ğ‘¡*3 ğ‘¡*1 ] â†’ [ğ‘¡*4 ] ok

Ã² Note
The return_call instruction is stack-polymorphic.
return_call_ref ğ‘¥
â€¢ The type ğ¶.types[ğ‘¥] must be defined in the context.
â€¢ The expansion of ğ¶.types[ğ‘¥] must be a function type func [ğ‘¡*1 ] â†’ [ğ‘¡*2 ].
â€¢ The result type [ğ‘¡*2 ] must match ğ¶.return.
â€¢ Then the instruction is valid with any valid type [ğ‘¡*3 ğ‘¡*1 (ref null ğ‘¥)] â†’ [ğ‘¡*4 ].
ğ¶ âŠ¢ [ğ‘¡*2 ] â‰¤ ğ¶.return
ğ¶ âŠ¢ [ğ‘¡*3 ğ‘¡*1 (ref null ğ‘¥)] â†’ [ğ‘¡*4 ] ok
expand(ğ¶.types[ğ‘¥]) = func [ğ‘¡*1 ] â†’ [ğ‘¡*2 ]
*
*
ğ¶ âŠ¢ call_ref ğ‘¥ : [ğ‘¡3 ğ‘¡1 (ref null ğ‘¥)] â†’ [ğ‘¡*4 ]
Ã² Note
The return_call_ref instruction is stack-polymorphic.

66

Chapter 3. Validation

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

return_call_indirect ğ‘¥ ğ‘¦
â€¢ The return type ğ¶.return must not be empty in the context.
â€¢ The table ğ¶.tables[ğ‘¥] must be defined in the context.
â€¢ Let at limits ğ‘¡ be the table type ğ¶.tables[ğ‘¥].
â€¢ The reference type ğ‘¡ must match type ref null func.
â€¢ The type ğ¶.types[ğ‘¦] must be defined in the context.
â€¢ The expansion of ğ¶.types[ğ‘¦] must be a function type func [ğ‘¡*1 ] â†’ [ğ‘¡*2 ].
â€¢ The result type [ğ‘¡*2 ] must match ğ¶.return.
â€¢ Then the instruction is valid with type [ğ‘¡*3 ğ‘¡*1 at] â†’ [ğ‘¡*4 ], for any sequences of value types ğ‘¡*3 and ğ‘¡*4 .
ğ¶.tables[ğ‘¥] = at limits ğ‘¡

ğ¶ âŠ¢ ğ‘¡ â‰¤ ref null func

ğ¶ âŠ¢ [ğ‘¡*2 ] â‰¤ ğ¶.return
expand(ğ¶.types[ğ‘¦]) = func [ğ‘¡*1 ] â†’ [ğ‘¡*2 ]
ğ¶ âŠ¢ return_call_indirect ğ‘¥ ğ‘¦ : [ğ‘¡*3 ğ‘¡*1 at] â†’ [ğ‘¡*4 ]

Ã² Note
The return_call_indirect instruction is stack-polymorphic.
throw ğ‘¥
â€¢ The tag ğ¶.tags[ğ‘¥] must be defined in the context.
*

â€¢ Let [ğ‘¡* ] â†’ [ğ‘¡â€² ] be the expansion of the tag type ğ¶.tags[ğ‘¥].
*

â€¢ The result type [ğ‘¡â€² ] must be empty.
â€¢ Then the instruction is valid with type [ğ‘¡*1 ğ‘¡* ] â†’ [ğ‘¡*2 ], for any sequences of value types ğ‘¡*1 and ğ‘¡*2 .
expand(ğ¶.tags[ğ‘¥]) = [ğ‘¡* ] â†’ []
ğ¶ âŠ¢ throw ğ‘¥ : [ğ‘¡*1 ğ‘¡* ] â†’ [ğ‘¡*2 ]
Ã² Note
The throw instruction is stack-polymorphic.
throw_ref
â€¢ The instruction is valid with type [ğ‘¡*1 exnref] â†’ [ğ‘¡*2 ], for any sequences of value types ğ‘¡*1 and ğ‘¡*2 .
ğ¶ âŠ¢ throw_ref : [ğ‘¡*1 exnref] â†’ [ğ‘¡*2 ]
Ã² Note
The throw_ref instruction is stack-polymorphic.

3.4.12 Instruction Sequences
Typing of instruction sequences is defined recursively.
Empty Instruction Sequence: ğœ–
â€¢ The empty instruction sequence is valid with type [] â†’ [].
ğ¶ âŠ¢ ğœ– : [] â†’ []
3.4. Instructions

67

ğ¶âŠ¢

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

Non-empty Instruction Sequence: instr instr â€²

*

â€¢ The instruction instr must be valid with some type [ğ‘¡*1 ] â†’ğ‘¥*1 [ğ‘¡*2 ].
â€¢ Let ğ¶ â€² be the same context as ğ¶, but with:
â€“ locals the same as in C, except that for every local index ğ‘¥ in ğ‘¥*1 , the local type locals[ğ‘¥] has been
updated to initialization status set.
*

â€¢ Under the context ğ¶ â€² , the instruction sequence instr â€² must be valid with some type [ğ‘¡*2 ] â†’ğ‘¥*2 [ğ‘¡*3 ].
â€¢ Then the combined instruction sequence is valid with type [ğ‘¡*1 ] â†’ğ‘¥*1 ğ‘¥*2 [ğ‘¡*3 ].
ğ¶ âŠ¢ instr : [ğ‘¡*1 ] â†’ğ‘¥*1 [ğ‘¡*2 ]
(ğ¶.locals[ğ‘¥1 ] = init ğ‘¡)*
â€²
â€²*
*
*
ğ¶ âŠ¢ instr : [ğ‘¡2 ] â†’ğ‘¥*2 [ğ‘¡3 ]
ğ¶ â€² = ğ¶ (with ğ¶.locals[ğ‘¥1 ] = set ğ‘¡)*
ğ¶ âŠ¢ instr instr â€² * : [ğ‘¡*1 ] â†’ğ‘¥*1 ğ‘¥*2 [ğ‘¡*2 ğ‘¡*3 ]
Subsumption for instr *
â€¢ The instruction sequence instr * must be valid with some type instrtype.
â€¢ The instruction type instrtype â€² : must be a valid
â€¢ The instruction type instrtype must match the type instrtype â€² .
â€¢ Then the instruction sequence instr * is also valid with type instrtype â€² .
ğ¶ âŠ¢ instr * : instrtype

ğ¶ âŠ¢ instrtype â€² ok
ğ¶ âŠ¢ instrtype â‰¤ instrtype â€²
ğ¶ âŠ¢ instr * : instrtype â€²

Ã² Note
In combination with the previous rule, subsumption allows to compose instructions whose types would not
directly fit otherwise. For example, consider the instruction sequence
(i32.const 1) (i32.const 1) i32.add
To type this sequence, its subsequence (i32.const 1) i32.add needs to be valid with an intermediate type. But
the direct type of (i32.const 1) is [] â†’ [i32], not matching the two inputs expected by i32.add. The subsumption
rule allows to weaken the type of (i32.const 1) to the supertype [i32] â†’ [i32 i32], such that it can be composed
with i32.add and yields the intermediate type [i32] â†’ [i32] for the subsequence. That can in turn be composed
with the first constant.
Furthermore, subsumption allows to drop init variables ğ‘¥* from the instruction type in a context where they
are not needed, for example, at the end of the body of a block.

3.4.13 Expressions
Expressions expr are classified by result types of the form [ğ‘¡* ].
instr * end
â€¢ The instruction sequence instr * must be valid with type [] â†’ [ğ‘¡* ].
â€¢ Then the expression is valid with result type [ğ‘¡* ].
ğ¶ âŠ¢ instr * : [] â†’ [ğ‘¡* ]
ğ¶ âŠ¢ instr * end : [ğ‘¡* ]

68

Chapter 3. Validation

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

Constant Expressions
â€¢ In a constant expression instr * end all instructions in instr * must be constant.
â€¢ A constant instruction instr must be:
â€“ either of the form ğ‘¡.const ğ‘,
â€“ or of the form inn.ibinop, where ibinop is limited to add, sub, or mul.
â€“ or of the form ref.null,
â€“ or of the form ref.i31,
â€“ or of the form ref.func ğ‘¥,
â€“ or of the form struct.new ğ‘¥,
â€“ or of the form struct.new_default ğ‘¥,
â€“ or of the form array.new ğ‘¥,
â€“ or of the form array.new_default ğ‘¥,
â€“ or of the form array.new_fixed ğ‘¥,
â€“ or of the form any.convert_extern,
â€“ or of the form extern.convert_any,
â€“ or of the form global.get ğ‘¥, in which case ğ¶.globals[ğ‘¥] must be a global type of the form const ğ‘¡.
(ğ¶ âŠ¢ instr const)*
ğ¶ âŠ¢ instr * end const
ğ¶ âŠ¢ ğ‘¡.const ğ‘ const ibinop âˆˆ {add, sub, mul}
ğ¶ âŠ¢ inn.ibinop const
ğ¶ âŠ¢ ref.null ğ‘¡ const

ğ¶ âŠ¢ ref.i31 const

ğ¶ âŠ¢ struct.new ğ‘¥ const
ğ¶ âŠ¢ array.new ğ‘¥ const

ğ¶ âŠ¢ struct.new_default ğ‘¥ const

ğ¶ âŠ¢ array.new_default ğ‘¥ const

ğ¶ âŠ¢ any.convert_extern const

ğ¶ âŠ¢ ref.func ğ‘¥ const

ğ¶ âŠ¢ array.new_fixed ğ‘¥ const

ğ¶ âŠ¢ extern.convert_any const

ğ¶.globals[ğ‘¥] = const ğ‘¡
ğ¶ âŠ¢ global.get ğ‘¥ const
Ã² Note
Currently, constant expressions occurring in globals are further constrained in that contained global.get instructions are only allowed to refer to imported or previously defined globals. Constant expressions occurring
in tables may only have global.get instructions that refer to imported globals. This is enforced in the validation
rule for modules by constraining the context ğ¶ accordingly.
The definition of constant expression may be extended in future versions of WebAssembly.

3.5 Modules
Modules are valid when all the components they contain are valid. Furthermore, most definitions are themselves
classified with a suitable type.

3.5. Modules

69

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

3.5.1 Types
The sequence of types defined in a module is validated incrementally, yielding a suitable context.
type *
â€¢ If the sequence is empty, then:
â€“ The context ğ¶ must be empty.
â€“ Then the type sequence is valid.
â€¢ Otherwise:
â€“ Let the recursive type rectype be the last element in the sequence.
â€“ The sequence without rectype must be valid for some context ğ¶ â€² .
â€“ Let the type index ğ‘¥ be the length of ğ¶ â€² .types, i.e., the first type index free in ğ¶ â€² .
â€“ Let the sequence of defined types deftype * be the result roll* ğ‘¥ (rectype) of rolling up into its sequence
of defined types.
â€“ The recursive type rectype must be valid under the context ğ¶ for type index ğ‘¥.
â€“ The current context ğ¶ be the same as ğ¶ â€² , but with deftype * appended to types.
â€“ Then the type sequence is valid.
{} âŠ¢ ğœ– ok
ğ¶ âŠ¢ type ok
â€²

*

ğ¶ = ğ¶ with types = ğ¶ .types roll* |ğ¶ â€² .types| (rectype)
ğ¶ âŠ¢ type * rectype ok
â€²

â€²

ğ¶ âŠ¢ rectype ok(|ğ¶ â€² .types|)

Ã² Note
Despite the appearance, the context ğ¶ is effectively an _output_ of this judgement.

3.5.2 Functions
Functions func are classified by defined types that expand to function types of the form func [ğ‘¡*1 ] â†’ [ğ‘¡*2 ].
{type ğ‘¥, locals ğ‘¡* , body expr }
â€¢ The defined type ğ¶.types[ğ‘¥] must be a function type.
â€¢ Let func [ğ‘¡*1 ] â†’ [ğ‘¡*2 ] be the expansion of the defined type ğ¶.types[ğ‘¥].
â€¢ For each local declared by a value type ğ‘¡ in ğ‘¡* :
â€“ The local for type ğ‘¡ must be valid with local type localtype ğ‘– .
â€¢ Let localtype * be the concatenation of all localtype ğ‘– .
â€¢ Let ğ¶ â€² be the same context as ğ¶, but with:
â€“ locals set to the sequence of value types (set ğ‘¡1 )* localtype * , concatenating parameters and locals,
â€“ labels set to the singular sequence containing only result type [ğ‘¡*2 ].
â€“ return set to the result type [ğ‘¡*2 ].
â€¢ Under the context ğ¶ â€² , the expression expr must be valid with type [ğ‘¡*2 ].
â€¢ Then the function definition is valid with type ğ¶.types[ğ‘¥].
expand(ğ¶.types[ğ‘¥]) = func [ğ‘¡*1 ] â†’ [ğ‘¡*2 ]

70

(ğ¶ âŠ¢ {type ğ‘¡} : init ğ‘¡)*
ğ¶, locals (set ğ‘¡1 )* (init ğ‘¡)* , labels [ğ‘¡*2 ], return [ğ‘¡*2 ] âŠ¢ expr
*
ğ¶ âŠ¢ {type ğ‘¥, locals {type ğ‘¡} , body expr } : ğ¶.types[ğ‘¥]

Chapter 3. Validation

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

3.5.3 Locals
Locals are classified with local types.
{type valtype}
â€¢ The value type valtype must be valid.
â€¢ If valtype is defaultable, then:
â€“ The local is valid with local type set valtype.
â€¢ Else:
â€“ The local is valid with local type unset valtype.
ğ¶ âŠ¢ ğ‘¡ ok
ğ¶ âŠ¢ ğ‘¡ defaultable
ğ¶ âŠ¢ {type ğ‘¡} : set ğ‘¡
ğ¶ âŠ¢ ğ‘¡ ok
ğ¶ âŠ¢ {type ğ‘¡} : unset ğ‘¡
Ã² Note
For cases where both rules are applicable, the former yields the more permissable type.

3.5.4 Tables
Tables table are classified by table types.
{type tabletype, init expr }
â€¢ The table type tabletype must be valid.
â€¢ Let ğ‘¡ be the element reference type of tabletype.
â€¢ The expression expr must be valid with result type [ğ‘¡].
â€¢ The expression expr must be constant.
â€¢ Then the table definition is valid with type tabletype.
ğ¶ âŠ¢ tabletype ok

tabletype = limits ğ‘¡
ğ¶ âŠ¢ expr : [ğ‘¡]
ğ¶ âŠ¢ {type tabletype, init expr } : tabletype

ğ¶ âŠ¢ expr const

3.5.5 Memories
Memories mem are classified by memory types.
{type memtype}
â€¢ The memory type memtype must be valid.
â€¢ Then the memory definition is valid with type memtype.
ğ¶ âŠ¢ memtype ok
ğ¶ âŠ¢ {type memtype} : memtype

3.5.6 Globals
Globals global are classified by global types of the form mut ğ‘¡.
Sequences of globals are handled incrementally, such that each definition has access to previous definitions.
3.5. Modules

71

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

{type mut ğ‘¡, init expr }
â€¢ The global type mut ğ‘¡ must be valid.
â€¢ The expression expr must be valid with result type [ğ‘¡].
â€¢ The expression expr must be constant.
â€¢ Then the global definition is valid with type mut ğ‘¡.
ğ¶ âŠ¢ mut ğ‘¡ ok
ğ¶ âŠ¢ expr : [ğ‘¡]
ğ¶ âŠ¢ expr const
ğ¶ âŠ¢ {type mut ğ‘¡, init expr } : mut ğ‘¡
global *
â€¢ If the sequence is empty, then it is valid with the empty sequence of global types.
â€¢ Else:
â€“ The first global definition must be valid with some type global type gt 1 .
â€“ Let ğ¶ â€² be the same context as ğ¶, but with the global type gt 1 apppended to the globals vector.
â€“ Under context ğ¶ â€² , the remainder of the sequence must be valid with some sequence gt * of global types.
â€“ Then the sequence is valid with the sequence of global types consisting of gt 1 prepended to gt * .

ğ¶âŠ¢ğœ–:ğœ–

ğ¶ âŠ¢ global 1 : gt 1
ğ¶ âŠ• {globals gt 1 } âŠ¢ global * : gt *
ğ¶ âŠ¢ global 1 global * : gt 1 gt *

3.5.7 Tags
Tags tag are classified by their tag type, each containing an index to a function type with empty result.
{type ğ‘¥}
â€¢ The type ğ¶.types[ğ‘¥] must be defined in the context.
*

â€¢ Let [ğ‘¡* ] â†’ [ğ‘¡â€² ] be the function type ğ¶.types[ğ‘¥].
*

â€¢ The sequence ğ‘¡â€² must be empty.
â€¢ Then the tag definition is valid with tag type [ğ‘¡* ] â†’ [].
ğ¶.types[ğ‘¥] = [ğ‘¡* ] â†’ []
ğ¶ âŠ¢ {type ğ‘¥} : [ğ‘¡* ] â†’ []
Ã² Note
Future versions of WebAssembly might allow non-empty return types for tags.

3.5.8 Element Segments
Element segments elem are classified by the reference type of their elements.
{type ğ‘¡, init ğ‘’* , mode elemmode}
â€¢ The reference type ğ‘¡ must be valid.
â€¢ For each ğ‘’ğ‘– in ğ‘’* :
â€“ The expression ğ‘’ğ‘– must be valid with some result type [ğ‘¡].
â€“ The expression ğ‘’ğ‘– must be constant.

72

Chapter 3. Validation

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

â€¢ The element mode elemmode must be valid with some reference type ğ‘¡â€² .
â€¢ The reference type ğ‘¡ must match the reference type ğ‘¡â€² .
â€¢ Then the element segment is valid with reference type ğ‘¡.
ğ¶ âŠ¢ ğ‘¡ ok

(ğ¶ âŠ¢ ğ‘’ : [ğ‘¡])*
(ğ¶ âŠ¢ ğ‘’ const)*
ğ¶ âŠ¢ elemmode : ğ‘¡â€²
ğ¶ âŠ¢ {type ğ‘¡, init ğ‘’* , mode elemmode} : ğ‘¡

ğ¶ âŠ¢ ğ‘¡ â‰¤ ğ‘¡â€²

passive
â€¢ The element mode is valid with any valid reference type.
ğ¶ âŠ¢ reftype ok
ğ¶ âŠ¢ passive : reftype
active {table ğ‘¥, offset expr }
â€¢ The table ğ¶.tables[ğ‘¥] must be defined in the context.
â€¢ Let at limits ğ‘¡ be the table type ğ¶.tables[ğ‘¥].
â€¢ The expression expr must be valid with result type [at].
â€¢ The expression expr must be constant.
â€¢ Then the element mode is valid with reference type ğ‘¡.
ğ¶.tables[ğ‘¥] = at limits ğ‘¡
ğ¶ âŠ¢ expr : [at]
ğ¶ âŠ¢ expr const
ğ¶ âŠ¢ active {table ğ‘¥, offset expr } : ğ‘¡
declarative
â€¢ The element mode is valid with any valid reference type.
ğ¶ âŠ¢ reftype ok
ğ¶ âŠ¢ declarative : reftype

3.5.9 Data Segments
Data segments data are not classified by any type but merely checked for well-formedness.
{init ğ‘* , mode datamode}
â€¢ The data mode datamode must be valid.
â€¢ Then the data segment is valid.
ğ¶ âŠ¢ datamode ok
ğ¶ âŠ¢ {init ğ‘* , mode datamode} ok
passive
â€¢ The data mode is valid.
ğ¶ âŠ¢ passive ok

3.5. Modules

73

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

active {memory ğ‘¥, offset expr }
â€¢ The memory ğ¶.mems[ğ‘¥] must be defined in the context.
â€¢ Let at limits be the memory type ğ¶.mems[ğ‘¥].
â€¢ The expression expr must be valid with result type [at].
â€¢ The expression expr must be constant.
â€¢ Then the data mode is valid.
ğ¶.mems[ğ‘¥] = at limits
ğ¶ âŠ¢ expr : [at]
ğ¶ âŠ¢ expr const
ğ¶ âŠ¢ active {memory ğ‘¥, offset expr } ok

3.5.10 Start Function
Start function declarations start are not classified by any type.
{func ğ‘¥}
â€¢ The function ğ¶.funcs[ğ‘¥] must be defined in the context.
â€¢ The expansion of ğ¶.funcs[ğ‘¥] must be a function type func [] â†’ [].
â€¢ Then the start function is valid.
expand(ğ¶.funcs[ğ‘¥]) = func [] â†’ []
ğ¶ âŠ¢ {func ğ‘¥} ok

3.5.11 Exports
Exports export and export descriptions exportdesc are classified by their external type.
{name name, desc exportdesc}
â€¢ The export description exportdesc must be valid with external type externtype.
â€¢ Then the export is valid with external type externtype.
ğ¶ âŠ¢ exportdesc : externtype
ğ¶ âŠ¢ {name name, desc exportdesc} : externtype
func ğ‘¥
â€¢ The function ğ¶.funcs[ğ‘¥] must be defined in the context.
â€¢ Let dt be the defined type ğ¶.funcs[ğ‘¥].
â€¢ Then the export description is valid with external type func dt.
ğ¶.funcs[ğ‘¥] = dt
ğ¶ âŠ¢ func ğ‘¥ : func dt
table ğ‘¥
â€¢ The table ğ¶.tables[ğ‘¥] must be defined in the context.
â€¢ Then the export description is valid with external type table ğ¶.tables[ğ‘¥].
ğ¶.tables[ğ‘¥] = tabletype
ğ¶ âŠ¢ table ğ‘¥ : table tabletype

74

Chapter 3. Validation

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

mem ğ‘¥
â€¢ The memory ğ¶.mems[ğ‘¥] must be defined in the context.
â€¢ Then the export description is valid with external type mem ğ¶.mems[ğ‘¥].
ğ¶.mems[ğ‘¥] = memtype
ğ¶ âŠ¢ mem ğ‘¥ : mem memtype
global ğ‘¥
â€¢ The global ğ¶.globals[ğ‘¥] must be defined in the context.
â€¢ Then the export description is valid with external type global ğ¶.globals[ğ‘¥].
ğ¶.globals[ğ‘¥] = globaltype
ğ¶ âŠ¢ global ğ‘¥ : global globaltype
tag ğ‘¥
â€¢ The tag ğ¶.tags[ğ‘¥] must be defined in the context.
â€¢ Then the export description is valid with external type tag ğ¶.tags[ğ‘¥].
ğ¶.tags[ğ‘¥] = tagtype
ğ¶ âŠ¢ tag ğ‘¥ : tag tagtype

3.5.12 Imports
Imports import and import descriptions importdesc are classified by external types.
{module name 1 , name name 2 , desc importdesc}
â€¢ The import description importdesc must be valid with type externtype.
â€¢ Then the import is valid with type externtype.
ğ¶ âŠ¢ importdesc : externtype
ğ¶ âŠ¢ {module name 1 , name name 2 , desc importdesc} : externtype
func ğ‘¥
â€¢ The defined type ğ¶.types[ğ‘¥] must be a function type.
â€¢ Then the import description is valid with type func ğ¶.types[ğ‘¥].
expand(ğ¶.types[ğ‘¥]) = func functype
ğ¶ âŠ¢ func ğ‘¥ : func ğ¶.types[ğ‘¥]
table tabletype
â€¢ The table type tabletype must be valid.
â€¢ Then the import description is valid with type table tabletype.
ğ¶ âŠ¢ tabletype ok
ğ¶ âŠ¢ table tabletype : table tabletype
mem memtype
â€¢ The memory type memtype must be valid.
â€¢ Then the import description is valid with type mem memtype.
ğ¶ âŠ¢ memtype ok
ğ¶ âŠ¢ mem memtype : mem memtype

3.5. Modules

75

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

global globaltype
â€¢ The global type globaltype must be valid.
â€¢ Then the import description is valid with type global globaltype.
ğ¶ âŠ¢ globaltype ok
ğ¶ âŠ¢ global globaltype : global globaltype
tag tag
â€¢ Let {type ğ‘¥} be the tag tag.
â€¢ The type ğ¶.types[ğ‘¥] must be defined in the context.
â€¢ The tag type ğ¶.types[ğ‘¥] must be a valid tag type.
â€¢ Then the import description is valid with type tag ğ¶.types[ğ‘¥].
âŠ¢ ğ¶.types[ğ‘¥] ok
ğ¶ âŠ¢ tag {type ğ‘¥} : tag ğ¶.types[ğ‘¥]

3.5.13 Modules
Modules are classified by their mapping from the external types of their imports to those of their exports.
A module is entirely closed, that is, its components can only refer to definitions that appear in the module itself.
Consequently, no initial context is required. Instead, the context ğ¶ for validation of the moduleâ€™s content is constructed from the definitions in the module.
â€¢ Let module be the module to validate.
â€¢ The types module.types must be valid yielding a context ğ¶0 .
â€¢ Let ğ¶ be a context where:
â€“ ğ¶.types is ğ¶0 .types,
â€“ ğ¶.funcs is funcs(it * ) concatenated with dt * , with the importâ€™s external types it * and the internal defined types dt * as determined below,
â€“ ğ¶.tables is tables(it * ) concatenated with tt * , with the importâ€™s external types it * and the internal table
types tt * as determined below,
â€“ ğ¶.mems is mems(it * ) concatenated with mt * , with the importâ€™s external types it * and the internal
memory types mt * as determined below,
â€“ ğ¶.globals is globals(it * ) concatenated with gt * , with the importâ€™s external types it * and the internal
global types gt * as determined below,
â€“ ğ¶.tags is tags(it * ) concatenated with ht * , with the importâ€™s external types it * and the internal tag
types ht * as determined below,
â€“ ğ¶.elems is rt * as determined below,
â€“ ğ¶.datas is okğ‘› , where ğ‘› is the length of the vector module.datas,
â€“ ğ¶.locals is empty,
â€“ ğ¶.labels is empty,
â€“ ğ¶.return is empty.
â€“ ğ¶.refs is the set funcidx(module with funcs = ğœ– with start = ğœ–), i.e., the set of function indices
occurring in the module, except in its functions or start function.
â€¢ Let ğ¶ â€² be the context where:
â€“ ğ¶ â€² .globals is the sequence globals(it * ),

76

Chapter 3. Validation

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

â€“ ğ¶ â€² .types is the same as ğ¶.types,
â€“ ğ¶ â€² .funcs is the same as ğ¶.funcs,
â€“ ğ¶ â€² .tables is the same as ğ¶.tables,
â€“ ğ¶ â€² .mems is the same as ğ¶.mems,
â€“ ğ¶ â€² .refs is the same as ğ¶.refs,
â€“ all other fields are empty.
â€¢ Under the context ğ¶ â€² :
â€“ The sequence module.globals of globals must be valid with a sequence gt * of global types.
â€“ For each table ğ‘– in module.tables, the definition table ğ‘– must be valid with a table type tt ğ‘– .
â€“ For each mem ğ‘– in module.mems, the definition mem ğ‘– must be valid with a memory type mt ğ‘– .
â€¢ Under the context ğ¶:
â€“ For each func ğ‘– in module.funcs, the definition func ğ‘– must be valid with a defined type dt ğ‘– .
â€“ For each tag ğ‘– in module.tags, the definition tag ğ‘– must be valid with a tag type ht ğ‘– .
â€“ For each elem ğ‘– in module.elems, the segment elem ğ‘– must be valid with reference type rt ğ‘– .
â€“ For each data ğ‘– in module.datas, the segment data ğ‘– must be valid.
â€“ If module.start is non-empty, then module.start must be valid.
â€“ For each import ğ‘– in module.imports, the segment import ğ‘– must be valid with an external type it ğ‘– .
â€“ For each export ğ‘– in module.exports, the segment export ğ‘– must be valid with external type et ğ‘– .
â€¢ Let dt * be the concatenation of the internal function types dt ğ‘– , in index order.
â€¢ Let tt * be the concatenation of the internal table types tt ğ‘– , in index order.
â€¢ Let mt * be the concatenation of the internal memory types mt ğ‘– , in index order.
â€¢ Let gt * be the concatenation of the internal global types gt ğ‘– , in index order.
â€¢ Let ht * be the concatenation of the internal tag types ht ğ‘– , in index order.
â€¢ Let rt * be the concatenation of the reference types rt ğ‘– , in index order.
â€¢ Let it * be the concatenation of external types it ğ‘– of the imports, in index order.
â€¢ Let et * be the concatenation of external types et ğ‘– of the exports, in index order.
â€¢ All export names export ğ‘– .name must be different.
â€¢ Then the module is valid with external types closğ¶ (it * â†’ et * ).
ğ¶0 âŠ¢ type * ok

ğ¶ â€² âŠ¢ global * : gt * (ğ¶ â€² âŠ¢ table : tt)* (ğ¶ â€² âŠ¢ mem : mt)* (ğ¶ âŠ¢ func : dt)* (ğ¶ âŠ¢ tag : ht)*
(ğ¶ âŠ¢ elem : rt)* (ğ¶ âŠ¢ data ok)ğ‘› (ğ¶ âŠ¢ start ok)? (ğ¶ âŠ¢ import : it)*
idt * = funcs(it * )
itt * = tables(it * )
imt * = mems(it * )
*
*
*
igt = globals(it )
iht = tags(it * )
ğ‘¥* = funcidx(module with funcs = ğœ– with start = ğœ–)
ğ¶ = {types ğ¶0 .types, funcs idt * dt * , tables itt * tt * , mems imt * mt * , globals igt * gt * , tags iht * ht * , elems rt * , datas okğ‘› , refs ğ‘¥*
ğ¶ â€² = {types ğ¶0 .types, globals igt * , funcs (ğ¶.funcs), tables (ğ¶.tables), mems (ğ¶.mems), refs (ğ¶.refs)}
(export.name)* disjoi
module = {types type * , funcs func * , tables table * , mems mem * , globals global * , tags tag * ,
elems elem * , datas data ğ‘› , start start ? , imports import * , exports export * }
âŠ¢ module : closğ¶ (it * â†’ et * )

3.5. Modules

77

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

Ã² Note
All functions in a module are mutually recursive. Consequently, the definition of the context ğ¶ in this rule
is recursive: it depends on the outcome of validation of the function, table, memory, and global definitions
contained in the module, which itself depends on ğ¶. However, this recursion is just a specification device. All
types needed to construct ğ¶ can easily be determined from a simple pre-pass over the module that does not
perform any actual validation.
Globals, however, are not recursive but evaluated sequentially, such that each constant expressions only has
access to imported or previously defined globals.

78

Chapter 3. Validation

CHAPTER

4

Execution

4.1 Conventions
WebAssembly code is executed when instantiating a module or invoking an exported function on the resulting
module instance.
Execution behavior is defined in terms of an abstract machine that models the program state. It includes a stack,
which records operand values and control constructs, and an abstract store containing global state.
For each instruction, there is a rule that specifies the effect of its execution on the program state. Furthermore,
there are rules describing the instantiation of a module. As with validation, all rules are given in two equivalent
forms:
1. In prose, describing the execution in intuitive form.
2. In formal notation, describing the rule in mathematical form.18
Ã² Note
As with validation, the prose and formal rules are equivalent, so that understanding of the formal notation is
not required to read this specification. The formalism offers a more concise description in notation that is used
widely in programming languages semantics and is readily amenable to mathematical proof.

4.1.1 Prose Notation
Execution is specified by stylised, step-wise rules for each instruction of the abstract syntax. The following conventions are adopted in stating these rules.
â€¢ The execution rules implicitly assume a given store ğ‘†.
â€¢ The execution rules also assume the presence of an implicit stack that is modified by pushing or popping
values, labels, and frames.
â€¢ Certain rules require the stack to contain at least one frame. The most recent frame is referred to as the
current frame.
18 The semantics is derived from the following article: Andreas Haas, Andreas Rossberg, Derek Schuff, Ben Titzer, Dan Gohman, Luke
Wagner, Alon Zakai, JF Bastien, Michael Holman. Bringing the Web up to Speed with WebAssembly19 . Proceedings of the 38th ACM
SIGPLAN Conference on Programming Language Design and Implementation (PLDI 2017). ACM 2017.
19 https://dl.acm.org/citation.cfm?doid=3062341.3062363

79

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

â€¢ Both the store and the current frame are mutated by replacing some of their components. Such replacement
is assumed to apply globally.
â€¢ The execution of an instruction may trap, in which case the entire computation is aborted and no further
modifications to the store are performed by it. (Other computations can still be initiated afterwards.)
â€¢ The execution of an instruction may also end in a jump to a designated target, which defines the next instruction to execute.
â€¢ Execution can enter and exit instruction sequences that form blocks.
â€¢ Instruction sequences are implicitly executed in order, unless a trap or jump occurs, or an exception is thrown.
â€¢ In various places the rules contain assertions expressing crucial invariants about the program state.

4.1.2 Formal Notation
Ã² Note
This section gives a brief explanation of the notation for specifying execution formally. For the interested
reader, a more thorough introduction can be found in respective text books.20
The formal execution rules use a standard approach for specifying operational semantics, rendering them into
reduction rules. Every rule has the following general form:
configuration

Ë“â†’

configuration

A configuration is a syntactic description of a program state. Each rule specifies one step of execution. As long
as there is at most one reduction rule applicable to a given configuration, reduction â€“ and thereby execution â€“ is
deterministic. WebAssembly has only very few exceptions to this, which are noted explicitly in this specification.
For WebAssembly, a configuration typically is a tuple (ğ‘†; ğ¹ ; instr * ) consisting of the current store ğ‘†, the call
frame ğ¹ of the current function, and the sequence of instructions that is to be executed. (A more precise definition
is given later.)
To avoid unnecessary clutter, the store ğ‘† and the frame ğ¹ are omitted from reduction rules that do not touch them.
There is no separate representation of the stack. Instead, it is conveniently represented as part of the configurationâ€™s
instruction sequence. In particular, values are defined to coincide with const instructions, and a sequence of const
instructions can be interpreted as an operand â€œstackâ€ that grows to the right.
Ã² Note
For example, the reduction rule for the i32.add instruction can be given as follows:
(i32.const ğ‘›1 ) (i32.const ğ‘›2 ) i32.add

(i32.const (ğ‘›1 + ğ‘›2 ) mod 232 )

Ë“â†’

Per this rule, two const instructions and the add instruction itself are removed from the instruction stream
and replaced with one new const instruction. This can be interpreted as popping two values off the stack and
pushing the result.
When no result is produced, an instruction reduces to the empty sequence:
nop

Ë“â†’

ğœ–

Labels and frames are similarly defined to be part of an instruction sequence.
The order of reduction is determined by the definition of an appropriate evaluation context.
20 For example: Benjamin Pierce. Types and Programming Languages21 . The MIT Press 2002
21 https://www.cis.upenn.edu/~bcpierce/tapl/

80

Chapter 4. Execution

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

Reduction terminates when no more reduction rules are applicable. Soundness of the WebAssembly type system
guarantees that this is only the case when the original instruction sequence has either been reduced to a sequence of
const instructions, which can be interpreted as the values of the resulting operand stack, or if a trap or an uncaught
exception occurred.
Ã² Note
For example, the following instruction sequence,
(f64.const ğ‘¥1 ) (f64.const ğ‘¥2 ) f64.neg (f64.const ğ‘¥3 ) f64.add f64.mul
terminates after three steps:
(f64.const ğ‘¥1 ) (f64.const ğ‘¥2 ) f64.neg (f64.const ğ‘¥3 ) f64.add f64.mul
Ë“â†’ (f64.const ğ‘¥1 ) (f64.const ğ‘¥4 ) (f64.const ğ‘¥3 ) f64.add f64.mul
Ë“â†’ (f64.const ğ‘¥1 ) (f64.const ğ‘¥5 ) f64.mul
Ë“â†’ (f64.const ğ‘¥6 )
where ğ‘¥4 = âˆ’ğ‘¥2 and ğ‘¥5 = âˆ’ğ‘¥2 + ğ‘¥3 and ğ‘¥6 = ğ‘¥1 Â· (âˆ’ğ‘¥2 + ğ‘¥3 ).

4.2 Runtime Structure
Store, stack, and other runtime structure forming the WebAssembly abstract machine, such as values or module
instances, are made precise in terms of additional auxiliary syntax.

4.2.1 Values
WebAssembly computations manipulate values of either the four basic number types, i.e., integers and floatingpoint data of 32 or 64 bit width each, or vectors of 128 bit width, or of reference type.
In most places of the semantics, values of different types can occur. In order to avoid ambiguities, values are
therefore represented with an abstract syntax that makes their type explicit. It is convenient to reuse the same
notation as for the const instructions and ref.null producing them.
References other than null are represented with additional administrative instructions. They either are scalar references, containing a 31-bit integer, structure references, pointing to a specific structure address, array references,
pointing to a specific array address, function references, pointing to a specific function address, exception references, pointing to a specific exception address, or host references pointing to an uninterpreted form of host address
defined by the embedder. Any of the aformentioned references can furthermore be wrapped up as an external
reference.
num

vec
ref

val

4.2. Runtime Structure

::=
|
|
|
::=
::=
|
|
|
|
|
|
|
::=

i32.const i32
i64.const i64
f32.const f32
f64.const f64
v128.const i128
ref.null (absheaptype | deftype)
ref.i31 u31
ref.struct structaddr
ref.array arrayaddr
ref.func funcaddr
ref.exn exnaddr
ref.host hostaddr
ref.extern ref
num | vec | ref

81

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

Ã² Note
Future versions of WebAssembly may add additional forms of reference.
Value types can have an associated default value; it is the respective value 0 for number types, 0 for vector types,
and null for nullable reference types. For other references, no default value is defined, defaultğ‘¡ hence is an optional
value val ? .
defaultğ‘¡
defaultğ‘¡
defaultğ‘¡
defaultğ‘¡

=
=
=
=

ğ‘¡.const 0
ğ‘¡.const 0
ref.null ğ‘¡
ğœ–

(if ğ‘¡ = numtype)
(if ğ‘¡ = vectype)
(if ğ‘¡ = (ref null heaptype))
(if ğ‘¡ = (ref heaptype))

Convention
â€¢ The meta variable ğ‘Ÿ ranges over reference values where clear from context.

4.2.2 Results
A result is the outcome of a computation. It is either a sequence of values, an uncaught exception, or a trap.
result

::= val *
|
ğ‘‡ [(ref.exn exnaddr ) throw_ref]
|
trap

4.2.3 Store
The store represents all global state that can be manipulated by WebAssembly programs. It consists of the runtime
representation of all instances of functions, tables, memories, globals, tags, element segments, data segments, and
structures, arrays or exceptions that have been allocated during the life time of the abstract machine.22
It is an invariant of the semantics that no element or data instance is addressed from anywhere else but the owning
module instances.
Syntactically, the store is defined as a record listing the existing instances of each category:
store

::= { funcs funcinst * ,
tables tableinst * ,
mems meminst * ,
globals globalinst * ,
tags taginst * ,
elems eleminst * ,
datas datainst * ,
structs structinst * ,
arrays arrayinst * ,
exns exninst * }

Convention
â€¢ The meta variable ğ‘† ranges over stores where clear from context.

4.2.4 Addresses
Function instances, table instances, memory instances, global instances, tag instances, element instances, data
instances and structure, array instances or exception instances in the store are referenced with abstract addresses.
22 In practice, implementations may apply techniques like garbage collection or reference counting to remove objects from the store that are
no longer referenced. However, such techniques are not semantically observable, and hence outside the scope of this specification.

82

Chapter 4. Execution

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

These are simply indices into the respective store component. In addition, an embedder may supply an uninterpreted
set of host addresses.
addr
funcaddr
tableaddr
memaddr
globaladdr
tagaddr
elemaddr
dataaddr
structaddr
arrayaddr
exnaddr
hostaddr

::=
::=
::=
::=
::=
::=
::=
::=
::=
::=
::=
::=

0 | 1 | 2 | ...
addr
addr
addr
addr
addr
addr
addr
addr
addr
addr
addr

An embedder may assign identity to exported store objects corresponding to their addresses, even where this identity is not observable from within WebAssembly code itself (such as for function instances or immutable globals).
Ã² Note
Addresses are dynamic, globally unique references to runtime objects, in contrast to indices, which are static,
module-local references to their original definitions. A memory address memaddr denotes the abstract address
of a memory instance in the store, not an offset inside a memory instance.
There is no specific limit on the number of allocations of store objects, hence logical addresses can be arbitrarily
large natural numbers.
Conventions
â€¢ The notation addr(ğ´) denotes the set of addresses from address space addr occurring free in ğ´. We sometimes reinterpret this set as the vector of its elements.

4.2.5 Module Instances
A module instance is the runtime representation of a module. It is created by instantiating a module, and collects
runtime representations of all entities that are imported, defined, or exported by the module.
moduleinst

::=

{ types
deftype * ,
funcaddrs funcaddr * ,
tableaddrs tableaddr * ,
memaddrs memaddr * ,
globaladdrs globaladdr * ,
tagaddrs tagaddr * ,
elemaddrs elemaddr * ,
dataaddrs dataaddr * ,
exports
exportinst * }

Each component references runtime instances corresponding to respective declarations from the original module
â€“ whether imported or defined â€“ in the order of their static indices. Function instances, table instances, memory
instances, global instances, and tag instances are referenced with an indirection through their respective addresses
in the store.
It is an invariant of the semantics that all export instances in a given module instance have different names.

4.2.6 Function Instances
A function instance is the runtime representation of a function. It effectively is a closure of the original function
over the runtime module instance of its originating module. The module instance is used to resolve references to

4.2. Runtime Structure

83

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

other definitions during execution of the function.
::= {type deftype, module moduleinst, code func}
|
{type deftype, hostcode hostfunc}
::= . . .

funcinst
hostfunc

A host function is a function expressed outside WebAssembly but passed to a module as an import. The definition
and behavior of host functions are outside the scope of this specification. For the purpose of this specification, it
is assumed that when invoked, a host function behaves non-deterministically, but within certain constraints that
ensure the integrity of the runtime.
Ã² Note
Function instances are immutable, and their identity is not observable by WebAssembly code. However, the
embedder might provide implicit or explicit means for distinguishing their addresses.

4.2.7 Table Instances
A table instance is the runtime representation of a table. It records its type and holds a sequence of reference
values.
tableinst

::= {type tabletype, elem ref * }

Table elements can be mutated through table instructions, the execution of an active element segment, or by external
means provided by the embedder.
It is an invariant of the semantics that all table elements have a type matching the element type of tabletype. It also
is an invariant that the length of the element sequence never exceeds the maximum size of tabletype, if present.

4.2.8 Memory Instances
A memory instance is the runtime representation of a linear memory. It records its type and holds a sequence of
bytes.
meminst

::= {type memtype, data byte * }

The length of the sequence always is a multiple of the WebAssembly page size, which is defined to be the constant
65536 â€“ abbreviated 64 Ki.
The bytes can be mutated through memory instructions, the execution of an active data segment, or by external
means provided by the embedder.
It is an invariant of the semantics that the length of the byte vector, divided by page size, never exceeds the maximum
size of memtype, if present.

4.2.9 Global Instances
A global instance is the runtime representation of a global variable. It records its type and holds an individual
value.
globalinst

::=

{type globaltype, value val }

The value of mutable globals can be mutated through variable instructions or by external means provided by the
embedder.
It is an invariant of the semantics that the value has a type matching the value type of globaltype.

4.2.10 Tag Instances
A tag instance is the runtime representation of a tag definition. It records the type of the tag.
taginst

84

::= {type tagtype}

Chapter 4. Execution

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

4.2.11 Element Instances
An element instance is the runtime representation of an element segment. It holds a vector of references and their
common type.
eleminst

::= {type reftype, elem vec(ref )}

4.2.12 Data Instances
An data instance is the runtime representation of a data segment. It holds a vector of bytes.
datainst

::= {data vec(byte)}

4.2.13 Export Instances
An export instance is the runtime representation of an export. It defines the exportâ€™s name and the associated
external value.
exportinst

::= {name name, value externval }

4.2.14 External Values
An external value is the runtime representation of an entity that can be imported or exported. It is an address
denoting either a function instance, table instance, memory instance, tag instances, or global instances in the shared
store.
externval

::=
|
|
|
|

func funcaddr
table tableaddr
mem memaddr
global globaladdr
tag tagaddr

Conventions
The following auxiliary notation is defined for sequences of external values. It filters out entries of a specific kind
in an order-preserving fashion:
â€¢ funcs(externval * ) = [funcaddr | (func funcaddr ) âˆˆ externval * ]
â€¢ tables(externval * ) = [tableaddr | (table tableaddr ) âˆˆ externval * ]
â€¢ mems(externval * ) = [memaddr | (mem memaddr ) âˆˆ externval * ]
â€¢ globals(externval * ) = [globaladdr | (global globaladdr ) âˆˆ externval * ]
â€¢ tags(externval * ) = [tagaddr | (tag tagaddr ) âˆˆ externval * ]

4.2.15 Aggregate Instances
A structure instance is the runtime representation of a heap object allocated from a structure type. Likewise,
an array instance is the runtime representation of a heap object allocated from an array type. Both record their
respective defined type and hold a vector of the values of their fields.
structinst
arrayinst
fieldval
packedval
4.2. Runtime Structure

::= {type deftype, fields vec(fieldval )}
::= {type deftype, fields vec(fieldval )}
::= val | packedval
::= i8.pack u8 | i16.pack u16
85

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

Conventions
â€¢ Conversion of a regular value to a field value is defined as follows:
packvaltype (val )
packpackedtype (i32.const ğ‘–)

= val
= packedtype.pack (wrap32,|packedtype| (ğ‘–))

â€¢ The inverse conversion of a field value to a regular value is defined as follows:
unpackvaltype (val )
unpacksx
packedtype (packedtype.pack ğ‘–)

= val
= i32.const (extendsx
|packedtype|,32 (ğ‘–))

4.2.16 Exception Instances
An exception instance is the runtime representation of an _exception_ produced by a throw instruction. It holds
the address of the respective tag and the argument values.
exninst

::= {tag tagaddr , fields vec(val )}

4.2.17 Stack
Besides the store, most instructions interact with an implicit stack. The stack contains the following kinds of entries:
â€¢ Values: the operands of instructions.
â€¢ Labels: active structured control instructions that can be targeted by branches.
â€¢ Activations: the call frames of active function calls.
â€¢ Handlers: active exception handlers.
These entries can occur on the stack in any order during the execution of a program. Stack entries are described
by abstract syntax as follows.
Ã² Note
It is possible to model the WebAssembly semantics using separate stacks for operands, control constructs, and
calls. However, because the stacks are interdependent, additional book keeping about associated stack heights
would be required. For the purpose of this specification, an interleaved representation is simpler.
Values
Values are represented by themselves.
Labels
Labels carry an argument arity ğ‘› and their associated branch target, which is expressed syntactically as an instruction sequence:
label

::= labelğ‘› {instr * }

Intuitively, instr * is the continuation to execute when the branch is taken, in place of the original control construct.
Ã² Note
For example, a loop label has the form
labelğ‘› {loop . . . end}

86

Chapter 4. Execution

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

When performing a branch to this label, this executes the loop, effectively restarting it from the beginning.
Conversely, a simple block label has the form
labelğ‘› {ğœ–}
When branching, the empty continuation ends the targeted block, such that execution can proceed with consecutive instructions.
Activation Frames
Activation frames carry the return arity ğ‘› of the respective function, hold the values of its locals (including arguments) in the order corresponding to their static local indices, and a reference to the functionâ€™s own module
instance:
frame
framestate

::= frameğ‘› {framestate}
::= {locals (val ? )* , module moduleinst}

Locals may be uninitialized, in which case they are empty. Locals are mutated by respective variable instructions.
Exception Handlers
Exception handlers are installed by try_table instructions and record the corresponding list of catch clauses:
handler

::= handlerğ‘› {catch * }

The handlers on the stack are searched when an exception is thrown.
Conventions
â€¢ The meta variable ğ¿ ranges over labels where clear from context.
â€¢ The meta variable ğ¹ ranges over frame states where clear from context.
â€¢ The meta variable ğ» ranges over exception handlers where clear from context.
â€¢ The following auxiliary definition takes a block type and looks up the instruction type that it denotes in the
current frame:
instrtypeğ‘†;ğ¹ (typeidx )
= functype
(if expand(ğ¹.module.types[typeidx ]) = func functype)
instrtypeğ‘†;ğ¹ ([valtype ? ]) = [] â†’ [valtype ? ]

4.2.18 Administrative Instructions
Ã² Note
This section is only relevant for the formal notation.

4.2. Runtime Structure

87

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

In order to express the reduction of traps, calls, exception handling, and control instructions, the syntax of instructions is extended to include the following administrative instructions:
instr

::=
|
|
|
|
|
|
|
|
|
|
|
|
|

...
trap
ref.i31 u31
ref.struct structaddr
ref.array arrayaddr
ref.func funcaddr
ref.exn exnaddr
ref.host hostaddr
ref.extern ref
invoke funcaddr
return_invoke funcaddr
labelğ‘› {instr * } instr * end
handlerğ‘› {catch * } instr * end
frameğ‘› {framestate} instr * end

The trap instruction represents the occurrence of a trap. Traps are bubbled up through nested instruction sequences,
ultimately reducing the entire program to a single trap instruction, signalling abrupt termination.
The ref.i31 instruction represents unboxed scalar reference values, ref.struct and ref.array represent structure and
array references, respectively, ref.func represents function references, and ref.exn represents exception references.
Similarly, ref.host represents host references and ref.extern represents any externalized reference.
The invoke instruction represents the imminent invocation of a function instance, identified by its address. It unifies
the handling of different forms of calls. Analogously, return_invoke represents the imminent tail invocation of a
function instance.
The label, frame, and handler instructions model labels, frames, and active exception handlers, respectively, â€œon
the stackâ€. Moreover, the administrative syntax maintains the nesting structure of the original structured control
instruction or function body and their instruction sequences with an end marker. That way, the end of the inner
instruction sequence is known when part of an outer sequence.
Ã² Note
For example, the reduction rule for block is:
block [ğ‘¡ğ‘› ] instr * end

Ë“â†’

labelğ‘› {ğœ–} instr * end

This replaces the block with a label instruction, which can be interpreted as â€œpushingâ€ the label on the stack.
When end is reached, i.e., the inner instruction sequence has been reduced to the empty sequence â€“ or rather,
a sequence of ğ‘› const instructions representing the resulting values â€“ then the label instruction is eliminated
courtesy of its own reduction rule:
labelğ‘š {instr * } val ğ‘› end

Ë“â†’

val ğ‘›

This can be interpreted as removing the label from the stack and only leaving the locally accumulated operand
values.

Block Contexts
In order to specify the reduction of branches, the following syntax of block contexts is defined, indexed by the count
ğ‘˜ of labels surrounding a hole [_] that marks the place where the next step of computation is taking place:
ğµğ‘˜
ğ¶0
ğ¶ ğ‘˜+1

::= val ğµ ğ‘˜ | ğµ ğ‘˜ instr | handlerğ‘› {catch * } ğµ ğ‘˜ end | ğ¶ ğ‘˜
::= [_]
::= labelğ‘› {instr * } ğµ ğ‘˜ end

This definition allows to index active labels surrounding a branch or return instruction.
88

Chapter 4. Execution

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

Ã² Note
For example, the reduction of a simple branch can be defined as follows:
label0 {instr * } ğµ ğ‘™ [br ğ‘™] end

Ë“â†’

instr *

Here, the hole [_] of the context is instantiated with a branch instruction. When a branch occurs, this rule
replaces the target label and associated instruction sequence with the labelâ€™s continuation. The selected label
is identified through the label index ğ‘™, which corresponds to the number of surrounding label instructions that
must be hopped over â€“ which is exactly the count encoded in the index of a block context.

Throw Contexts
In order to specify the reduction of try_table blocks, the following syntax of throw contexts is defined, as well as
associated structural rules:
ğ‘‡

::= [_]
|
val * ğ‘‡ instr *
|
labelğ‘› {instr * } ğ‘‡ end
|
frameğ‘› {ğ¹ } ğ‘‡ end

Throw contexts allow matching the program context around a throw instruction up to the innermost enclosing
exception handler, if one exists.
Ã² Note
Contrary to block contexts, throw contexts do not skip over handlers.

Configurations
A configuration consists of the current store and an executing thread.
A thread is a computation over instructions that operates relative to the state of a current frame referring to the
module instance in which the computation runs, i.e., where the current function originates from.
config
thread

::= store; thread
::= framestate; instr *

Ã² Note
The current version of WebAssembly is single-threaded, but configurations with multiple threads may be supported in the future.

Evaluation Contexts
Finally, the following definition of evaluation context and associated structural rules enable reduction inside instruction sequences and administrative forms as well as the propagation of traps:
ğ¸

::=

[_] | val * ğ¸ instr * | labelğ‘› {instr * } ğ¸ end | handlerğ‘› {catch * } ğ¸ end
*

ğ‘†; ğ¹ ; ğ¸[instr * ] Ë“â†’ ğ‘† â€² ; ğ¹ â€² ; ğ¸[instr â€² ]
*
(if ğ‘†; ğ¹ ; instr * Ë“â†’ ğ‘† â€² ; ğ¹ â€² ; instr â€² )
â€²
*
â€²
â€²â€²
â€²*
ğ‘†; ğ¹ ; frameğ‘› {ğ¹ } instr end Ë“â†’ ğ‘† ; ğ¹ ; frameğ‘› {ğ¹ } instr end
*
(if ğ‘†; ğ¹ â€² ; instr * Ë“â†’ ğ‘† â€² ; ğ¹ â€²â€² ; instr â€² )
ğ‘†; ğ¹ ; ğ¸[trap] Ë“â†’ ğ‘†; ğ¹ ; trap
ğ‘†; ğ¹ ; frameğ‘› {ğ¹ â€² } trap end Ë“â†’ ğ‘†; ğ¹ ; trap
4.2. Runtime Structure

(if ğ¸ Ì¸= [_])

89

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

Reduction terminates when a threadâ€™s instruction sequence has been reduced to a result, that is, either a sequence
of values, to an uncaught exception, or to a trap.
Ã² Note
The restriction on evaluation contexts rules out contexts like [_] and ğœ– [_] ğœ– for which ğ¸[trap] = trap.
For an example of reduction under evaluation contexts, consider the following instruction sequence.
(f64.const ğ‘¥1 ) (f64.const ğ‘¥2 ) f64.neg (f64.const ğ‘¥3 ) f64.add f64.mul
This can be decomposed into ğ¸[(f64.const ğ‘¥2 ) f64.neg] where
ğ¸ = (f64.const ğ‘¥1 ) [_] (f64.const ğ‘¥3 ) f64.add f64.mul
Moreover, this is the only possible choice of evaluation context where the contents of the hole matches the
left-hand side of a reduction rule.

4.3 Numerics
Numeric primitives are defined in a generic manner, by operators indexed over a bit width ğ‘ .
Some operators are non-deterministic, because they can return one of several possible results (such as different NaN
values). Technically, each operator thus returns a set of allowed values. For convenience, deterministic results are
expressed as plain values, which are assumed to be identified with a respective singleton set.
Some operators are partial, because they are not defined on certain inputs. Technically, an empty set of results is
returned for these inputs.
In formal notation, each operator is defined by equational clauses that apply in decreasing order of precedence.
That is, the first clause that is applicable to the given arguments defines the result. In some cases, similar clauses
are combined into one by using the notation Â± or âˆ“. When several of these placeholders occur in a single clause,
then they must be resolved consistently: either the upper sign is chosen for all of them or the lower sign.
Ã² Note
For example, the fcopysign operator is defined as follows:
fcopysignğ‘ (Â±ğ‘1 , Â±ğ‘2 ) = Â±ğ‘1
fcopysignğ‘ (Â±ğ‘1 , âˆ“ğ‘2 ) = âˆ“ğ‘1
This definition is to be read as a shorthand for the following expansion of each clause into two separate ones:
fcopysignğ‘ (+ğ‘1 , +ğ‘2 ) = +ğ‘1
fcopysignğ‘ (âˆ’ğ‘1 , âˆ’ğ‘2 ) = âˆ’ğ‘1
fcopysignğ‘ (+ğ‘1 , âˆ’ğ‘2 ) = âˆ’ğ‘1
fcopysignğ‘ (âˆ’ğ‘1 , +ğ‘2 ) = +ğ‘1
Numeric operators are lifted to input sequences by applying the operator element-wise, returning a sequence of
results. When there are multiple inputs, they must be of equal length.
ğ‘œğ‘(ğ‘ğ‘›1 , . . . , ğ‘ğ‘›ğ‘˜ )

=

ğ‘œğ‘(ğ‘ğ‘›1 [0], . . . , ğ‘ğ‘›ğ‘˜ [0]) . . . ğ‘œğ‘(ğ‘ğ‘›1 [ğ‘› âˆ’ 1], . . . , ğ‘ğ‘›ğ‘˜ [ğ‘› âˆ’ 1])

Ã² Note

90

Chapter 4. Execution

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

For example, the unary operator fabs, when given a sequence of floating-point values, return a sequence of
floating-point results:
fabsğ‘ (ğ‘§ ğ‘› )

=

fabsğ‘ (ğ‘§[0]) . . . fabsğ‘ (ğ‘§[ğ‘›])

The binary operator iadd, when given two sequences of integers of the same length, ğ‘›, return a sequence of
integer results:
iaddğ‘ (ğ‘–ğ‘›1 , ğ‘–ğ‘›2 )

=

iaddğ‘ (ğ‘–1 [0], ğ‘–2 [0]) . . . iaddğ‘ (ğ‘–1 [ğ‘›], ğ‘–2 [ğ‘›])

Conventions:
â€¢ The meta variable ğ‘‘ is used to range over single bits.
â€¢ The meta variable ğ‘ is used to range over (signless) magnitudes of floating-point values, including nan and
âˆ.
â€¢ The meta variable ğ‘ is used to range over (signless) rational magnitudes, excluding nan or âˆ.
â€¢ The notation ğ‘“ âˆ’1 denotes the inverse of a bijective function ğ‘“ .
â€¢ Truncation of rational values is written trunc(Â±ğ‘), with the usual mathematical definition:
trunc(Â±ğ‘)

=

Â±ğ‘–

(if ğ‘– âˆˆ N âˆ§ +ğ‘ âˆ’ 1 < ğ‘– â‰¤ +ğ‘)

â€¢ Saturation of integers is written sat_uğ‘ (ğ‘–) and sat_sğ‘ (ğ‘–). The arguments to these two functions range over
arbitrary signed integers.
â€“ Unsigned saturation, sat_uğ‘ (ğ‘–) clamps ğ‘– to between 0 and 2ğ‘ âˆ’ 1:
sat_uğ‘ (ğ‘–) = 0
sat_uğ‘ (ğ‘–) = 2ğ‘ âˆ’ 1
sat_uğ‘ (ğ‘–) = ğ‘–

(if ğ‘– < 0)
(if ğ‘– > 2ğ‘ âˆ’ 1)
(otherwise)

â€“ Signed saturation, sat_sğ‘ (ğ‘–) clamps ğ‘– to between âˆ’2ğ‘ âˆ’1 and 2ğ‘ âˆ’1 âˆ’ 1:
sat_sğ‘ (ğ‘–) = âˆ’2ğ‘ âˆ’1
sat_sğ‘ (ğ‘–) = 2ğ‘ âˆ’1 âˆ’ 1
sat_sğ‘ (ğ‘–) = ğ‘–

(if ğ‘– < âˆ’2ğ‘ âˆ’1 )
(if ğ‘– > 2ğ‘ âˆ’1 âˆ’ 1)
(otherwise)

4.3.1 Representations
Numbers and numeric vectors have an underlying binary representation as a sequence of bits:
bitsiğ‘ (ğ‘–) = ibitsğ‘ (ğ‘–)
bitsfğ‘ (ğ‘§) = fbitsğ‘ (ğ‘§)
bitsvğ‘ (ğ‘–) = ibitsğ‘ (ğ‘–)
The first case of these applies to representations of both integer value types and packed types.
Each of these functions is a bijection, hence they are invertible.
Integers
Integers are represented as base two unsigned numbers:
ibitsğ‘ (ğ‘–)

= ğ‘‘ğ‘ âˆ’1 . . . ğ‘‘0

(ğ‘– = 2ğ‘ âˆ’1 Â· ğ‘‘ğ‘ âˆ’1 + Â· Â· Â· + 20 Â· ğ‘‘0 )

Boolean operators like âˆ§, âˆ¨, or âŠ» are lifted to bit sequences of equal length by applying them pointwise.

4.3. Numerics

91

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

Floating-Point
Floating-point values are represented in the respective binary format defined by IEEE 75423 (Section 3.4):
fbitsğ‘ (Â±(1 + ğ‘š Â· 2âˆ’ğ‘€ ) Â· 2ğ‘’ ) = fsign(Â±) ibitsğ¸ (ğ‘’ + fbiasğ‘ ) ibitsğ‘€ (ğ‘š)
fbitsğ‘ (Â±(0 + ğ‘š Â· 2âˆ’ğ‘€ ) Â· 2ğ‘’ ) = fsign(Â±) (0)ğ¸ ibitsğ‘€ (ğ‘š)
fbitsğ‘ (Â±âˆ)
= fsign(Â±) (1)ğ¸ (0)ğ‘€
fbitsğ‘ (Â±nan(ğ‘›))
= fsign(Â±) (1)ğ¸ ibitsğ‘€ (ğ‘›)
= 2ğ¸âˆ’1 âˆ’ 1
= 0
= 1

fbiasğ‘
fsign(+)
fsign(âˆ’)
where ğ‘€ = signif(ğ‘ ) and ğ¸ = expon(ğ‘ ).
Vectors

Numeric vectors of type vğ‘ have the same underlying representation as an iğ‘ . They can also be interpreted as a
sequence of numeric values packed into a vğ‘ with a particular shape ğ‘¡xğ‘€ , provided that ğ‘ = |ğ‘¡| Â· ğ‘€ .
lanesğ‘¡xğ‘€ (ğ‘) = ğ‘0 . . . ğ‘ğ‘€ âˆ’1
(where ğ‘¤ = |ğ‘¡|/8
âˆ§ ğ‘* = bytesiğ‘ (ğ‘)
*
âˆ§ ğ‘ğ‘– = bytesâˆ’1
ğ‘¡ (ğ‘ [ğ‘– Â· ğ‘¤ : ğ‘¤]))
This function is a bijection on iğ‘ , hence it is invertible.
Storage
When a number is stored into memory, it is converted into a sequence of bytes in little endian24 byte order:
bytesğ‘¡ (ğ‘–)

=

littleendian(bitsğ‘¡ (ğ‘–))

littleendian(ğœ–)
*
littleendian(ğ‘‘8 ğ‘‘â€² )

= ğœ–
*
8
= littleendian(ğ‘‘â€² ) ibitsâˆ’1
8 (ğ‘‘ )

Again these functions are invertible bijections.

4.3.2 Integer Operations
Sign Interpretation
Integer operators are defined on i ğ‘ values. Operators that use a signed interpretation convert the value using the
following definition, which takes the twoâ€™s complement when the value lies in the upper half of the value range
(i.e., its most significant bit is 1):
signedğ‘ (ğ‘–)
signedğ‘ (ğ‘–)

= ğ‘–
= ğ‘– âˆ’ 2ğ‘

(0 â‰¤ ğ‘– < 2ğ‘ âˆ’1 )
(2ğ‘ âˆ’1 â‰¤ ğ‘– < 2ğ‘ )

This function is bijective, and hence invertible.
Boolean Interpretation
The integer result of predicates â€“ i.e., tests and relational operators â€“ is defined with the help of the following
auxiliary function producing the value 1 or 0 depending on a condition.
bool(ğ¶)
bool(ğ¶)

=
=

1
0

(if ğ¶)
(otherwise)

iaddğ‘ (ğ‘–1 , ğ‘–2 )
â€¢ Return the result of adding ğ‘–1 and ğ‘–2 modulo 2ğ‘ .
iaddğ‘ (ğ‘–1 , ğ‘–2 )

=

(ğ‘–1 + ğ‘–2 ) mod 2ğ‘

23 https://ieeexplore.ieee.org/document/8766229

24 https://en.wikipedia.org/wiki/Endianness#Little-endian

92

Chapter 4. Execution

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

isubğ‘ (ğ‘–1 , ğ‘–2 )
â€¢ Return the result of subtracting ğ‘–2 from ğ‘–1 modulo 2ğ‘ .
isubğ‘ (ğ‘–1 , ğ‘–2 )

=

(ğ‘–1 âˆ’ ğ‘–2 + 2ğ‘ ) mod 2ğ‘

imulğ‘ (ğ‘–1 , ğ‘–2 )
â€¢ Return the result of multiplying ğ‘–1 and ğ‘–2 modulo 2ğ‘ .
imulğ‘ (ğ‘–1 , ğ‘–2 )

=

(ğ‘–1 Â· ğ‘–2 ) mod 2ğ‘

idiv_uğ‘ (ğ‘–1 , ğ‘–2 )
â€¢ If ğ‘–2 is 0, then the result is undefined.
â€¢ Else, return the result of dividing ğ‘–1 by ğ‘–2 , truncated toward zero.
idiv_uğ‘ (ğ‘–1 , 0) =
idiv_uğ‘ (ğ‘–1 , ğ‘–2 ) =

{}
trunc(ğ‘–1 /ğ‘–2 )

Ã² Note
This operator is partial.
idiv_sğ‘ (ğ‘–1 , ğ‘–2 )
â€¢ Let ğ‘—1 be the signed interpretation of ğ‘–1 .
â€¢ Let ğ‘—2 be the signed interpretation of ğ‘–2 .
â€¢ If ğ‘—2 is 0, then the result is undefined.
â€¢ Else if ğ‘—1 divided by ğ‘—2 is 2ğ‘ âˆ’1 , then the result is undefined.
â€¢ Else, return the result of dividing ğ‘—1 by ğ‘—2 , truncated toward zero.
idiv_sğ‘ (ğ‘–1 , 0) = {}
idiv_sğ‘ (ğ‘–1 , ğ‘–2 ) = {}
(if signedğ‘ (ğ‘–1 )/signedğ‘ (ğ‘–2 ) = 2ğ‘ âˆ’1 )
âˆ’1
idiv_sğ‘ (ğ‘–1 , ğ‘–2 ) = signedğ‘ (trunc(signedğ‘ (ğ‘–1 )/signedğ‘ (ğ‘–2 )))
Ã² Note
This operator is partial. Besides division by 0, the result of (âˆ’2ğ‘ âˆ’1 )/(âˆ’1) = +2ğ‘ âˆ’1 is not representable as
an ğ‘ -bit signed integer.
irem_uğ‘ (ğ‘–1 , ğ‘–2 )
â€¢ If ğ‘–2 is 0, then the result is undefined.
â€¢ Else, return the remainder of dividing ğ‘–1 by ğ‘–2 .
irem_uğ‘ (ğ‘–1 , 0) = {}
irem_uğ‘ (ğ‘–1 , ğ‘–2 ) = ğ‘–1 âˆ’ ğ‘–2 Â· trunc(ğ‘–1 /ğ‘–2 )

Ã² Note
This operator is partial.
As long as both operators are defined, it holds that ğ‘–1 = ğ‘–2 Â· idiv_u(ğ‘–1 , ğ‘–2 ) + irem_u(ğ‘–1 , ğ‘–2 ).

4.3. Numerics

93

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

irem_sğ‘ (ğ‘–1 , ğ‘–2 )
â€¢ Let ğ‘—1 be the signed interpretation of ğ‘–1 .
â€¢ Let ğ‘—2 be the signed interpretation of ğ‘–2 .
â€¢ If ğ‘–2 is 0, then the result is undefined.
â€¢ Else, return the remainder of dividing ğ‘—1 by ğ‘—2 , with the sign of the dividend ğ‘—1 .
irem_sğ‘ (ğ‘–1 , 0) = {}
irem_sğ‘ (ğ‘–1 , ğ‘–2 ) = signedâˆ’1
ğ‘ (ğ‘—1 âˆ’ ğ‘—2 Â· trunc(ğ‘—1 /ğ‘—2 ))
(where ğ‘—1 = signedğ‘ (ğ‘–1 ) âˆ§ ğ‘—2 = signedğ‘ (ğ‘–2 ))
Ã² Note
This operator is partial.
As long as both operators are defined, it holds that ğ‘–1 = ğ‘–2 Â· idiv_s(ğ‘–1 , ğ‘–2 ) + irem_s(ğ‘–1 , ğ‘–2 ).
inotğ‘ (ğ‘–)
â€¢ Return the bitwise negation of ğ‘–.
inotğ‘ (ğ‘–)

=

ğ‘
ibitsâˆ’1
ğ‘ (ibitsğ‘ (ğ‘–) âŠ» ibitsğ‘ (2 âˆ’ 1))

iandğ‘ (ğ‘–1 , ğ‘–2 )
â€¢ Return the bitwise conjunction of ğ‘–1 and ğ‘–2 .
iandğ‘ (ğ‘–1 , ğ‘–2 )

ibitsâˆ’1
ğ‘ (ibitsğ‘ (ğ‘–1 ) âˆ§ ibitsğ‘ (ğ‘–2 ))

=

iandnotğ‘ (ğ‘–1 , ğ‘–2 )
â€¢ Return the bitwise conjunction of ğ‘–1 and the bitwise negation of ğ‘–2 .
iandnotğ‘ (ğ‘–1 , ğ‘–2 )

=

iandğ‘ (ğ‘–1 , inotğ‘ (ğ‘–2 ))

iorğ‘ (ğ‘–1 , ğ‘–2 )
â€¢ Return the bitwise disjunction of ğ‘–1 and ğ‘–2 .
iorğ‘ (ğ‘–1 , ğ‘–2 )

=

ibitsâˆ’1
ğ‘ (ibitsğ‘ (ğ‘–1 ) âˆ¨ ibitsğ‘ (ğ‘–2 ))

ixorğ‘ (ğ‘–1 , ğ‘–2 )
â€¢ Return the bitwise exclusive disjunction of ğ‘–1 and ğ‘–2 .
ixorğ‘ (ğ‘–1 , ğ‘–2 )

=

ibitsâˆ’1
ğ‘ (ibitsğ‘ (ğ‘–1 ) âŠ» ibitsğ‘ (ğ‘–2 ))

ishlğ‘ (ğ‘–1 , ğ‘–2 )
â€¢ Let ğ‘˜ be ğ‘–2 modulo ğ‘ .
â€¢ Return the result of shifting ğ‘–1 left by ğ‘˜ bits, modulo 2ğ‘ .
ishlğ‘ (ğ‘–1 , ğ‘–2 )

=

ğ‘ âˆ’ğ‘˜ ğ‘˜
ibitsâˆ’1
0 )
ğ‘ (ğ‘‘2

(if ibitsğ‘ (ğ‘–1 ) = ğ‘‘ğ‘˜1 ğ‘‘2ğ‘ âˆ’ğ‘˜ âˆ§ ğ‘˜ = ğ‘–2 mod ğ‘ )

ishr_uğ‘ (ğ‘–1 , ğ‘–2 )
â€¢ Let ğ‘˜ be ğ‘–2 modulo ğ‘ .
â€¢ Return the result of shifting ğ‘–1 right by ğ‘˜ bits, extended with 0 bits.
ishr_uğ‘ (ğ‘–1 , ğ‘–2 )
94

=

ğ‘˜ ğ‘ âˆ’ğ‘˜
ibitsâˆ’1
)
ğ‘ (0 ğ‘‘1

âˆ’ğ‘˜ ğ‘˜
(if ibitsğ‘ (ğ‘–1 ) = ğ‘‘ğ‘
ğ‘‘2 âˆ§ ğ‘˜ = ğ‘–2 mod ğ‘ )
1

Chapter 4. Execution

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

ishr_sğ‘ (ğ‘–1 , ğ‘–2 )
â€¢ Let ğ‘˜ be ğ‘–2 modulo ğ‘ .
â€¢ Return the result of shifting ğ‘–1 right by ğ‘˜ bits, extended with the most significant bit of the original value.
ishr_sğ‘ (ğ‘–1 , ğ‘–2 )

=

ğ‘˜+1 ğ‘ âˆ’ğ‘˜âˆ’1
ibitsâˆ’1
ğ‘‘1
)
ğ‘ (ğ‘‘0

(if ibitsğ‘ (ğ‘–1 ) = ğ‘‘0 ğ‘‘1ğ‘ âˆ’ğ‘˜âˆ’1 ğ‘‘ğ‘˜2 âˆ§ ğ‘˜ = ğ‘–2 mod ğ‘ )

irotlğ‘ (ğ‘–1 , ğ‘–2 )
â€¢ Let ğ‘˜ be ğ‘–2 modulo ğ‘ .
â€¢ Return the result of rotating ğ‘–1 left by ğ‘˜ bits.
irotlğ‘ (ğ‘–1 , ğ‘–2 )

=

ğ‘ âˆ’ğ‘˜ ğ‘˜
ibitsâˆ’1
ğ‘‘1 )
ğ‘ (ğ‘‘2

âˆ’ğ‘˜
(if ibitsğ‘ (ğ‘–1 ) = ğ‘‘ğ‘˜1 ğ‘‘ğ‘
âˆ§ ğ‘˜ = ğ‘–2 mod ğ‘ )
2

irotrğ‘ (ğ‘–1 , ğ‘–2 )
â€¢ Let ğ‘˜ be ğ‘–2 modulo ğ‘ .
â€¢ Return the result of rotating ğ‘–1 right by ğ‘˜ bits.
irotrğ‘ (ğ‘–1 , ğ‘–2 )

=

ğ‘˜ ğ‘ âˆ’ğ‘˜
ibitsâˆ’1
)
ğ‘ (ğ‘‘2 ğ‘‘1

(if ibitsğ‘ (ğ‘–1 ) = ğ‘‘1ğ‘ âˆ’ğ‘˜ ğ‘‘ğ‘˜2 âˆ§ ğ‘˜ = ğ‘–2 mod ğ‘ )

iclzğ‘ (ğ‘–)
â€¢ Return the count of leading zero bits in ğ‘–; all bits are considered leading zeros if ğ‘– is 0.
iclzğ‘ (ğ‘–)

(if ibitsğ‘ (ğ‘–) = 0ğ‘˜ (1 ğ‘‘* )? )

= ğ‘˜

ictzğ‘ (ğ‘–)
â€¢ Return the count of trailing zero bits in ğ‘–; all bits are considered trailing zeros if ğ‘– is 0.
ictzğ‘ (ğ‘–)

(if ibitsğ‘ (ğ‘–) = (ğ‘‘* 1)? 0ğ‘˜ )

= ğ‘˜

ipopcntğ‘ (ğ‘–)
â€¢ Return the count of non-zero bits in ğ‘–.
ipopcntğ‘ (ğ‘–)

=

ğ‘˜

(if ibitsğ‘ (ğ‘–) = (0* 1)ğ‘˜ 0* )

ieqzğ‘ (ğ‘–)
â€¢ Return 1 if ğ‘– is zero, 0 otherwise.
ieqzğ‘ (ğ‘–)

=

bool(ğ‘– = 0)

=

bool(ğ‘–1 = ğ‘–2 )

=

bool(ğ‘–1 Ì¸= ğ‘–2 )

ieqğ‘ (ğ‘–1 , ğ‘–2 )
â€¢ Return 1 if ğ‘–1 equals ğ‘–2 , 0 otherwise.
ieqğ‘ (ğ‘–1 , ğ‘–2 )
ineğ‘ (ğ‘–1 , ğ‘–2 )
â€¢ Return 1 if ğ‘–1 does not equal ğ‘–2 , 0 otherwise.
ineğ‘ (ğ‘–1 , ğ‘–2 )

4.3. Numerics

95

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

ilt_uğ‘ (ğ‘–1 , ğ‘–2 )
â€¢ Return 1 if ğ‘–1 is less than ğ‘–2 , 0 otherwise.
ilt_uğ‘ (ğ‘–1 , ğ‘–2 )

=

bool(ğ‘–1 < ğ‘–2 )

ilt_sğ‘ (ğ‘–1 , ğ‘–2 )
â€¢ Let ğ‘—1 be the signed interpretation of ğ‘–1 .
â€¢ Let ğ‘—2 be the signed interpretation of ğ‘–2 .
â€¢ Return 1 if ğ‘—1 is less than ğ‘—2 , 0 otherwise.
ilt_sğ‘ (ğ‘–1 , ğ‘–2 )

=

bool(signedğ‘ (ğ‘–1 ) < signedğ‘ (ğ‘–2 ))

igt_uğ‘ (ğ‘–1 , ğ‘–2 )
â€¢ Return 1 if ğ‘–1 is greater than ğ‘–2 , 0 otherwise.
igt_uğ‘ (ğ‘–1 , ğ‘–2 )

=

bool(ğ‘–1 > ğ‘–2 )

igt_sğ‘ (ğ‘–1 , ğ‘–2 )
â€¢ Let ğ‘—1 be the signed interpretation of ğ‘–1 .
â€¢ Let ğ‘—2 be the signed interpretation of ğ‘–2 .
â€¢ Return 1 if ğ‘—1 is greater than ğ‘—2 , 0 otherwise.
igt_sğ‘ (ğ‘–1 , ğ‘–2 )

=

bool(signedğ‘ (ğ‘–1 ) > signedğ‘ (ğ‘–2 ))

ile_uğ‘ (ğ‘–1 , ğ‘–2 )
â€¢ Return 1 if ğ‘–1 is less than or equal to ğ‘–2 , 0 otherwise.
ile_uğ‘ (ğ‘–1 , ğ‘–2 )

=

bool(ğ‘–1 â‰¤ ğ‘–2 )

ile_sğ‘ (ğ‘–1 , ğ‘–2 )
â€¢ Let ğ‘—1 be the signed interpretation of ğ‘–1 .
â€¢ Let ğ‘—2 be the signed interpretation of ğ‘–2 .
â€¢ Return 1 if ğ‘—1 is less than or equal to ğ‘—2 , 0 otherwise.
ile_sğ‘ (ğ‘–1 , ğ‘–2 )

=

bool(signedğ‘ (ğ‘–1 ) â‰¤ signedğ‘ (ğ‘–2 ))

ige_uğ‘ (ğ‘–1 , ğ‘–2 )
â€¢ Return 1 if ğ‘–1 is greater than or equal to ğ‘–2 , 0 otherwise.
ige_uğ‘ (ğ‘–1 , ğ‘–2 )

=

bool(ğ‘–1 â‰¥ ğ‘–2 )

ige_sğ‘ (ğ‘–1 , ğ‘–2 )
â€¢ Let ğ‘—1 be the signed interpretation of ğ‘–1 .
â€¢ Let ğ‘—2 be the signed interpretation of ğ‘–2 .
â€¢ Return 1 if ğ‘—1 is greater than or equal to ğ‘—2 , 0 otherwise.
ige_sğ‘ (ğ‘–1 , ğ‘–2 )

96

=

bool(signedğ‘ (ğ‘–1 ) â‰¥ signedğ‘ (ğ‘–2 ))

Chapter 4. Execution

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

iextendğ‘€ _sğ‘ (ğ‘–)
â€¢ Let ğ‘— be the result of computing wrapğ‘,ğ‘€ (ğ‘–).
â€¢ Return extends ğ‘€,ğ‘ (ğ‘—).
iextendğ‘€ _sğ‘ (ğ‘–)

=

extends ğ‘€,ğ‘ (wrapğ‘,ğ‘€ (ğ‘–))

ibitselectğ‘ (ğ‘–1 , ğ‘–2 , ğ‘–3 )
â€¢ Let ğ‘—1 be the bitwise conjunction of ğ‘–1 and ğ‘–3 .
â€¢ Let ğ‘—3â€² be the bitwise negation of ğ‘–3 .
â€¢ Let ğ‘—2 be the bitwise conjunction of ğ‘–2 and ğ‘—3â€² .
â€¢ Return the bitwise disjunction of ğ‘—1 and ğ‘—2 .
ibitselectğ‘ (ğ‘–1 , ğ‘–2 , ğ‘–3 )

=

iorğ‘ (iandğ‘ (ğ‘–1 , ğ‘–3 ), iandğ‘ (ğ‘–2 , inotğ‘ (ğ‘–3 )))

iabsğ‘ (ğ‘–)
â€¢ Let ğ‘— be the signed interpretation of ğ‘–.
â€¢ If ğ‘— is greater than or equal to 0, then return ğ‘–.
â€¢ Else return the negation of j, modulo 2ğ‘ .
iabsğ‘ (ğ‘–) = ğ‘–
iabsğ‘ (ğ‘–) = âˆ’signedğ‘ (ğ‘–) mod 2ğ‘

(if signedğ‘ (ğ‘–) â‰¥ 0)
(otherwise)

inegğ‘ (ğ‘–)
â€¢ Return the result of negating ğ‘–, modulo 2ğ‘ .
inegğ‘ (ğ‘–)

=

(2ğ‘ âˆ’ ğ‘–) mod 2ğ‘

imin_uğ‘ (ğ‘–1 , ğ‘–2 )
â€¢ Return ğ‘–1 if ilt_uğ‘ (ğ‘–1 , ğ‘–2 ) is 1, return ğ‘–2 otherwise.
imin_uğ‘ (ğ‘–1 , ğ‘–2 ) = ğ‘–1
imin_uğ‘ (ğ‘–1 , ğ‘–2 ) = ğ‘–2

(if ilt_uğ‘ (ğ‘–1 , ğ‘–2 ) = 1)
(otherwise)

imin_sğ‘ (ğ‘–1 , ğ‘–2 )
â€¢ Return ğ‘–1 if ilt_sğ‘ (ğ‘–1 , ğ‘–2 ) is 1, return ğ‘–2 otherwise.
imin_sğ‘ (ğ‘–1 , ğ‘–2 ) = ğ‘–1
imin_sğ‘ (ğ‘–1 , ğ‘–2 ) = ğ‘–2

(if ilt_sğ‘ (ğ‘–1 , ğ‘–2 ) = 1)
(otherwise)

imax_uğ‘ (ğ‘–1 , ğ‘–2 )
â€¢ Return ğ‘–1 if igt_uğ‘ (ğ‘–1 , ğ‘–2 ) is 1, return ğ‘–2 otherwise.
imax_uğ‘ (ğ‘–1 , ğ‘–2 ) =
imax_uğ‘ (ğ‘–1 , ğ‘–2 ) =

ğ‘–1
ğ‘–2

(if igt_uğ‘ (ğ‘–1 , ğ‘–2 ) = 1)
(otherwise)

imax_sğ‘ (ğ‘–1 , ğ‘–2 )
â€¢ Return ğ‘–1 if igt_sğ‘ (ğ‘–1 , ğ‘–2 ) is 1, return ğ‘–2 otherwise.
imax_sğ‘ (ğ‘–1 , ğ‘–2 ) =
imax_sğ‘ (ğ‘–1 , ğ‘–2 ) =

4.3. Numerics

ğ‘–1
ğ‘–2

(if igt_sğ‘ (ğ‘–1 , ğ‘–2 ) = 1)
(otherwise)

97

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

iadd_sat_uğ‘ (ğ‘–1 , ğ‘–2 )
â€¢ Let ğ‘– be the result of adding ğ‘–1 and ğ‘–2 .
â€¢ Return sat_uğ‘ (ğ‘–).
iadd_sat_uğ‘ (ğ‘–1 , ğ‘–2 )

=

sat_uğ‘ (ğ‘–1 + ğ‘–2 )

iadd_sat_sğ‘ (ğ‘–1 , ğ‘–2 )
â€¢ Let ğ‘—1 be the signed interpretation of ğ‘–1
â€¢ Let ğ‘—2 be the signed interpretation of ğ‘–2
â€¢ Let ğ‘— be the result of adding ğ‘—1 and ğ‘—2 .
â€¢ Return the value whose signed interpretation is sat_sğ‘ (ğ‘—).
iadd_sat_sğ‘ (ğ‘–1 , ğ‘–2 )

=

signedâˆ’1
ğ‘ (sat_sğ‘ (signedğ‘ (ğ‘–1 ) + signedğ‘ (ğ‘–2 )))

isub_sat_uğ‘ (ğ‘–1 , ğ‘–2 )
â€¢ Let ğ‘– be the result of subtracting ğ‘–2 from ğ‘–1 .
â€¢ Return sat_uğ‘ (ğ‘–).
isub_sat_uğ‘ (ğ‘–1 , ğ‘–2 )

=

sat_uğ‘ (ğ‘–1 âˆ’ ğ‘–2 )

isub_sat_sğ‘ (ğ‘–1 , ğ‘–2 )
â€¢ Let ğ‘—1 be the signed interpretation of ğ‘–1
â€¢ Let ğ‘—2 be the signed interpretation of ğ‘–2
â€¢ Let ğ‘— be the result of subtracting ğ‘—2 from ğ‘—1 .
â€¢ Return the value whose signed interpretation is sat_sğ‘ (ğ‘—).
isub_sat_sğ‘ (ğ‘–1 , ğ‘–2 )

=

signedâˆ’1
ğ‘ (sat_sğ‘ (signedğ‘ (ğ‘–1 ) âˆ’ signedğ‘ (ğ‘–2 )))

iavgr_uğ‘ (ğ‘–1 , ğ‘–2 )
â€¢ Let ğ‘— be the result of adding ğ‘–1 , ğ‘–2 , and 1.
â€¢ Return the result of dividing ğ‘— by 2, truncated toward zero.
iavgr_uğ‘ (ğ‘–1 , ğ‘–2 )

=

trunc((ğ‘–1 + ğ‘–2 + 1)/2)

iq15mulrsat_sğ‘ (ğ‘–1 , ğ‘–2 )
â€¢ Return the whose signed interpretation is the result of sat_sğ‘ (ishr_sğ‘ (ğ‘–1 Â· ğ‘–2 + 214 , 15)).
iq15mulrsat_sğ‘ (ğ‘–1 , ğ‘–2 )

=

14
signedâˆ’1
ğ‘ (sat_sğ‘ (ishr_sğ‘ (ğ‘–1 Â· ğ‘–2 + 2 , 15)))

4.3.3 Floating-Point Operations
Floating-point arithmetic follows the IEEE 75425 standard, with the following qualifications:
â€¢ All operators use round-to-nearest ties-to-even, except where otherwise specified. Non-default directed
rounding attributes are not supported.
â€¢ Following the recommendation that operators propagate NaN payloads from their operands is permitted but
not required.
25 https://ieeexplore.ieee.org/document/8766229

98

Chapter 4. Execution

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

â€¢ All operators use â€œnon-stopâ€ mode, and floating-point exceptions are not otherwise observable. In particular,
neither alternate floating-point exception handling attributes nor operators on status flags are supported.
There is no observable difference between quiet and signalling NaNs.
Ã² Note
Some of these limitations may be lifted in future versions of WebAssembly.

Rounding
Rounding always is round-to-nearest ties-to-even, in correspondence with IEEE 75426 (Section 4.3.1).
An exact floating-point number is a rational number that is exactly representable as a floating-point number of
given bit width ğ‘ .
A limit number for a given floating-point bit width ğ‘ is a positive or negative number whose magnitude is the
smallest power of 2 that is not exactly representable as a floating-point number of width ğ‘ (that magnitude is 2128
for ğ‘ = 32 and 21024 for ğ‘ = 64).
A candidate number is either an exact floating-point number or a positive or negative limit number for the given
bit width ğ‘ .
A candidate pair is a pair ğ‘§1 , ğ‘§2 of candidate numbers, such that no candidate number exists that lies between the
two.
A real number ğ‘Ÿ is converted to a floating-point value of bit width ğ‘ as follows:
â€¢ If ğ‘Ÿ is 0, then return +0.
â€¢ Else if ğ‘Ÿ is an exact floating-point number, then return ğ‘Ÿ.
â€¢ Else if ğ‘Ÿ greater than or equal to the positive limit, then return +âˆ.
â€¢ Else if ğ‘Ÿ is less than or equal to the negative limit, then return âˆ’âˆ.
â€¢ Else if ğ‘§1 and ğ‘§2 are a candidate pair such that ğ‘§1 < ğ‘Ÿ < ğ‘§2 , then:
â€“ If |ğ‘Ÿ âˆ’ ğ‘§1 | < |ğ‘Ÿ âˆ’ ğ‘§2 |, then let ğ‘§ be ğ‘§1 .
â€“ Else if |ğ‘Ÿ âˆ’ ğ‘§1 | > |ğ‘Ÿ âˆ’ ğ‘§2 |, then let ğ‘§ be ğ‘§2 .
â€“ Else if |ğ‘Ÿ âˆ’ ğ‘§1 | = |ğ‘Ÿ âˆ’ ğ‘§2 | and the significand of ğ‘§1 is even, then let ğ‘§ be ğ‘§1 .
â€“ Else, let ğ‘§ be ğ‘§2 .
â€¢ If ğ‘§ is 0, then:
â€“ If ğ‘Ÿ < 0, then return âˆ’0.
â€“ Else, return +0.
â€¢ Else if ğ‘§ is a limit number, then:
â€“ If ğ‘Ÿ < 0, then return âˆ’âˆ.
â€“ Else, return +âˆ.
â€¢ Else, return ğ‘§.
26 https://ieeexplore.ieee.org/document/8766229

4.3. Numerics

99

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)
floatğ‘ (0)
floatğ‘ (ğ‘Ÿ)
floatğ‘ (ğ‘Ÿ)
floatğ‘ (ğ‘Ÿ)
floatğ‘ (ğ‘Ÿ)

=
=
=
=
=

+0
ğ‘Ÿ
+âˆ
âˆ’âˆ
closestğ‘ (ğ‘Ÿ, ğ‘§1 , ğ‘§2 )

closestğ‘ (ğ‘Ÿ, ğ‘§1 , ğ‘§2 )
closestğ‘ (ğ‘Ÿ, ğ‘§1 , ğ‘§2 )
closestğ‘ (ğ‘Ÿ, ğ‘§1 , ğ‘§2 )
closestğ‘ (ğ‘Ÿ, ğ‘§1 , ğ‘§2 )

= rectifyğ‘ (ğ‘Ÿ, ğ‘§1 )
= rectifyğ‘ (ğ‘Ÿ, ğ‘§2 )
= rectifyğ‘ (ğ‘Ÿ, ğ‘§1 )
= rectifyğ‘ (ğ‘Ÿ, ğ‘§2 )

rectifyğ‘ (ğ‘Ÿ, Â±limitğ‘ )
rectifyğ‘ (ğ‘Ÿ, 0)
rectifyğ‘ (ğ‘Ÿ, 0)
rectifyğ‘ (ğ‘Ÿ, ğ‘§)

=
=
=
=

Â±âˆ
+0
âˆ’0
ğ‘§

=
=
=
=

fğ‘ âˆ©Q
expon(ğ‘ )âˆ’1
22
exactğ‘ âˆª {+limitğ‘ , âˆ’limitğ‘ }
{(ğ‘§1 , ğ‘§2 ) âˆˆ candidate2ğ‘ | ğ‘§1 < ğ‘§2 âˆ§ âˆ€ğ‘§ âˆˆ candidateğ‘ , ğ‘§ â‰¤ ğ‘§1 âˆ¨ ğ‘§ â‰¥ ğ‘§2 }

(if ğ‘Ÿ âˆˆ exactğ‘ )
(if ğ‘Ÿ â‰¥ +limitğ‘ )
(if ğ‘Ÿ â‰¤ âˆ’limitğ‘ )
(if ğ‘§1 < ğ‘Ÿ < ğ‘§2 âˆ§ (ğ‘§1 , ğ‘§2 ) âˆˆ candidatepairğ‘ )
(if |ğ‘Ÿ âˆ’ ğ‘§1 | < |ğ‘Ÿ âˆ’ ğ‘§2 |)
(if |ğ‘Ÿ âˆ’ ğ‘§1 | > |ğ‘Ÿ âˆ’ ğ‘§2 |)
(if |ğ‘Ÿ âˆ’ ğ‘§1 | = |ğ‘Ÿ âˆ’ ğ‘§2 | âˆ§ evenğ‘ (ğ‘§1 ))
(if |ğ‘Ÿ âˆ’ ğ‘§1 | = |ğ‘Ÿ âˆ’ ğ‘§2 | âˆ§ evenğ‘ (ğ‘§2 ))

(ğ‘Ÿ â‰¥ 0)
(ğ‘Ÿ < 0)

where:
exactğ‘
limitğ‘
candidateğ‘
candidatepairğ‘

evenğ‘ ((ğ‘‘ + ğ‘š Â· 2âˆ’ğ‘€ ) Â· 2ğ‘’ ) â‡” ğ‘š mod 2 = 0
evenğ‘ (Â±limitğ‘ )
â‡” true

NaN Propagation
When the result of a floating-point operator other than fneg, fabs, or fcopysign is a NaN, then its sign is nondeterministic and the payload is computed as follows:
â€¢ If the payload of all NaN inputs to the operator is canonical (including the case that there are no NaN inputs),
then the payload of the output is canonical as well.
â€¢ Otherwise the payload is picked non-deterministically among all arithmetic NaNs; that is, its most significant
bit is 1 and all others are unspecified.
â€¢ In the deterministic profile, however, a positive canonical NaNs is reliably produced in the latter case.
The non-deterministic result is expressed by the following auxiliary function producing a set of allowed outputs
from a set of inputs:
[!DET]
[!DET]

nansğ‘ {ğ‘§ * }
nansğ‘ {ğ‘§ * }
nansğ‘ {ğ‘§ * }

= {+nan(canonğ‘ )}
= {+nan(ğ‘›), âˆ’nan(ğ‘›) | ğ‘› = canonğ‘ }
= {+nan(ğ‘›), âˆ’nan(ğ‘›) | ğ‘› â‰¥ canonğ‘ }

(if {ğ‘§ * } âŠ† {+nan(canonğ‘ ), âˆ’nan(canonğ‘ )}
(if {ğ‘§ * } Ì¸âŠ† {+nan(canonğ‘ ), âˆ’nan(canonğ‘ )}

faddğ‘ (ğ‘§1 , ğ‘§2 )
â€¢ If either ğ‘§1 or ğ‘§2 is a NaN, then return an element of nansğ‘ {ğ‘§1 , ğ‘§2 }.
â€¢ Else if both ğ‘§1 and ğ‘§2 are infinities of opposite signs, then return an element of nansğ‘ {}.
â€¢ Else if both ğ‘§1 and ğ‘§2 are infinities of equal sign, then return that infinity.
â€¢ Else if either ğ‘§1 or ğ‘§2 is an infinity, then return that infinity.
â€¢ Else if both ğ‘§1 and ğ‘§2 are zeroes of opposite sign, then return positive zero.
â€¢ Else if both ğ‘§1 and ğ‘§2 are zeroes of equal sign, then return that zero.
â€¢ Else if either ğ‘§1 or ğ‘§2 is a zero, then return the other operand.
â€¢ Else if both ğ‘§1 and ğ‘§2 are values with the same magnitude but opposite signs, then return positive zero.
â€¢ Else return the result of adding ğ‘§1 and ğ‘§2 , rounded to the nearest representable value.

100

Chapter 4. Execution

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)
faddğ‘ (Â±nan(ğ‘›), ğ‘§2 ) = nansğ‘ {Â±nan(ğ‘›), ğ‘§2 }
faddğ‘ (ğ‘§1 , Â±nan(ğ‘›)) = nansğ‘ {Â±nan(ğ‘›), ğ‘§1 }
faddğ‘ (Â±âˆ, âˆ“âˆ)
= nansğ‘ {}
faddğ‘ (Â±âˆ, Â±âˆ)
= Â±âˆ
faddğ‘ (ğ‘§1 , Â±âˆ)
= Â±âˆ
faddğ‘ (Â±âˆ, ğ‘§2 )
= Â±âˆ
faddğ‘ (Â±0, âˆ“0)
= +0
faddğ‘ (Â±0, Â±0)
= Â±0
faddğ‘ (ğ‘§1 , Â±0)
= ğ‘§1
faddğ‘ (Â±0, ğ‘§2 )
= ğ‘§2
faddğ‘ (Â±ğ‘, âˆ“ğ‘)
= +0
faddğ‘ (ğ‘§1 , ğ‘§2 )
= floatğ‘ (ğ‘§1 + ğ‘§2 )
fsubğ‘ (ğ‘§1 , ğ‘§2 )
â€¢ If either ğ‘§1 or ğ‘§2 is a NaN, then return an element of nansğ‘ {ğ‘§1 , ğ‘§2 }.
â€¢ Else if both ğ‘§1 and ğ‘§2 are infinities of equal signs, then return an element of nansğ‘ {}.
â€¢ Else if both ğ‘§1 and ğ‘§2 are infinities of opposite sign, then return ğ‘§1 .
â€¢ Else if ğ‘§1 is an infinity, then return that infinity.
â€¢ Else if ğ‘§2 is an infinity, then return that infinity negated.
â€¢ Else if both ğ‘§1 and ğ‘§2 are zeroes of equal sign, then return positive zero.
â€¢ Else if both ğ‘§1 and ğ‘§2 are zeroes of opposite sign, then return ğ‘§1 .
â€¢ Else if ğ‘§2 is a zero, then return ğ‘§1 .
â€¢ Else if ğ‘§1 is a zero, then return ğ‘§2 negated.
â€¢ Else if both ğ‘§1 and ğ‘§2 are the same value, then return positive zero.
â€¢ Else return the result of subtracting ğ‘§2 from ğ‘§1 , rounded to the nearest representable value.
fsubğ‘ (Â±nan(ğ‘›), ğ‘§2 ) = nansğ‘ {Â±nan(ğ‘›), ğ‘§2 }
fsubğ‘ (ğ‘§1 , Â±nan(ğ‘›)) = nansğ‘ {Â±nan(ğ‘›), ğ‘§1 }
fsubğ‘ (Â±âˆ, Â±âˆ)
= nansğ‘ {}
fsubğ‘ (Â±âˆ, âˆ“âˆ)
= Â±âˆ
fsubğ‘ (ğ‘§1 , Â±âˆ)
= âˆ“âˆ
fsubğ‘ (Â±âˆ, ğ‘§2 )
= Â±âˆ
fsubğ‘ (Â±0, Â±0)
= +0
fsubğ‘ (Â±0, âˆ“0)
= Â±0
fsubğ‘ (ğ‘§1 , Â±0)
= ğ‘§1
fsubğ‘ (Â±0, Â±ğ‘2 )
= âˆ“ğ‘2
fsubğ‘ (Â±ğ‘, Â±ğ‘)
= +0
fsubğ‘ (ğ‘§1 , ğ‘§2 )
= floatğ‘ (ğ‘§1 âˆ’ ğ‘§2 )

Ã² Note
Up to the non-determinism regarding NaNs, it always holds that fsubğ‘ (ğ‘§1 , ğ‘§2 ) = faddğ‘ (ğ‘§1 , fnegğ‘ (ğ‘§2 )).
fmulğ‘ (ğ‘§1 , ğ‘§2 )
â€¢ If either ğ‘§1 or ğ‘§2 is a NaN, then return an element of nansğ‘ {ğ‘§1 , ğ‘§2 }.
â€¢ Else if one of ğ‘§1 and ğ‘§2 is a zero and the other an infinity, then return an element of nansğ‘ {}.
â€¢ Else if both ğ‘§1 and ğ‘§2 are infinities of equal sign, then return positive infinity.
â€¢ Else if both ğ‘§1 and ğ‘§2 are infinities of opposite sign, then return negative infinity.
â€¢ Else if either ğ‘§1 or ğ‘§2 is an infinity and the other a value with equal sign, then return positive infinity.
4.3. Numerics

101

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

â€¢ Else if either ğ‘§1 or ğ‘§2 is an infinity and the other a value with opposite sign, then return negative infinity.
â€¢ Else if both ğ‘§1 and ğ‘§2 are zeroes of equal sign, then return positive zero.
â€¢ Else if both ğ‘§1 and ğ‘§2 are zeroes of opposite sign, then return negative zero.
â€¢ Else return the result of multiplying ğ‘§1 and ğ‘§2 , rounded to the nearest representable value.
fmulğ‘ (Â±nan(ğ‘›), ğ‘§2 ) = nansğ‘ {Â±nan(ğ‘›), ğ‘§2 }
fmulğ‘ (ğ‘§1 , Â±nan(ğ‘›)) = nansğ‘ {Â±nan(ğ‘›), ğ‘§1 }
fmulğ‘ (Â±âˆ, Â±0)
= nansğ‘ {}
fmulğ‘ (Â±âˆ, âˆ“0)
= nansğ‘ {}
fmulğ‘ (Â±0, Â±âˆ)
= nansğ‘ {}
fmulğ‘ (Â±0, âˆ“âˆ)
= nansğ‘ {}
fmulğ‘ (Â±âˆ, Â±âˆ)
= +âˆ
fmulğ‘ (Â±âˆ, âˆ“âˆ)
= âˆ’âˆ
fmulğ‘ (Â±ğ‘1 , Â±âˆ)
= +âˆ
fmulğ‘ (Â±ğ‘1 , âˆ“âˆ)
= âˆ’âˆ
fmulğ‘ (Â±âˆ, Â±ğ‘2 )
= +âˆ
fmulğ‘ (Â±âˆ, âˆ“ğ‘2 )
= âˆ’âˆ
fmulğ‘ (Â±0, Â±0)
= +0
fmulğ‘ (Â±0, âˆ“0)
= âˆ’0
fmulğ‘ (ğ‘§1 , ğ‘§2 )
= floatğ‘ (ğ‘§1 Â· ğ‘§2 )
fdivğ‘ (ğ‘§1 , ğ‘§2 )
â€¢ If either ğ‘§1 or ğ‘§2 is a NaN, then return an element of nansğ‘ {ğ‘§1 , ğ‘§2 }.
â€¢ Else if both ğ‘§1 and ğ‘§2 are infinities, then return an element of nansğ‘ {}.
â€¢ Else if both ğ‘§1 and ğ‘§2 are zeroes, then return an element of nansğ‘ {ğ‘§1 , ğ‘§2 }.
â€¢ Else if ğ‘§1 is an infinity and ğ‘§2 a value with equal sign, then return positive infinity.
â€¢ Else if ğ‘§1 is an infinity and ğ‘§2 a value with opposite sign, then return negative infinity.
â€¢ Else if ğ‘§2 is an infinity and ğ‘§1 a value with equal sign, then return positive zero.
â€¢ Else if ğ‘§2 is an infinity and ğ‘§1 a value with opposite sign, then return negative zero.
â€¢ Else if ğ‘§1 is a zero and ğ‘§2 a value with equal sign, then return positive zero.
â€¢ Else if ğ‘§1 is a zero and ğ‘§2 a value with opposite sign, then return negative zero.
â€¢ Else if ğ‘§2 is a zero and ğ‘§1 a value with equal sign, then return positive infinity.
â€¢ Else if ğ‘§2 is a zero and ğ‘§1 a value with opposite sign, then return negative infinity.
â€¢ Else return the result of dividing ğ‘§1 by ğ‘§2 , rounded to the nearest representable value.
fdivğ‘ (Â±nan(ğ‘›), ğ‘§2 ) = nansğ‘ {Â±nan(ğ‘›), ğ‘§2 }
fdivğ‘ (ğ‘§1 , Â±nan(ğ‘›)) = nansğ‘ {Â±nan(ğ‘›), ğ‘§1 }
fdivğ‘ (Â±âˆ, Â±âˆ)
= nansğ‘ {}
fdivğ‘ (Â±âˆ, âˆ“âˆ)
= nansğ‘ {}
fdivğ‘ (Â±0, Â±0)
= nansğ‘ {}
fdivğ‘ (Â±0, âˆ“0)
= nansğ‘ {}
fdivğ‘ (Â±âˆ, Â±ğ‘2 )
= +âˆ
fdivğ‘ (Â±âˆ, âˆ“ğ‘2 )
= âˆ’âˆ
fdivğ‘ (Â±ğ‘1 , Â±âˆ)
= +0
fdivğ‘ (Â±ğ‘1 , âˆ“âˆ)
= âˆ’0
fdivğ‘ (Â±0, Â±ğ‘2 )
= +0
fdivğ‘ (Â±0, âˆ“ğ‘2 )
= âˆ’0
fdivğ‘ (Â±ğ‘1 , Â±0)
= +âˆ
fdivğ‘ (Â±ğ‘1 , âˆ“0)
= âˆ’âˆ
fdivğ‘ (ğ‘§1 , ğ‘§2 )
= floatğ‘ (ğ‘§1 /ğ‘§2 )

102

Chapter 4. Execution

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

fmağ‘ (ğ‘§1 , ğ‘§2 , ğ‘§3 )
The function fma is the same as fusedMultiplyAdd defined by IEEE 75427 (Section 5.4.1). It computes (ğ‘§1 Â·ğ‘§2 )+ğ‘§3
as if with unbounded range and precision, rounding only once for the final result.
â€¢ If either ğ‘§1 or ğ‘§2 or ğ‘§3 is a NaN, return an element of nansğ‘ ğ‘§1 , ğ‘§2 , ğ‘§3 .
â€¢ Else if either ğ‘§1 or ğ‘§2 is a zero and the other is an infinity, then return an element of nansğ‘ {}.
â€¢ Else if both ğ‘§1 or ğ‘§2 are infinities of equal sign, and ğ‘§3 is a negative infinity, then return an element of
nansğ‘ {}.
â€¢ Else if both ğ‘§1 or ğ‘§2 are infinities of opposite sign, and ğ‘§3 is a positive infinity, then return an element of
nansğ‘ {}.
â€¢ Else if either ğ‘§1 or ğ‘§2 is an infinity and the other is a value of the same sign, and ğ‘§3 is a negative infinity,
then return an element of nansğ‘ {}.
â€¢ Else if either ğ‘§1 or ğ‘§2 is an infinity and the other is a value of the opposite sign, and ğ‘§3 is a positive infinity,
then return an element of nansğ‘ {}.
â€¢ Else if both ğ‘§1 and ğ‘§2 are zeroes of the same sign and ğ‘§3 is a zero, then return positive zero.
â€¢ Else if both ğ‘§1 and ğ‘§2 are zeroes of the opposite sign and ğ‘§3 is a positive zero, then return positive zero.
â€¢ Else if both ğ‘§1 and ğ‘§2 are zeroes of the opposite sign and ğ‘§3 is a negative zero, then return negative zero.
â€¢ Else return the result of multiplying ğ‘§1 and ğ‘§2 , adding ğ‘§3 to the intermediate, and the final result ref:rounded
<aux-ieee> to the nearest representable value.
fmağ‘ (Â±nan(ğ‘›), ğ‘§2 , ğ‘§3 ) = nansğ‘ {Â±nan(ğ‘›), ğ‘§2 , ğ‘§3 }
fmağ‘ (ğ‘§1 , Â±nan(ğ‘›), ğ‘§3 ) = nansğ‘ {Â±nan(ğ‘›), ğ‘§1 , ğ‘§3 }
fmağ‘ (ğ‘§1 , ğ‘§2 , Â±nan(ğ‘›)) = nansğ‘ {Â±nan(ğ‘›), ğ‘§1 , ğ‘§2 }
fmağ‘ (Â±âˆ, Â±0, ğ‘§3 )
= nansğ‘ {}
fmağ‘ (Â±âˆ, âˆ“0, ğ‘§3 )
= nansğ‘ {}
fmağ‘ (Â±âˆ, Â±âˆ, âˆ’âˆ) = nansğ‘ {}
fmağ‘ (Â±âˆ, âˆ“âˆ, +âˆ) = nansğ‘ {}
fmağ‘ (Â±ğ‘1 , Â±âˆ, âˆ’âˆ) = nansğ‘ {}
fmağ‘ (Â±ğ‘1 , âˆ“âˆ, +âˆ) = nansğ‘ {}
fmağ‘ (Â±âˆ, Â±ğ‘1 , âˆ’âˆ) = nansğ‘ {}
fmağ‘ (âˆ“âˆ, Â±ğ‘1 , +âˆ) = nansğ‘ {}
fmağ‘ (Â±0, Â±0, âˆ“0)
= +0
fmağ‘ (Â±0, Â±0, Â±0)
= +0
fmağ‘ (Â±0, âˆ“0, +0)
= +0
fmağ‘ (Â±0, âˆ“0, âˆ’0)
= âˆ’0
fmağ‘ (ğ‘§1 , ğ‘§2 , ğ‘§3 )
= floatğ‘ (ğ‘§1 Â· ğ‘§2 + ğ‘§3 )
fminğ‘ (ğ‘§1 , ğ‘§2 )
â€¢ If either ğ‘§1 or ğ‘§2 is a NaN, then return an element of nansğ‘ {ğ‘§1 , ğ‘§2 }.
â€¢ Else if either ğ‘§1 or ğ‘§2 is a negative infinity, then return negative infinity.
â€¢ Else if either ğ‘§1 or ğ‘§2 is a positive infinity, then return the other value.
â€¢ Else if both ğ‘§1 and ğ‘§2 are zeroes of opposite signs, then return negative zero.
â€¢ Else return the smaller value of ğ‘§1 and ğ‘§2 .
27 https://ieeexplore.ieee.org/document/8766229

4.3. Numerics

103

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)
fminğ‘ (Â±nan(ğ‘›), ğ‘§2 ) = nansğ‘ {Â±nan(ğ‘›), ğ‘§2 }
fminğ‘ (ğ‘§1 , Â±nan(ğ‘›)) = nansğ‘ {Â±nan(ğ‘›), ğ‘§1 }
fminğ‘ (+âˆ, ğ‘§2 )
= ğ‘§2
fminğ‘ (âˆ’âˆ, ğ‘§2 )
= âˆ’âˆ
fminğ‘ (ğ‘§1 , +âˆ)
= ğ‘§1
fminğ‘ (ğ‘§1 , âˆ’âˆ)
= âˆ’âˆ
fminğ‘ (Â±0, âˆ“0)
= âˆ’0
fminğ‘ (ğ‘§1 , ğ‘§2 )
= ğ‘§1
fminğ‘ (ğ‘§1 , ğ‘§2 )
= ğ‘§2

(if ğ‘§1 â‰¤ ğ‘§2 )
(if ğ‘§2 â‰¤ ğ‘§1 )

fmaxğ‘ (ğ‘§1 , ğ‘§2 )
â€¢ If either ğ‘§1 or ğ‘§2 is a NaN, then return an element of nansğ‘ {ğ‘§1 , ğ‘§2 }.
â€¢ Else if either ğ‘§1 or ğ‘§2 is a positive infinity, then return positive infinity.
â€¢ Else if either ğ‘§1 or ğ‘§2 is a negative infinity, then return the other value.
â€¢ Else if both ğ‘§1 and ğ‘§2 are zeroes of opposite signs, then return positive zero.
â€¢ Else return the larger value of ğ‘§1 and ğ‘§2 .
fmaxğ‘ (Â±nan(ğ‘›), ğ‘§2 ) =
fmaxğ‘ (ğ‘§1 , Â±nan(ğ‘›)) =
fmaxğ‘ (+âˆ, ğ‘§2 )
=
fmaxğ‘ (âˆ’âˆ, ğ‘§2 )
=
fmaxğ‘ (ğ‘§1 , +âˆ)
=
fmaxğ‘ (ğ‘§1 , âˆ’âˆ)
=
fmaxğ‘ (Â±0, âˆ“0)
=
fmaxğ‘ (ğ‘§1 , ğ‘§2 )
=
fmaxğ‘ (ğ‘§1 , ğ‘§2 )
=

nansğ‘ {Â±nan(ğ‘›), ğ‘§2 }
nansğ‘ {Â±nan(ğ‘›), ğ‘§1 }
+âˆ
ğ‘§2
+âˆ
ğ‘§1
+0
ğ‘§1
ğ‘§2

(if ğ‘§1 â‰¥ ğ‘§2 )
(if ğ‘§2 â‰¥ ğ‘§1 )

fcopysignğ‘ (ğ‘§1 , ğ‘§2 )
â€¢ If ğ‘§1 and ğ‘§2 have the same sign, then return ğ‘§1 .
â€¢ Else return ğ‘§1 with negated sign.
fcopysignğ‘ (Â±ğ‘1 , Â±ğ‘2 )
fcopysignğ‘ (Â±ğ‘1 , âˆ“ğ‘2 )

=
=

Â±ğ‘1
âˆ“ğ‘1

fabsğ‘ (ğ‘§)
â€¢ If ğ‘§ is a NaN, then return ğ‘§ with positive sign.
â€¢ Else if ğ‘§ is an infinity, then return positive infinity.
â€¢ Else if ğ‘§ is a zero, then return positive zero.
â€¢ Else if ğ‘§ is a positive value, then ğ‘§.
â€¢ Else return ğ‘§ negated.
fabsğ‘ (Â±nan(ğ‘›))
fabsğ‘ (Â±âˆ)
fabsğ‘ (Â±0)
fabsğ‘ (Â±ğ‘)

= +nan(ğ‘›)
= +âˆ
= +0
= +ğ‘

fnegğ‘ (ğ‘§)
â€¢ If ğ‘§ is a NaN, then return ğ‘§ with negated sign.
â€¢ Else if ğ‘§ is an infinity, then return that infinity negated.
â€¢ Else if ğ‘§ is a zero, then return that zero negated.
â€¢ Else return ğ‘§ negated.
104

Chapter 4. Execution

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)
fnegğ‘ (Â±nan(ğ‘›))
fnegğ‘ (Â±âˆ)
fnegğ‘ (Â±0)
fnegğ‘ (Â±ğ‘)

=
=
=
=

âˆ“nan(ğ‘›)
âˆ“âˆ
âˆ“0
âˆ“ğ‘

fsqrtğ‘ (ğ‘§)
â€¢ If ğ‘§ is a NaN, then return an element of nansğ‘ {ğ‘§}.
â€¢ Else if ğ‘§ is negative infinity, then return an element of nansğ‘ {}.
â€¢ Else if ğ‘§ is positive infinity, then return positive infinity.
â€¢ Else if ğ‘§ is a zero, then return that zero.
â€¢ Else if ğ‘§ has a negative sign, then return an element of nansğ‘ {}.
â€¢ Else return the square root of ğ‘§.
fsqrtğ‘ (Â±nan(ğ‘›))
fsqrtğ‘ (âˆ’âˆ)
fsqrtğ‘ (+âˆ)
fsqrtğ‘ (Â±0)
fsqrtğ‘ (âˆ’ğ‘)
fsqrtğ‘ (+ğ‘)

=
=
=
=
=
=

nansğ‘ {Â±nan(ğ‘›)}
nansğ‘ {}
+âˆ
Â±0
nansğ‘ {}
(ï¸€âˆš )ï¸€
ğ‘
floatğ‘

fceilğ‘ (ğ‘§)
â€¢ If ğ‘§ is a NaN, then return an element of nansğ‘ {ğ‘§}.
â€¢ Else if ğ‘§ is an infinity, then return ğ‘§.
â€¢ Else if ğ‘§ is a zero, then return ğ‘§.
â€¢ Else if ğ‘§ is smaller than 0 but greater than âˆ’1, then return negative zero.
â€¢ Else return the smallest integral value that is not smaller than ğ‘§.
fceilğ‘ (Â±nan(ğ‘›))
fceilğ‘ (Â±âˆ)
fceilğ‘ (Â±0)
fceilğ‘ (âˆ’ğ‘)
fceilğ‘ (Â±ğ‘)

=
=
=
=
=

nansğ‘ {Â±nan(ğ‘›)}
Â±âˆ
Â±0
âˆ’0
floatğ‘ (ğ‘–)

(if âˆ’1 < âˆ’ğ‘ < 0)
(if Â±ğ‘ â‰¤ ğ‘– < Â±ğ‘ + 1)

ffloorğ‘ (ğ‘§)
â€¢ If ğ‘§ is a NaN, then return an element of nansğ‘ {ğ‘§}.
â€¢ Else if ğ‘§ is an infinity, then return ğ‘§.
â€¢ Else if ğ‘§ is a zero, then return ğ‘§.
â€¢ Else if ğ‘§ is greater than 0 but smaller than 1, then return positive zero.
â€¢ Else return the largest integral value that is not larger than ğ‘§.
ffloorğ‘ (Â±nan(ğ‘›))
ffloorğ‘ (Â±âˆ)
ffloorğ‘ (Â±0)
ffloorğ‘ (+ğ‘)
ffloorğ‘ (Â±ğ‘)

4.3. Numerics

=
=
=
=
=

nansğ‘ {Â±nan(ğ‘›)}
Â±âˆ
Â±0
+0
floatğ‘ (ğ‘–)

(if 0 < +ğ‘ < 1)
(if Â±ğ‘ âˆ’ 1 < ğ‘– â‰¤ Â±ğ‘)

105

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

ftruncğ‘ (ğ‘§)
â€¢ If ğ‘§ is a NaN, then return an element of nansğ‘ {ğ‘§}.
â€¢ Else if ğ‘§ is an infinity, then return ğ‘§.
â€¢ Else if ğ‘§ is a zero, then return ğ‘§.
â€¢ Else if ğ‘§ is greater than 0 but smaller than 1, then return positive zero.
â€¢ Else if ğ‘§ is smaller than 0 but greater than âˆ’1, then return negative zero.
â€¢ Else return the integral value with the same sign as ğ‘§ and the largest magnitude that is not larger than the
magnitude of ğ‘§.
ftruncğ‘ (Â±nan(ğ‘›))
ftruncğ‘ (Â±âˆ)
ftruncğ‘ (Â±0)
ftruncğ‘ (+ğ‘)
ftruncğ‘ (âˆ’ğ‘)
ftruncğ‘ (Â±ğ‘)

nansğ‘ {Â±nan(ğ‘›)}
Â±âˆ
Â±0
+0
âˆ’0
floatğ‘ (Â±ğ‘–)

=
=
=
=
=
=

(if 0 < +ğ‘ < 1)
(if âˆ’1 < âˆ’ğ‘ < 0)
(if +ğ‘ âˆ’ 1 < ğ‘– â‰¤ +ğ‘)

fnearestğ‘ (ğ‘§)
â€¢ If ğ‘§ is a NaN, then return an element of nansğ‘ {ğ‘§}.
â€¢ Else if ğ‘§ is an infinity, then return ğ‘§.
â€¢ Else if ğ‘§ is a zero, then return ğ‘§.
â€¢ Else if ğ‘§ is greater than 0 but smaller than or equal to 0.5, then return positive zero.
â€¢ Else if ğ‘§ is smaller than 0 but greater than or equal to âˆ’0.5, then return negative zero.
â€¢ Else return the integral value that is nearest to ğ‘§; if two values are equally near, return the even one.
fnearestğ‘ (Â±nan(ğ‘›))
fnearestğ‘ (Â±âˆ)
fnearestğ‘ (Â±0)
fnearestğ‘ (+ğ‘)
fnearestğ‘ (âˆ’ğ‘)
fnearestğ‘ (Â±ğ‘)
fnearestğ‘ (Â±ğ‘)

=
=
=
=
=
=
=

nansğ‘ {Â±nan(ğ‘›)}
Â±âˆ
Â±0
+0
âˆ’0
floatğ‘ (Â±ğ‘–)
floatğ‘ (Â±ğ‘–)

(if 0 < +ğ‘ â‰¤ 0.5)
(if âˆ’0.5 â‰¤ âˆ’ğ‘ < 0)
(if |ğ‘– âˆ’ ğ‘| < 0.5)
(if |ğ‘– âˆ’ ğ‘| = 0.5 âˆ§ ğ‘– even)

feqğ‘ (ğ‘§1 , ğ‘§2 )
â€¢ If either ğ‘§1 or ğ‘§2 is a NaN, then return 0.
â€¢ Else if both ğ‘§1 and ğ‘§2 are zeroes, then return 1.
â€¢ Else if both ğ‘§1 and ğ‘§2 are the same value, then return 1.
â€¢ Else return 0.
feqğ‘ (Â±nan(ğ‘›), ğ‘§2 ) = 0
feqğ‘ (ğ‘§1 , Â±nan(ğ‘›)) = 0
feqğ‘ (Â±0, âˆ“0)
= 1
feqğ‘ (ğ‘§1 , ğ‘§2 )
= bool(ğ‘§1 = ğ‘§2 )
fneğ‘ (ğ‘§1 , ğ‘§2 )
â€¢ If either ğ‘§1 or ğ‘§2 is a NaN, then return 1.
â€¢ Else if both ğ‘§1 and ğ‘§2 are zeroes, then return 0.
â€¢ Else if both ğ‘§1 and ğ‘§2 are the same value, then return 0.
â€¢ Else return 1.

106

Chapter 4. Execution

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)
fneğ‘ (Â±nan(ğ‘›), ğ‘§2 ) = 1
fneğ‘ (ğ‘§1 , Â±nan(ğ‘›)) = 1
fneğ‘ (Â±0, âˆ“0)
= 0
fneğ‘ (ğ‘§1 , ğ‘§2 )
= bool(ğ‘§1 Ì¸= ğ‘§2 )
fltğ‘ (ğ‘§1 , ğ‘§2 )
â€¢ If either ğ‘§1 or ğ‘§2 is a NaN, then return 0.
â€¢ Else if ğ‘§1 and ğ‘§2 are the same value, then return 0.
â€¢ Else if ğ‘§1 is positive infinity, then return 0.
â€¢ Else if ğ‘§1 is negative infinity, then return 1.
â€¢ Else if ğ‘§2 is positive infinity, then return 1.
â€¢ Else if ğ‘§2 is negative infinity, then return 0.
â€¢ Else if both ğ‘§1 and ğ‘§2 are zeroes, then return 0.
â€¢ Else if ğ‘§1 is smaller than ğ‘§2 , then return 1.
â€¢ Else return 0.
fltğ‘ (Â±nan(ğ‘›), ğ‘§2 ) = 0
fltğ‘ (ğ‘§1 , Â±nan(ğ‘›)) = 0
fltğ‘ (ğ‘§, ğ‘§)
= 0
fltğ‘ (+âˆ, ğ‘§2 )
= 0
fltğ‘ (âˆ’âˆ, ğ‘§2 )
= 1
fltğ‘ (ğ‘§1 , +âˆ)
= 1
fltğ‘ (ğ‘§1 , âˆ’âˆ)
= 0
fltğ‘ (Â±0, âˆ“0)
= 0
fltğ‘ (ğ‘§1 , ğ‘§2 )
= bool(ğ‘§1 < ğ‘§2 )
fgtğ‘ (ğ‘§1 , ğ‘§2 )
â€¢ If either ğ‘§1 or ğ‘§2 is a NaN, then return 0.
â€¢ Else if ğ‘§1 and ğ‘§2 are the same value, then return 0.
â€¢ Else if ğ‘§1 is positive infinity, then return 1.
â€¢ Else if ğ‘§1 is negative infinity, then return 0.
â€¢ Else if ğ‘§2 is positive infinity, then return 0.
â€¢ Else if ğ‘§2 is negative infinity, then return 1.
â€¢ Else if both ğ‘§1 and ğ‘§2 are zeroes, then return 0.
â€¢ Else if ğ‘§1 is larger than ğ‘§2 , then return 1.
â€¢ Else return 0.
fgtğ‘ (Â±nan(ğ‘›), ğ‘§2 ) = 0
fgtğ‘ (ğ‘§1 , Â±nan(ğ‘›)) = 0
fgtğ‘ (ğ‘§, ğ‘§)
= 0
fgtğ‘ (+âˆ, ğ‘§2 )
= 1
fgtğ‘ (âˆ’âˆ, ğ‘§2 )
= 0
fgtğ‘ (ğ‘§1 , +âˆ)
= 0
fgtğ‘ (ğ‘§1 , âˆ’âˆ)
= 1
fgtğ‘ (Â±0, âˆ“0)
= 0
fgtğ‘ (ğ‘§1 , ğ‘§2 )
= bool(ğ‘§1 > ğ‘§2 )

4.3. Numerics

107

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

fleğ‘ (ğ‘§1 , ğ‘§2 )
â€¢ If either ğ‘§1 or ğ‘§2 is a NaN, then return 0.
â€¢ Else if ğ‘§1 and ğ‘§2 are the same value, then return 1.
â€¢ Else if ğ‘§1 is positive infinity, then return 0.
â€¢ Else if ğ‘§1 is negative infinity, then return 1.
â€¢ Else if ğ‘§2 is positive infinity, then return 1.
â€¢ Else if ğ‘§2 is negative infinity, then return 0.
â€¢ Else if both ğ‘§1 and ğ‘§2 are zeroes, then return 1.
â€¢ Else if ğ‘§1 is smaller than or equal to ğ‘§2 , then return 1.
â€¢ Else return 0.
fleğ‘ (Â±nan(ğ‘›), ğ‘§2 ) = 0
fleğ‘ (ğ‘§1 , Â±nan(ğ‘›)) = 0
fleğ‘ (ğ‘§, ğ‘§)
= 1
fleğ‘ (+âˆ, ğ‘§2 )
= 0
fleğ‘ (âˆ’âˆ, ğ‘§2 )
= 1
fleğ‘ (ğ‘§1 , +âˆ)
= 1
fleğ‘ (ğ‘§1 , âˆ’âˆ)
= 0
fleğ‘ (Â±0, âˆ“0)
= 1
fleğ‘ (ğ‘§1 , ğ‘§2 )
= bool(ğ‘§1 â‰¤ ğ‘§2 )
fgeğ‘ (ğ‘§1 , ğ‘§2 )
â€¢ If either ğ‘§1 or ğ‘§2 is a NaN, then return 0.
â€¢ Else if ğ‘§1 and ğ‘§2 are the same value, then return 1.
â€¢ Else if ğ‘§1 is positive infinity, then return 1.
â€¢ Else if ğ‘§1 is negative infinity, then return 0.
â€¢ Else if ğ‘§2 is positive infinity, then return 0.
â€¢ Else if ğ‘§2 is negative infinity, then return 1.
â€¢ Else if both ğ‘§1 and ğ‘§2 are zeroes, then return 1.
â€¢ Else if ğ‘§1 is larger than or equal to ğ‘§2 , then return 1.
â€¢ Else return 0.
fgeğ‘ (Â±nan(ğ‘›), ğ‘§2 ) = 0
fgeğ‘ (ğ‘§1 , Â±nan(ğ‘›)) = 0
fgeğ‘ (ğ‘§, ğ‘§)
= 1
fgeğ‘ (+âˆ, ğ‘§2 )
= 1
fgeğ‘ (âˆ’âˆ, ğ‘§2 )
= 0
fgeğ‘ (ğ‘§1 , +âˆ)
= 0
fgeğ‘ (ğ‘§1 , âˆ’âˆ)
= 1
fgeğ‘ (Â±0, âˆ“0)
= 1
fgeğ‘ (ğ‘§1 , ğ‘§2 )
= bool(ğ‘§1 â‰¥ ğ‘§2 )
fpminğ‘ (ğ‘§1 , ğ‘§2 )
â€¢ If ğ‘§2 is less than ğ‘§1 then return ğ‘§2 .
â€¢ Else return ğ‘§1 .
fpminğ‘ (ğ‘§1 , ğ‘§2 )
fpminğ‘ (ğ‘§1 , ğ‘§2 )

108

= ğ‘§2
= ğ‘§1

(if fltğ‘ (ğ‘§2 , ğ‘§1 ) = 1)
(otherwise)

Chapter 4. Execution

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

fpmaxğ‘ (ğ‘§1 , ğ‘§2 )
â€¢ If ğ‘§1 is less than ğ‘§2 then return ğ‘§2 .
â€¢ Else return ğ‘§1 .
fpmaxğ‘ (ğ‘§1 , ğ‘§2 )
fpmaxğ‘ (ğ‘§1 , ğ‘§2 )

= ğ‘§2
= ğ‘§1

(if fltğ‘ (ğ‘§1 , ğ‘§2 ) = 1)
(otherwise)

4.3.4 Conversions
extendu ğ‘€,ğ‘ (ğ‘–)
â€¢ Return ğ‘–.
extendu ğ‘€,ğ‘ (ğ‘–)

=

ğ‘–

Ã² Note
In the abstract syntax, unsigned extension just reinterprets the same value.
extends ğ‘€,ğ‘ (ğ‘–)
â€¢ Let ğ‘— be the signed interpretation of ğ‘– of size ğ‘€ .
â€¢ Return the twoâ€™s complement of ğ‘— relative to size ğ‘ .
extends ğ‘€,ğ‘ (ğ‘–)

=

signedâˆ’1
ğ‘ (signedğ‘€ (ğ‘–))

wrapğ‘€,ğ‘ (ğ‘–)
â€¢ Return ğ‘– modulo 2ğ‘ .
wrapğ‘€,ğ‘ (ğ‘–)

= ğ‘– mod 2ğ‘

truncu ğ‘€,ğ‘ (ğ‘§)
â€¢ If ğ‘§ is a NaN, then the result is undefined.
â€¢ Else if ğ‘§ is an infinity, then the result is undefined.
â€¢ Else if ğ‘§ is a number and trunc(ğ‘§) is a value within range of the target type, then return that value.
â€¢ Else the result is undefined.
truncu ğ‘€,ğ‘ (Â±nan(ğ‘›))
truncu ğ‘€,ğ‘ (Â±âˆ)
truncu ğ‘€,ğ‘ (Â±ğ‘)
truncu ğ‘€,ğ‘ (Â±ğ‘)

=
=
=
=

{}
{}
trunc(Â±ğ‘)
{}

(if âˆ’1 < trunc(Â±ğ‘) < 2ğ‘ )
(otherwise)

Ã² Note
This operator is partial. It is not defined for NaNs, infinities, or values for which the result is out of range.
truncs ğ‘€,ğ‘ (ğ‘§)
â€¢ If ğ‘§ is a NaN, then the result is undefined.
â€¢ Else if ğ‘§ is an infinity, then the result is undefined.
â€¢ If ğ‘§ is a number and trunc(ğ‘§) is a value within range of the target type, then return that value.
â€¢ Else the result is undefined.

4.3. Numerics

109

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)
truncs ğ‘€,ğ‘ (Â±nan(ğ‘›))
truncs ğ‘€,ğ‘ (Â±âˆ)
truncs ğ‘€,ğ‘ (Â±ğ‘)
truncs ğ‘€,ğ‘ (Â±ğ‘)

=
=
=
=

{}
{}
trunc(Â±ğ‘)
{}

(if âˆ’2ğ‘ âˆ’1 âˆ’ 1 < trunc(Â±ğ‘) < 2ğ‘ âˆ’1 )
(otherwise)

Ã² Note
This operator is partial. It is not defined for NaNs, infinities, or values for which the result is out of range.
trunc_sat_uğ‘€,ğ‘ (ğ‘§)
â€¢ If ğ‘§ is a NaN, then return 0.
â€¢ Else if ğ‘§ is negative infinity, then return 0.
â€¢ Else if ğ‘§ is positive infinity, then return 2ğ‘ âˆ’ 1.
â€¢ Else, return sat_uğ‘ (trunc(ğ‘§)).
trunc_sat_uğ‘€,ğ‘ (Â±nan(ğ‘›))
trunc_sat_uğ‘€,ğ‘ (âˆ’âˆ)
trunc_sat_uğ‘€,ğ‘ (+âˆ)
trunc_sat_uğ‘€,ğ‘ (ğ‘§)

= 0
= 0
= 2ğ‘ âˆ’ 1
= sat_uğ‘ (trunc(ğ‘§))

trunc_sat_sğ‘€,ğ‘ (ğ‘§)
â€¢ If ğ‘§ is a NaN, then return 0.
â€¢ Else if ğ‘§ is negative infinity, then return âˆ’2ğ‘ âˆ’1 .
â€¢ Else if ğ‘§ is positive infinity, then return 2ğ‘ âˆ’1 âˆ’ 1.
â€¢ Else, return the value whose signed interpretation is sat_sğ‘ (trunc(ğ‘§)).
trunc_sat_sğ‘€,ğ‘ (Â±nan(ğ‘›))
trunc_sat_sğ‘€,ğ‘ (âˆ’âˆ)
trunc_sat_sğ‘€,ğ‘ (+âˆ)
trunc_sat_sğ‘€,ğ‘ (ğ‘§)

= 0
= âˆ’2ğ‘ âˆ’1
= 2ğ‘ âˆ’1 âˆ’ 1
= signedâˆ’1
ğ‘ (sat_sğ‘ (trunc(ğ‘§)))

promoteğ‘€,ğ‘ (ğ‘§)
â€¢ If ğ‘§ is a canonical NaN, then return an element of nansğ‘ {} (i.e., a canonical NaN of size ğ‘ ).
â€¢ Else if ğ‘§ is a NaN, then return an element of nansğ‘ {Â±nan(1)} (i.e., any arithmetic NaN of size ğ‘ ).
â€¢ Else, return ğ‘§.
promoteğ‘€,ğ‘ (Â±nan(ğ‘›)) = nansğ‘ {}
promoteğ‘€,ğ‘ (Â±nan(ğ‘›)) = nansğ‘ {+nan(1)}
promoteğ‘€,ğ‘ (ğ‘§)
= ğ‘§

(if ğ‘› = canonğ‘ )
(otherwise)

demoteğ‘€,ğ‘ (ğ‘§)
â€¢ If ğ‘§ is a canonical NaN, then return an element of nansğ‘ {} (i.e., a canonical NaN of size ğ‘ ).
â€¢ Else if ğ‘§ is a NaN, then return an element of nansğ‘ {Â±nan(1)} (i.e., any NaN of size ğ‘ ).
â€¢ Else if ğ‘§ is an infinity, then return that infinity.
â€¢ Else if ğ‘§ is a zero, then return that zero.
â€¢ Else, return floatğ‘ (ğ‘§).

110

Chapter 4. Execution

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)
demoteğ‘€,ğ‘ (Â±nan(ğ‘›)) = nansğ‘ {}
demoteğ‘€,ğ‘ (Â±nan(ğ‘›)) = nansğ‘ {+nan(1)}
demoteğ‘€,ğ‘ (Â±âˆ)
= Â±âˆ
demoteğ‘€,ğ‘ (Â±0)
= Â±0
demoteğ‘€,ğ‘ (Â±ğ‘)
= floatğ‘ (Â±ğ‘)

(if ğ‘› = canonğ‘ )
(otherwise)

convertu ğ‘€,ğ‘ (ğ‘–)
â€¢ Return floatğ‘ (ğ‘–).
convertu ğ‘€,ğ‘ (ğ‘–)

=

floatğ‘ (ğ‘–)

converts ğ‘€,ğ‘ (ğ‘–)
â€¢ Let ğ‘— be the signed interpretation of ğ‘–.
â€¢ Return floatğ‘ (ğ‘—).
converts ğ‘€,ğ‘ (ğ‘–)

=

floatğ‘ (signedğ‘€ (ğ‘–))

reinterpretğ‘¡1 ,ğ‘¡2 (ğ‘)
â€¢ Let ğ‘‘* be the bit sequence bitsğ‘¡1 (ğ‘).
â€¢ Return the constant ğ‘â€² for which bitsğ‘¡2 (ğ‘â€² ) = ğ‘‘* .
reinterpretğ‘¡1 ,ğ‘¡2 (ğ‘)

=

bitsâˆ’1
ğ‘¡2 (bitsğ‘¡1 (ğ‘))

narrows ğ‘€,ğ‘ (ğ‘–)
â€¢ Let ğ‘— be the signed interpretation of ğ‘– of size ğ‘€ .
â€¢ Return the value whose signed interpretation is sat_sğ‘ (ğ‘—).
narrows ğ‘€,ğ‘ (ğ‘–)

=

signedâˆ’1
ğ‘ (sat_sğ‘ (signedğ‘€ (ğ‘–)))

narrowu ğ‘€,ğ‘ (ğ‘–)
â€¢ Let ğ‘— be the signed interpretation of ğ‘– of size ğ‘€ .
â€¢ Return sat_uğ‘ (ğ‘—).
narrowu ğ‘€,ğ‘ (ğ‘–)

=

sat_uğ‘ (signedğ‘€ (ğ‘–))

4.3.5 Relaxed Operations
The result of relaxed operators are implementation-dependent, because the set of possible results may depend on
properties of the host environment, such as its hardware. Technically, their behaviour is controlled by a set of global
parameters to the semantics that an implementation can instantiate in different ways. These choices are fixed, that
is, parameters are constant during the execution of any given program.
Every such parameter is an index into a sequence of possible sets of results and must be instantiated to a defined
index. In the deterministic profile, every parameter is prescribed to be 0. This behaviour is expressed by the
following auxiliary function, where ğ‘… is a global parameter selecting one of the allowed outcomes:
[!DET]

relaxed(ğ‘…)[ğ´0 , . . . , ğ´ğ‘› ] = ğ´ğ‘…
relaxed(ğ‘…)[ğ´0 , . . . , ğ´ğ‘› ] = ğ´0

Ã² Note
Each parameter can be thought of as inducing a family of operations that is fixed to one particular choice by an
implementation. The fixed operation itself can still be non-deterministic or partial.

4.3. Numerics

111

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

Implementations are expexted to either choose the behaviour that is the most efficient on the underlying hardware, or the behaviour of the deterministic profile.
frelaxed_maddğ‘ (ğ‘§1 , ğ‘§2 , ğ‘§3 )
The implementation-specific behaviour of this operation is determined by the global parameter ğ‘…fmadd âˆˆ {0, 1}.
â€¢ Return relaxed(ğ‘…fmadd )[faddğ‘ (fmulğ‘ (ğ‘§1 , ğ‘§2 ), ğ‘§3 ) or fmağ‘ (ğ‘§1 , ğ‘§2 , ğ‘§3 )].
frelaxed_maddğ‘ (ğ‘§1 , ğ‘§2 , ğ‘§3 )

=

relaxed(ğ‘…fmadd )[faddğ‘ (fmulğ‘ (ğ‘§1 , ğ‘§2 ), ğ‘§3 ), fmağ‘ (ğ‘§1 , ğ‘§2 , ğ‘§3 )]

Ã² Note
Relaxed multiply-add allows for fused or unfused results, which leads to implementation-dependent rounding
behaviour. In the deterministic profile, the unfused behaviour is used.
frelaxed_nmaddğ‘ (ğ‘§1 , ğ‘§2 , ğ‘§3 )
â€¢ Return frelaxed_madd(âˆ’ğ‘§1 , ğ‘§2 , ğ‘§3 ).
frelaxed_nmaddğ‘ (ğ‘§1 , ğ‘§2 , ğ‘§3 )

=

frelaxed_maddğ‘ (âˆ’ğ‘§1 , ğ‘§2 , ğ‘§3 )

Ã² Note
This operation is implementation-dependent because frelaxed_madd is implementation-dependent.
frelaxed_minğ‘ (ğ‘§1 , ğ‘§2 )
The implementation-specific behaviour of this operation is determined by the global parameter ğ‘…fmin âˆˆ
{0, 1, 2, 3}.
â€¢ If ğ‘§1 is a NaN, then return relaxed(ğ‘…fmin )[fminğ‘ (ğ‘§1 , ğ‘§2 ), NAN(n), z_2, z_2 ]`.
â€¢ If ğ‘§2 is a NaN, then return relaxed(ğ‘…fmin )[fminğ‘ (ğ‘§1 , ğ‘§2 ), z_1, NAN(n), z_1 ]`.
â€¢ If both ğ‘§1 and ğ‘§2 are zeroes of opposite sign, then return relaxed(ğ‘…fmin )[fminğ‘ (ğ‘§1 , ğ‘§2 ), pm 0, mp 0, -0 ]`.
â€¢ Return fminğ‘ (ğ‘§1 , ğ‘§2 ).
frelaxed_minğ‘ (Â±nan(ğ‘›), ğ‘§2 ) = relaxed(ğ‘…fmin )[fminğ‘ (Â±nan(ğ‘›), ğ‘§2 ), nan(ğ‘›), ğ‘§2 , ğ‘§2 ]
frelaxed_minğ‘ (ğ‘§1 , Â±nan(ğ‘›)) = relaxed(ğ‘…fmin )[fminğ‘ (ğ‘§1 , Â±nan(ğ‘›)), ğ‘§1 , nan(ğ‘›), ğ‘§1 ]
frelaxed_minğ‘ (Â±0, âˆ“0)
= relaxed(ğ‘…fmin )[fminğ‘ (Â±0, âˆ“0), Â±0, âˆ“0, âˆ’0]
frelaxed_minğ‘ (ğ‘§1 , ğ‘§2 )
= fminğ‘ (ğ‘§1 , ğ‘§2 )

(otherwise)

Ã² Note
Relaxed minimum is implementation-dependent for NaNs and for zeroes with different signs. In the deterministic profile, it behaves like regular fmin.
frelaxed_maxğ‘ (ğ‘§1 , ğ‘§2 )
The implementation-specific behaviour of this operation is determined by the global parameter ğ‘…fmax âˆˆ
{0, 1, 2, 3}.
â€¢ If ğ‘§1 is a NaN, then return relaxed(ğ‘…fmax )[fmaxğ‘ (ğ‘§1 , ğ‘§2 ), NAN(n), z_2, z_2 ]`.
â€¢ If ğ‘§2 is a NaN, then return relaxed(ğ‘…fmax )[fmaxğ‘ (ğ‘§1 , ğ‘§2 ), z_1, NAN(n), z_1 ]`.
â€¢ If both ğ‘§1 and ğ‘§2 are zeroes of opposite sign, then return relaxed(ğ‘…fmax )[fmaxğ‘ (ğ‘§1 , ğ‘§2 ), pm 0, mp 0, +0 ]`.
112

Chapter 4. Execution

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

â€¢ Return fmaxğ‘ (ğ‘§1 , ğ‘§2 ).
frelaxed_maxğ‘ (Â±nan(ğ‘›), ğ‘§2 ) = relaxed(ğ‘…fmax )[fmaxğ‘ (Â±nan(ğ‘›), ğ‘§2 ), nan(ğ‘›), ğ‘§2 , ğ‘§2 ]
frelaxed_maxğ‘ (ğ‘§1 , Â±nan(ğ‘›)) = relaxed(ğ‘…fmax )[fmaxğ‘ (ğ‘§1 , Â±nan(ğ‘›)), ğ‘§1 , nan(ğ‘›), ğ‘§1 ]
frelaxed_maxğ‘ (Â±0, âˆ“0)
= relaxed(ğ‘…fmax )[fmaxğ‘ (Â±0, âˆ“0), Â±0, âˆ“0, +0]
frelaxed_maxğ‘ (ğ‘§1 , ğ‘§2 )
= fmaxğ‘ (ğ‘§1 , ğ‘§2 )

(otherwise)

Ã² Note
Relaxed maximum is implementation-dependent for NaNs and for zeroes with different signs. In the deterministic profile, it behaves like regular fmax.
irelaxed_dot_mulğ‘€,ğ‘ (ğ‘–1 , ğ‘–2 )
This is an auxiliary operator for the specification of relaxed_dot.
The implementation-specific behaviour of this operation is determined by the global parameter ğ‘…idot âˆˆ {0, 1}.
â€¢ Return relaxed(ğ‘…idot )[imulğ‘ (extends ğ‘€,ğ‘ (ğ‘–1 ), extends ğ‘€,ğ‘ (ğ‘–2 )), imulğ‘ (extends ğ‘€,ğ‘ (ğ‘–1 ), extendu ğ‘€,ğ‘ (ğ‘–2 ))].
irelaxed_dot_mulğ‘€,ğ‘ (ğ‘–1 , ğ‘–2 )

=

relaxed(ğ‘…idot )[imulğ‘ (extends ğ‘€,ğ‘ (ğ‘–1 ), extends ğ‘€,ğ‘ (ğ‘–2 )), imulğ‘ (extends ğ‘€,ğ‘ (ğ‘–1 ), extendu ğ‘€

Ã² Note
Relaxed dot product is implementation-dependent when the second operand is negative in a signed intepretation. In the deterministic profile, it behaves like signed dot product.
irelaxed_q15mulr_sğ‘ (ğ‘–1 , ğ‘–2 )
The implementation-specific behaviour of this operation is determined by the global parameter ğ‘…iq15mulr âˆˆ {0, 1}.
ğ‘ âˆ’1
ğ‘ âˆ’1
â€¢ If both ğ‘–1 and ğ‘–2 equal (signedâˆ’1
), then return relaxed(ğ‘…iq15mulr )[2ğ‘ âˆ’1 âˆ’ 1, signedâˆ’1
)].
ğ‘ (âˆ’2
ğ‘ (âˆ’2

â€¢ Return iq15mulrsat_s(ğ‘–1 , ğ‘–2 )
ğ‘ âˆ’1
ğ‘ âˆ’1
irelaxed_q15mulr_sğ‘ (signedâˆ’1
), signedâˆ’1
))
ğ‘ (âˆ’2
ğ‘ (âˆ’2
irelaxed_q15mulr_sğ‘ (ğ‘–1 , ğ‘–2 )

ğ‘ âˆ’1
= relaxed(ğ‘…iq15mulr )[2ğ‘ âˆ’1 âˆ’ 1, signedâˆ’1
)]
ğ‘ (âˆ’2
= iq15mulrsat_s(ğ‘–1 , ğ‘–2 )

Ã² Note
Relaxed Q15 multiplication is implementation-dependent when the result overflows. In the deterministic profile, it behaves like regular iq15mulrsat_s.
relaxed_truncğ‘¢ğ‘€,ğ‘ (ğ‘§)
The implementation-specific behaviour of this operation is determined by the global parameter ğ‘…trunc_u âˆˆ {0, 1}.
â€¢ If ğ‘§ is normal or subnormal and trunc(ğ‘§) is non-negative and less than 2ğ‘ , then return truncu ğ‘€,ğ‘ (ğ‘§).
â€¢ Else, return relaxed(ğ‘…trunc_u )[trunc_sat_uğ‘€,ğ‘ (ğ‘§), R].
relaxed_truncğ‘¢ğ‘€,ğ‘ (Â±ğ‘) = truncu ğ‘€,ğ‘ (Â±ğ‘)
relaxed_truncğ‘¢ğ‘€,ğ‘ (ğ‘§)
= relaxed(ğ‘…trunc_u )[trunc_sat_uğ‘€,ğ‘ (ğ‘§), R]

(if 0 â‰¤ trunc(Â±ğ‘) < 2ğ‘ )
(otherwise)

Ã² Note
Relaxed unsigned truncation is non-deterministic for NaNs and out-of-range values. In the deterministic profile,
it behaves like regular trunc_sat_u.

4.3. Numerics

113

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

relaxed_truncğ‘ ğ‘€,ğ‘ (ğ‘§)
The implementation-specific behaviour of this operation is determined by the global parameter ğ‘…trunc_s âˆˆ {0, 1}.
â€¢ If ğ‘§ is normal or subnormal and trunc(ğ‘§) is greater than or equal to âˆ’2ğ‘ âˆ’1 and less than 2ğ‘ âˆ’1 , then return
truncs ğ‘€,ğ‘ (ğ‘§).
â€¢ Else, return relaxed(ğ‘…trunc_s )[trunc_sat_sğ‘€,ğ‘ (ğ‘§), R].
relaxed_truncğ‘ ğ‘€,ğ‘ (Â±ğ‘) = truncs ğ‘€,ğ‘ (Â±ğ‘)
relaxed_truncğ‘ ğ‘€,ğ‘ (ğ‘§)
= relaxed(ğ‘…trunc_s )[trunc_sat_sğ‘€,ğ‘ (ğ‘§), R]

(if âˆ’2ğ‘ âˆ’1 â‰¤ trunc(Â±ğ‘) < 2ğ‘ âˆ’1 )
(otherwise)

Ã² Note
Relaxed signed truncation is non-deterministic for NaNs and out-of-range values. In the deterministic profile,
it behaves like regular trunc_sat_s.
frelaxed_swizzle(ğ‘–ğ‘› , ğ‘— ğ‘› )
The implementation-specific behaviour of this operation is determined by the global parameter ğ‘…swizzle âˆˆ {0, 1}.
â€¢ For each ğ‘—ğ‘˜ in ğ‘— ğ‘› , let ğ‘Ÿğ‘˜ be the value frelaxed_swizzle_lane(ğ‘–ğ‘› , ğ‘—ğ‘˜ ).
â€¢ Let ğ‘Ÿğ‘› be the concatenation of all ğ‘Ÿğ‘˜ .
â€¢ Return ğ‘Ÿğ‘› .
frelaxed_swizzle(ğ‘–ğ‘› , ğ‘— ğ‘› )

=

frelaxed_swizzle_lane(ğ‘–ğ‘› , ğ‘—)ğ‘›

where:
frelaxed_swizzle_lane(ğ‘–ğ‘› , ğ‘—) = ğ‘–[ğ‘—]
frelaxed_swizzle_lane(ğ‘–ğ‘› , ğ‘—) = 0
frelaxed_swizzle_lane(ğ‘–ğ‘› , ğ‘—) = relaxed(ğ‘…swizzle )[0, ğ‘–ğ‘› [ğ‘— mod ğ‘›]]

(if ğ‘— < 16)
(if signed8 (ğ‘—) < 0)
(otherwise)

Ã² Note
Relaxed swizzle is implementation-dependent if the signed interpretation of any of the 8-bit indices in ğ‘— ğ‘› is
larger than or equal to 16. In the deterministic profile, it behaves like regular swizzle.
irelaxed_laneselectğ‘ (ğ‘–1 , ğ‘–2 , ğ‘–3 )
The implementation-specific behaviour of this operation is determined by the global parameter ğ‘…laneselect âˆˆ {0, 1}.
â€¢ If ğ‘–3 is smaller than 2ğ‘ âˆ’1 , then let ğ‘–â€²3 be the value 0, otherwise 2ğ‘ âˆ’ 1.
â€¢ Let ğ‘–â€²â€²3 be relaxed(ğ‘…laneselect )[ğ‘–3 , ğ‘–â€²3 ].
â€¢ Return ibitselectğ‘ (ğ‘–1 , ğ‘–2 , ğ‘–â€²â€²3 ).
irelaxed_laneselectğ‘ (ğ‘–1 , ğ‘–2 , ğ‘–3 )

=

ibitselectğ‘ (ğ‘–1 , ğ‘–2 , relaxed(ğ‘…laneselect )[ğ‘–3 , extends 1,ğ‘ (ishr_uğ‘ (ğ‘–3 , ğ‘ âˆ’ 1))])

Ã² Note
Relaxed lane selection is non-deterministic when the mask mixes set and cleared bits, since the value of the
high bit may or may not be expanded to all bits. In the deterministic profile, it behaves like ibitselect.

114

Chapter 4. Execution

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

4.4 Types
Execution has to check and compare types in a few places, such as executing call_indirect or instantiating modules.
It is an invariant of the semantics that all types occurring during execution are closed.
Ã² Note
Runtime type checks generally involve types from multiple modules or types not defined by a module at all,
such that module-local type indices are not meaningful.

4.4.1 Instantiation
Any form of type can be instantiated into a closed type inside a module instance by substituting each type index ğ‘¥
occurring in it with the corresponding defined type moduleinst.types[ğ‘¥].
closmoduleinst (ğ‘¡) = ğ‘¡[:= moduleinst.types]

Ã² Note
This is the runtime equivalent to type closure.

4.5 Values
4.5.1 Value Typing
For the purpose of checking argument values against the parameter types of exported functions, values are classified
by value types. The following auxiliary typing rules specify this typing relation relative to a store ğ‘† in which
possibly referenced addresses live.
Numeric Values ğ‘¡.const ğ‘
â€¢ The value is valid with number type ğ‘¡.
ğ‘† âŠ¢ ğ‘¡.const ğ‘ : ğ‘¡
Vector Values ğ‘¡.const ğ‘
â€¢ The value is valid with vector type ğ‘¡.
ğ‘† âŠ¢ ğ‘¡.const ğ‘ : ğ‘¡
Null References ref.null ğ‘¡
â€¢ The heap type must be valid under the empty context.
â€¢ Then the value is valid with reference type (ref null ğ‘¡â€² ), where the heap type ğ‘¡â€² is the least type that matches
ğ‘¡.
âŠ¢ ğ‘¡ ok
ğ‘¡â€² âˆˆ {none, nofunc, noexn, noextern}
âŠ¢ ğ‘¡â€² â‰¤ ğ‘¡
â€²
ğ‘† âŠ¢ ref.null ğ‘¡ : (ref null ğ‘¡ )
Ã² Note
A null reference is typed with the least type in its respective hierarchy. That ensures that it is compatible with
any nullable type in that hierarchy.

4.4. Types

115

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

Scalar References ref.i31 ğ‘–
â€¢ The value is valid with reference type (ref i31).
ğ‘† âŠ¢ ref.i31 ğ‘– : ref i31
Structure References ref.struct ğ‘
â€¢ The structure address ğ‘ must exist in the store.
â€¢ Let structinst be the structure instance ğ‘†.structs[ğ‘].
â€¢ Let deftype be the defined type structinst.type.
â€¢ The expansion of deftype must be a struct type.
â€¢ Then the value is valid with reference type (ref deftype).
deftype = ğ‘†.structs[ğ‘].type
expand(deftype) = struct structtype
ğ‘† âŠ¢ ref.struct ğ‘ : ref deftype
Array References ref.array ğ‘
â€¢ The array address ğ‘ must exist in the store.
â€¢ Let arrayinst be the array instance ğ‘†.arrays[ğ‘].
â€¢ Let deftype be the defined type arrayinst.type.
â€¢ The expansion of deftype must be an array type.
â€¢ Then the value is valid with reference type (ref arraytype).
deftype = ğ‘†.arrays[ğ‘].type
expand(deftype) = array arraytype
ğ‘† âŠ¢ ref.array ğ‘ : ref deftype
Exception References ref.exn ğ‘
â€¢ The store entry ğ‘†.exns[ğ‘] must exist.
â€¢ Then the value is valid with reference type exnref.
ğ‘†.exns[ğ‘] = exninst
ğ‘† âŠ¢ ref.exn : exnref
Function References ref.func ğ‘
â€¢ The function address ğ‘ must exist in the store.
â€¢ Let funcinst be the function instance ğ‘†.funcs[ğ‘].
â€¢ Let deftype be the defined type funcinst.type.
â€¢ The expansion of deftype must be a function type.
â€¢ Then the value is valid with reference type (ref functype).
deftype = ğ‘†.funcs[ğ‘].type
expand(deftype) = func functype
ğ‘† âŠ¢ ref.func ğ‘ : ref deftype
Host References ref.host ğ‘
â€¢ The value is valid with reference type (ref any).
ğ‘† âŠ¢ ref.host ğ‘ : ref any

116

Chapter 4. Execution

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

Ã² Note
A host reference is considered internalized by this rule.
External References ref.extern ref
â€¢ The reference value ref must be valid with some reference type (ref null? ğ‘¡).
â€¢ The heap type ğ‘¡ must match the heap type any.
â€¢ Then the value is valid with reference type (ref null? extern).
ğ‘† âŠ¢ ref : ref null? ğ‘¡
âŠ¢ ğ‘¡ â‰¤ any
ğ‘† âŠ¢ ref.extern ref : ref null? extern
Subsumption
â€¢ The value must be valid with some value type ğ‘¡.
â€¢ The value type ğ‘¡ matches another valid type ğ‘¡â€² .
â€¢ Then the value is valid with type ğ‘¡â€² .
ğ‘† âŠ¢ val : ğ‘¡

âŠ¢ ğ‘¡â€² ok
ğ‘† âŠ¢ val : ğ‘¡â€²

âŠ¢ ğ‘¡ â‰¤ ğ‘¡â€²

4.5.2 External Typing
For the purpose of checking external values against imports, such values are classified by external types. The
following auxiliary typing rules specify this typing relation relative to a store ğ‘† in which the referenced instances
live.
func ğ‘
â€¢ The store entry ğ‘†.funcs[ğ‘] must exist.
â€¢ Then func ğ‘ is valid with external type func ğ‘†.funcs[ğ‘].type.
ğ‘† âŠ¢ func ğ‘ : func ğ‘†.funcs[ğ‘].type

table ğ‘
â€¢ The store entry ğ‘†.tables[ğ‘] must exist.
â€¢ Then table ğ‘ is valid with external type table ğ‘†.tables[ğ‘].type.
ğ‘† âŠ¢ table ğ‘ : table ğ‘†.tables[ğ‘].type

mem ğ‘
â€¢ The store entry ğ‘†.mems[ğ‘] must exist.
â€¢ Then mem ğ‘ is valid with external type mem ğ‘†.mems[ğ‘].type.
ğ‘† âŠ¢ mem ğ‘ : mem ğ‘†.mems[ğ‘].type

4.5. Values

117

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

global ğ‘
â€¢ The store entry ğ‘†.globals[ğ‘] must exist.
â€¢ Then global ğ‘ is valid with external type global ğ‘†.globals[ğ‘].type.
ğ‘† âŠ¢ global ğ‘ : global ğ‘†.globals[ğ‘].type

tag ğ‘
â€¢ The store entry ğ‘†.tags[ğ‘] must exist.
â€¢ Let tagtype be the function type ğ‘†.tags[ğ‘].type.
â€¢ Then tag ğ‘ is valid with external type tag tagtype.
ğ‘† âŠ¢ tag ğ‘ : tag ğ‘†.tags[ğ‘].type
Subsumption
â€¢ The external value must be valid with some external type et.
â€¢ The external type et matches another valid type et â€² .
â€¢ Then the external value is valid with type et â€² .
ğ‘† âŠ¢ externval : et
âŠ¢ et â€² ok
ğ‘† âŠ¢ externval : et â€²

âŠ¢ et â‰¤ et â€²

4.6 Instructions
WebAssembly computation is performed by executing individual instructions.

4.6.1 Numeric Instructions
Numeric instructions are defined in terms of the generic numeric operators. The mapping of numeric instructions
to their underlying operators is expressed by the following definition:
op iğ‘ (ğ‘–1 , . . . , ğ‘–ğ‘˜ )
op fğ‘ (ğ‘§1 , . . . , ğ‘§ğ‘˜ )

= iop ğ‘ (ğ‘–1 , . . . , ğ‘–ğ‘˜ )
= fop ğ‘ (ğ‘§1 , . . . , ğ‘§ğ‘˜ )

And for conversion operators:
?

cvtop sx
ğ‘¡1 ,ğ‘¡2 (ğ‘)

?

= cvtop sx
|ğ‘¡1 |,|ğ‘¡2 | (ğ‘)

Where the underlying operators are partial, the corresponding instruction will trap when the result is not defined.
Where the underlying operators are non-deterministic, because they may return one of multiple possible NaN
values, so are the corresponding instructions.
Ã² Note
For example, the result of instruction i32.add applied to operands ğ‘–1 , ğ‘–2 invokes addi32 (ğ‘–1 , ğ‘–2 ), which maps to the
generic iadd32 (ğ‘–1 , ğ‘–2 ) via the above definition. Similarly, i64.trunc_f32_s applied to ğ‘§ invokes truncsf32,i64 (ğ‘§),
which maps to the generic truncs 32,64 (ğ‘§).
ğ‘¡.const ğ‘
1. Push the value ğ‘¡.const ğ‘ to the stack.

118

Chapter 4. Execution

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

Ã² Note
No formal reduction rule is required for this instruction, since const instructions already are values.
ğ‘¡.unop
1. Assert: due to validation, a value of value type ğ‘¡ is on the top of the stack.
2. Pop the value ğ‘¡.const ğ‘1 from the stack.
3. If unop ğ‘¡ (ğ‘1 ) is defined, then:
a. Let ğ‘ be a possible result of computing unop ğ‘¡ (ğ‘1 ).
b. Push the value ğ‘¡.const ğ‘ to the stack.
4. Else:
a. Trap.
(ğ‘¡.const ğ‘1 ) ğ‘¡.unop
(ğ‘¡.const ğ‘1 ) ğ‘¡.unop

Ë“â†’ (ğ‘¡.const ğ‘)
Ë“â†’ trap

(if ğ‘ âˆˆ unop ğ‘¡ (ğ‘1 ))
(if unop ğ‘¡ (ğ‘1 ) = {})

ğ‘¡.binop
1. Assert: due to validation, two values of value type ğ‘¡ are on the top of the stack.
2. Pop the value ğ‘¡.const ğ‘2 from the stack.
3. Pop the value ğ‘¡.const ğ‘1 from the stack.
4. If binop ğ‘¡ (ğ‘1 , ğ‘2 ) is defined, then:
a. Let ğ‘ be a possible result of computing binop ğ‘¡ (ğ‘1 , ğ‘2 ).
b. Push the value ğ‘¡.const ğ‘ to the stack.
5. Else:
a. Trap.
(ğ‘¡.const ğ‘1 ) (ğ‘¡.const ğ‘2 ) ğ‘¡.binop
(ğ‘¡.const ğ‘1 ) (ğ‘¡.const ğ‘2 ) ğ‘¡.binop

Ë“â†’ (ğ‘¡.const ğ‘)
Ë“â†’ trap

(if ğ‘ âˆˆ binop ğ‘¡ (ğ‘1 , ğ‘2 ))
(if binop ğ‘¡ (ğ‘1 , ğ‘2 ) = {})

ğ‘¡.testop
1. Assert: due to validation, a value of value type ğ‘¡ is on the top of the stack.
2. Pop the value ğ‘¡.const ğ‘1 from the stack.
3. Let ğ‘ be the result of computing testop ğ‘¡ (ğ‘1 ).
4. Push the value i32.const ğ‘ to the stack.
(ğ‘¡.const ğ‘1 ) ğ‘¡.testop

Ë“â†’ (i32.const ğ‘)

(if ğ‘ = testop ğ‘¡ (ğ‘1 ))

ğ‘¡.relop
1. Assert: due to validation, two values of value type ğ‘¡ are on the top of the stack.
2. Pop the value ğ‘¡.const ğ‘2 from the stack.
3. Pop the value ğ‘¡.const ğ‘1 from the stack.
4. Let ğ‘ be the result of computing relop ğ‘¡ (ğ‘1 , ğ‘2 ).
5. Push the value i32.const ğ‘ to the stack.
(ğ‘¡.const ğ‘1 ) (ğ‘¡.const ğ‘2 ) ğ‘¡.relop

4.6. Instructions

Ë“â†’ (i32.const ğ‘)

(if ğ‘ = relop ğ‘¡ (ğ‘1 , ğ‘2 ))

119

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

ğ‘¡2 .cvtop_ğ‘¡1 _sx ?
1. Assert: due to validation, a value of value type ğ‘¡1 is on the top of the stack.
2. Pop the value ğ‘¡1 .const ğ‘1 from the stack.
?

3. If cvtop sx
ğ‘¡1 ,ğ‘¡2 (ğ‘1 ) is defined:
?

a. Let ğ‘2 be a possible result of computing cvtop sx
ğ‘¡1 ,ğ‘¡2 (ğ‘1 ).
b. Push the value ğ‘¡2 .const ğ‘2 to the stack.
4. Else:
a. Trap.
(ğ‘¡1 .const ğ‘1 ) ğ‘¡2 .cvtop_ğ‘¡1 _sx ?
(ğ‘¡1 .const ğ‘1 ) ğ‘¡2 .cvtop_ğ‘¡1 _sx ?

Ë“â†’ (ğ‘¡2 .const ğ‘2 )
Ë“â†’ trap

?

(if ğ‘2 âˆˆ cvtop sx
ğ‘¡1 ,ğ‘¡2 (ğ‘1 ))
sx ?
(if cvtop ğ‘¡1 ,ğ‘¡2 (ğ‘1 ) = {})

4.6.2 Reference Instructions
ref.null ğ‘¥
1. Let ğ¹ be the current frame.
2. Assert: due to validation, the defined type ğ¹.module.types[ğ‘¥] exists.
3. Let deftype be the defined type ğ¹.module.types[ğ‘¥].
4. Push the value ref.null deftype to the stack.
ğ¹ ; (ref.null ğ‘¥) Ë“â†’ ğ¹ ; (ref.null deftype)

(if deftype = ğ¹.module.types[ğ‘¥])

Ã² Note
No formal reduction rule is required for the case ref.null absheaptype, since the instruction form is already a
value.
ref.func ğ‘¥
1. Let ğ¹ be the current frame.
2. Assert: due to validation, ğ¹.module.funcaddrs[ğ‘¥] exists.
3. Let ğ‘ be the function address ğ¹.module.funcaddrs[ğ‘¥].
4. Push the value ref.func ğ‘ to the stack.
ğ¹ ; (ref.func ğ‘¥) Ë“â†’ ğ¹ ; (ref.func ğ‘)

(if ğ‘ = ğ¹.module.funcaddrs[ğ‘¥])

ref.is_null
1. Assert: due to validation, a reference value is on the top of the stack.
2. Pop the value ref from the stack.
3. If ref is ref.null ht, then:
a. Push the value i32.const 1 to the stack.
4. Else:
a. Push the value i32.const 0 to the stack.
ref ref.is_null Ë“â†’ (i32.const 1)
ref ref.is_null Ë“â†’ (i32.const 0)

120

(if ref = ref.null ht)
(otherwise)

Chapter 4. Execution

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

ref.as_non_null
1. Assert: due to validation, a reference value is on the top of the stack.
2. Pop the value ref from the stack.
3. If ref is ref.null ht, then:
a. Trap.
4. Push the value ref back to the stack.
ref ref.as_non_null Ë“â†’ trap
ref ref.as_non_null Ë“â†’ ref

(if ref = ref.null ht)
(otherwise)

ref.eq
1. Assert: due to validation, two reference values are on the top of the stack.
2. Pop the value ref 2 from the stack.
3. Pop the value ref 1 from the stack.
4. If ref 1 is the same as ref 2 , then:
a. Push the value i32.const 1 to the stack.
5. Else:
a. Push the value i32.const 0 to the stack.
ref 1 ref 2 ref.eq
ref 1 ref 2 ref.eq
ref 1 ref 2 ref.eq

Ë“â†’ (i32.const 1)
Ë“â†’ (i32.const 1)
Ë“â†’ (i32.const 0)

(if ref 1 = (ref.null ht 1 ) âˆ§ ref 2 = (ref.null ht 2 ))
(if ref 1 = ref 2 )
(otherwise)

ref.test rt
1. Let ğ¹ be the current frame.
2. Let rt 1 be the reference type closğ¹.module (rt).
3. Assert: due to validation, rt 1 is closed.
4. Assert: due to validation, a reference value is on the top of the stack.
5. Pop the value ref from the stack.
6. Assert: due to validation, the reference value is valid with some reference type.
7. Let rt 2 be the reference type of ref .
8. If the reference type rt 2 matches rt 1 , then:
a. Push the value i32.const 1 to the stack.
9. Else:
a. Push the value i32.const 0 to the stack.
ğ‘†; ğ¹ ; ref (ref.test rt) Ë“â†’ (i32.const 1)
ğ‘†; ğ¹ ; ref (ref.test rt) Ë“â†’ (i32.const 0)

(if ğ‘† âŠ¢ ref : rt â€² âˆ§ âŠ¢ rt â€² â‰¤ closğ¹.module (rt))
(otherwise)

ref.cast rt
1. Let ğ¹ be the current frame.
2. Let rt 1 be the reference type closğ¹.module (rt).
3. Assert: due to validation, rt 1 is closed.
4. Assert: due to validation, a reference value is on the top of the stack.
5. Pop the value ref from the stack.

4.6. Instructions

121

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

6. Assert: due to validation, the reference value is valid with some reference type.
7. Let rt 2 be the reference type of ref .
8. If the reference type rt 2 matches rt 1 , then:
a. Push the value ref back to the stack.
9. Else:
a. Trap.
(if ğ‘† âŠ¢ ref : rt â€² âˆ§ âŠ¢ rt â€² â‰¤ closğ¹.module (rt))
(otherwise)

ğ‘†; ğ¹ ; ref (ref.cast rt) Ë“â†’ ref
ğ‘†; ğ¹ ; ref (ref.cast rt) Ë“â†’ trap
ref.i31

1. Assert: due to validation, a value of type i32 is on the top of the stack.
2. Pop the value i32.const ğ‘– from the stack.
3. Let ğ‘— be the result of computing wrap32,31 (ğ‘–).
4. Push the reference value (ref.i31 ğ‘—) to the stack.
(i32.const ğ‘–) ref.i31 Ë“â†’

(ref.i31 wrap32,31 (ğ‘–))

i31.get_sx
1. Assert: due to validation, a value of type (ref null i31) is on the top of the stack.
2. Pop the value ref from the stack.
3. If ref is ref.null ğ‘¡, then:
a. Trap.
4. Assert: due to validation, a ref is a scalar reference.
5. Let ref.i31 ğ‘– be the reference value ref .
6. Let ğ‘— be the result of computing extendsx
31,32 (ğ‘–).
7. Push the value i32.const ğ‘— to the stack.
(ref.i31 ğ‘–) i31.get_sx
(ref.null ğ‘¡) i31.get_sx

Ë“â†’ (i32.const extendsx
31,32 (ğ‘–))
Ë“â†’ trap

struct.new ğ‘¥
1. Let ğ¹ be the current frame.
2. Assert: due to validation, the defined type ğ¹.module.types[ğ‘¥] exists.
3. Let deftype be the defined type ğ¹.module.types[ğ‘¥].
4. Assert: due to validation, the expansion of deftype is a structure type.
5. Let struct ft * be the expanded structure type of deftype.
6. Let ğ‘› be the length of the field type sequence ft * .
7. Assert: due to validation, ğ‘› values are on the top of the stack.
8. Pop the ğ‘› values val * from the stack.
9. For every value val ğ‘– in val * and corresponding field type ft ğ‘– in ft * :
a. Let fieldval ğ‘– be the result of computing packft ğ‘– (val ğ‘– )).
10. Let fieldval * the concatenation of all field values fieldval ğ‘– .
11. Let si be the structure instance {type deftype, fields fieldval * }.

122

Chapter 4. Execution

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

12. Let ğ‘ be the length of ğ‘†.structs.
13. Append si to ğ‘†.structs.
14. Push the structure reference ref.struct ğ‘ to the stack.
ğ‘†; ğ¹ ; val ğ‘› (struct.new ğ‘¥) Ë“â†’ ğ‘† â€² ; ğ¹ ; (ref.struct |ğ‘†.structs|)
(if expand(ğ¹.module.types[ğ‘¥]) = struct ft ğ‘›
âˆ§ si = {type ğ¹.module.types[ğ‘¥], fields (packft (val ))ğ‘› }
âˆ§ ğ‘† â€² = ğ‘† with structs = ğ‘†.structs si )
struct.new_default ğ‘¥
1. Let ğ¹ be the current frame.
2. Assert: due to validation, the defined type ğ¹.module.types[ğ‘¥] exists.
3. Let deftype be the defined type ğ¹.module.types[ğ‘¥].
4. Assert: due to validation, the expansion of deftype is a structure type.
5. Let struct ft * be the expanded structure type of deftype.
6. Let ğ‘› be the length of the field type sequence ft * .
7. For every field type ft ğ‘– in ft * :
a. Let ğ‘¡ğ‘– be the value type unpack(ft ğ‘– ).
b. Assert: due to validation, defaultğ‘¡ğ‘– is defined.
c. Push the value defaultğ‘¡ğ‘– to the stack.
8. Execute the instruction (struct.new ğ‘¥).
ğ¹ ; (struct.new_default ğ‘¥) Ë“â†’

(defaultunpack(ft) ))ğ‘› (struct.new ğ‘¥)
(if expand(ğ¹.module.types[ğ‘¥]) = struct ft ğ‘› )

struct.get_sx ? ğ‘¥ ğ‘¦
1. Let ğ¹ be the current frame.
2. Assert: due to validation, the defined type ğ¹.module.types[ğ‘¥] exists.
3. Let deftype be the defined type ğ¹.module.types[ğ‘¥].
4. Assert: due to validation, the expansion of deftype is a structure type with at least ğ‘¦ + 1 fields.
5. Let struct ft * be the expanded structure type of deftype.
6. Let ft ğ‘¦ be the ğ‘¦-th field type of ft * .
7. Assert: due to validation, a value of type (ref null ğ‘¥) is on the top of the stack.
8. Pop the value ref from the stack.
9. If ref is ref.null ğ‘¡, then:
a. Trap.
10. Assert: due to validation, a ref is a structure reference.
11. Let ref.struct ğ‘ be the reference value ref .
12. Assert: due to validation, the structure instance ğ‘†.structs[ğ‘] exists and has at least ğ‘¦ + 1 fields.
13. Let fieldval be the field value ğ‘†.structs[ğ‘].fields[ğ‘¦].
?

14. Let val be the result of computing unpacksx
ft ğ‘¦ (fieldval )).
15. Push the value val to the stack.

4.6. Instructions

123

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)
(if expand(ğ¹.module.types[ğ‘¥]) = struct ft ğ‘›
?
âˆ§ val = unpacksx
ft ğ‘› [ğ‘¦] (ğ‘†.structs[ğ‘].fields[ğ‘¦]))

ğ‘†; ğ¹ ; (ref.struct ğ‘) (struct.get_sx ? ğ‘¥ ğ‘¦) Ë“â†’ val
ğ‘†; ğ¹ ; (ref.null ğ‘¡) (struct.get_sx ? ğ‘¥ ğ‘¦)

Ë“â†’ trap

struct.set ğ‘¥ ğ‘¦
1. Let ğ¹ be the current frame.
2. Assert: due to validation, the defined type ğ¹.module.types[ğ‘¥] exists.
3. Let deftype be the defined type ğ¹.module.types[ğ‘¥].
4. Assert: due to validation, the expansion of deftype is a structure type with at least ğ‘¦ + 1 fields.
5. Let struct ft * be the expanded structure type of deftype.
6. Let ft ğ‘¦ be the ğ‘¦-th field type of ft * .
7. Assert: due to validation, a value is on the top of the stack.
8. Pop the value val from the stack.
9. Assert: due to validation, a value of type (ref null ğ‘¥) is on the top of the stack.
10. Pop the value ref from the stack.
11. If ref is ref.null ğ‘¡, then:
a. Trap.
12. Assert: due to validation, a ref is a structure reference.
13. Let ref.struct ğ‘ be the reference value ref .
14. Assert: due to validation, the structure instance ğ‘†.structs[ğ‘] exists and has at least ğ‘¦ + 1 fields.
15. Let fieldval be the result of computing packft ğ‘¦ (val )).
16. Replace the field value ğ‘†.structs[ğ‘].fields[ğ‘¦] with fieldval .
ğ‘†; ğ¹ ; (ref.struct ğ‘) val (struct.set ğ‘¥ ğ‘¦) Ë“â†’ ğ‘† â€² ; ğœ–
ğ‘†; ğ¹ ; (ref.null ğ‘¡) val (struct.set ğ‘¥ ğ‘¦)

(if expand(ğ¹.module.types[ğ‘¥]) = struct ft ğ‘›
âˆ§ ğ‘† â€² = ğ‘† with structs[ğ‘].fields[ğ‘¦] = packft ğ‘› [ğ‘¦] (val ))

Ë“â†’ trap

array.new ğ‘¥
1. Assert: due to validation, a value of type i32 is on the top of the stack.
2. Pop the value (i32.const ğ‘›) from the stack.
3. Assert: due to validation, a value is on the top of the stack.
4. Pop the value val from the stack.
5. Push the value val to the stack ğ‘› times.
6. Execute the instruction (array.new_fixed ğ‘¥ ğ‘›).
val (i32.const ğ‘›) (array.new ğ‘¥) Ë“â†’ val ğ‘› (array.new_fixed ğ‘¥ ğ‘›)
array.new_default ğ‘¥
1. Let ğ¹ be the current frame.
2. Assert: due to validation, the defined type ğ¹.module.types[ğ‘¥] exists.
3. Let deftype be the defined type ğ¹.module.types[ğ‘¥].
4. Assert: due to validation, the expansion of deftype is an array type.
5. Let array ft be the expanded array type of deftype.
6. Assert: due to validation, a value of type i32 is on the top of the stack.
124

Chapter 4. Execution

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

7. Pop the value i32.const ğ‘› from the stack.
8. Let ğ‘¡ be the value type unpack(ft).
9. Assert: due to validation, defaultğ‘¡ is defined.
10. Push the value defaultğ‘¡ to the stack ğ‘› times.
11. Execute the instruction (array.new_fixed ğ‘¥ ğ‘›).
ğ¹ ; (i32.const ğ‘›) (array.new_default ğ‘¥) Ë“â†’ (defaultunpack(ft) )ğ‘› (array.new_fixed ğ‘¥ ğ‘›)
(if expand(ğ¹.module.types[ğ‘¥]) = array ft)
array.new_fixed ğ‘¥ ğ‘›
1. Let ğ¹ be the current frame.
2. Assert: due to validation, the defined type ğ¹.module.types[ğ‘¥] exists.
3. Let deftype be the defined type ğ¹.module.types[ğ‘¥].
4. Assert: due to validation, the expansion of deftype is a array type.
5. Let array ft be the expanded array type of deftype.
6. Assert: due to validation, ğ‘› values are on the top of the stack.
7. Pop the ğ‘› values val * from the stack.
8. For every value val ğ‘– in val * :
a. Let fieldval ğ‘– be the result of computing packft (val ğ‘– )).
9. Let fieldval * be the concatenation of all field values fieldval ğ‘– .
10. Let ai be the array instance {type deftype, fields fieldval * }.
11. Let ğ‘ be the length of ğ‘†.arrays.
12. Append ai to ğ‘†.arrays.
13. Push the array reference ref.array ğ‘ to the stack.
ğ‘†; ğ¹ ; val ğ‘› (array.new_fixed ğ‘¥ ğ‘›) Ë“â†’ ğ‘† â€² ; ğ¹ ; (ref.array |ğ‘†.arrays|)
(if expand(ğ¹.module.types[ğ‘¥]) = array ft
âˆ§ ai = {type ğ¹.module.types[ğ‘¥], fields (packft (val ))ğ‘› }
âˆ§ ğ‘† â€² = ğ‘† with arrays = ğ‘†.arrays ai )
array.new_data ğ‘¥ ğ‘¦
1. Let ğ¹ be the current frame.
2. Assert: due to validation, the defined type ğ¹.module.types[ğ‘¥] exists.
3. Let deftype be the defined type ğ¹.module.types[ğ‘¥].
4. Assert: due to validation, the expansion of deftype is an array type.
5. Let array ft be the expanded array type of deftype.
6. Assert: due to validation, the data address ğ¹.module.dataaddrs[ğ‘¦] exists.
7. Let da be the data address ğ¹.module.dataaddrs[ğ‘¦].
8. Assert: due to validation, the data instance ğ‘†.datas[da] exists.
9. Let datainst be the data instance ğ‘†.datas[da].
10. Assert: due to validation, two values of type i32 are on the top of the stack.
11. Pop the value i32.const ğ‘› from the stack.
12. Pop the value i32.const ğ‘  from the stack.

4.6. Instructions

125

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

13. Assert: due to validation, the field type ft has a defined bit width.
14. Let ğ‘§ be the bit width of field type ft divided by eight.
15. If the sum of ğ‘  and ğ‘› times ğ‘§ is larger than the length of datainst.data, then:
a. Trap.
16. Let ğ‘* be the byte sequence datainst.data[ğ‘  : ğ‘› Â· ğ‘§].
17. Let ğ‘¡ be the value type unpack(ft).
ğ‘§

18. For each of the ğ‘› consecutive subsequences ğ‘â€² of ğ‘* :
a. Assert: due to validation, bytesft is defined.
ğ‘§

b. Let ğ‘ğ‘– be the constant for which bytesft (ğ‘ğ‘– ) is ğ‘â€² .
c. Push the value ğ‘¡.const ğ‘ğ‘– to the stack.
19. Execute the instruction (array.new_fixed ğ‘¥ ğ‘›).
ğ‘†; ğ¹ ; (i32.const ğ‘ ) (i32.const ğ‘›) (array.new_data ğ‘¥ ğ‘¦) Ë“â†’ trap
(if expand(ğ¹.module.types[ğ‘¥]) = array ft
âˆ§ ğ‘  + ğ‘› Â· |ft|/8 > |ğ‘†.datas[ğ¹.module.dataaddrs[ğ‘¦]].data|)

ğ‘†; ğ¹ ; (i32.const ğ‘ ) (i32.const ğ‘›) (array.new_data ğ‘¥ ğ‘¦) Ë“â†’ (ğ‘¡.const ğ‘)ğ‘› (array.new_fixed ğ‘¥ ğ‘›)
(if expand(ğ¹.module.types[ğ‘¥]) = array ft
âˆ§ ğ‘¡ = unpack(ft)
âˆ§ concat((bytesft (ğ‘))ğ‘› ) = ğ‘†.datas[ğ¹.module.dataaddrs[ğ‘¦]].data
array.new_elem ğ‘¥ ğ‘¦
1. Let ğ¹ be the current frame.
2. Assert: due to validation, the element address ğ¹.module.elemaddrs[ğ‘¦] exists.
3. Let ea be the element address ğ¹.module.elemaddrs[ğ‘¦].
4. Assert: due to validation, the element instance ğ‘†.elems[ea] exists.
5. Let eleminst be the element instance ğ‘†.elems[ea].
6. Assert: due to validation, two values of type i32 are on the top of the stack.
7. Pop the value (i32.const ğ‘›) from the stack.
8. Pop the value (i32.const ğ‘ ) from the stack.
9. If the sum of ğ‘  and ğ‘› is larger than the length of eleminst.elem, then:
a. Trap.
10. Let ref * be the reference sequence eleminst.elem[ğ‘  : ğ‘›].
11. Push the references ref * to the stack.
12. Execute the instruction (array.new_fixed ğ‘¥ ğ‘›).
ğ‘†; ğ¹ ; (i32.const ğ‘ ) (i32.const ğ‘›) (array.new_elem ğ‘¥ ğ‘¦) Ë“â†’ trap
(if ğ‘  + ğ‘› > |ğ‘†.elems[ğ¹.module.elemaddrs[ğ‘¦]].elem|)
ğ‘†; ğ¹ ; (i32.const ğ‘ ) (i32.const ğ‘›) (array.new_elem ğ‘¥ ğ‘¦) Ë“â†’ ref ğ‘› (array.new_fixed ğ‘¥ ğ‘›)
(if ref ğ‘› = ğ‘†.elems[ğ¹.module.elemaddrs[ğ‘¦]].elem[ğ‘  : ğ‘›])

126

Chapter 4. Execution

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

array.get_sx ? ğ‘¥
1. Let ğ¹ be the current frame.
2. Assert: due to validation, the defined type ğ¹.module.types[ğ‘¥] exists.
3. Let deftype be the defined type ğ¹.module.types[ğ‘¥].
4. Assert: due to validation, the expansion of deftype is an array type.
5. Let array ft be the expanded array type of deftype.
6. Assert: due to validation, a value of type i32 is on the top of the stack.
7. Pop the value i32.const ğ‘– from the stack.
8. Assert: due to validation, a value of type (ref null ğ‘¥) is on the top of the stack.
9. Pop the value ref from the stack.
10. If ref is ref.null ğ‘¡, then:
a. Trap.
11. Assert: due to validation, ref is an array reference.
12. Let ref.array ğ‘ be the reference value ref .
13. Assert: due to validation, the array instance ğ‘†.arrays[ğ‘] exists.
14. If ğ‘› is larger than or equal to the length of ğ‘†.arrays[ğ‘].fields, then:
a. Trap.
15. Let fieldval be the field value ğ‘†.arrays[ğ‘].fields[ğ‘–].
?

16. Let val be the result of computing unpacksx
ft (fieldval )).
17. Push the value val to the stack.
ğ‘†; ğ¹ ; (ref.array ğ‘) (i32.const ğ‘–) (array.get_sx ? ğ‘¥) Ë“â†’ trap
(if ğ‘– â‰¥ |arrays[ğ‘].fields|)
ğ‘†; ğ¹ ; (ref.array ğ‘) (i32.const ğ‘–) (array.get_sx ? ğ‘¥) Ë“â†’ val
(if expand(ğ¹.module.types[ğ‘¥]) = array ft
?
âˆ§ val = unpacksx
ft (ğ‘†.arrays[ğ‘].fields[ğ‘–]))
ğ‘†; ğ¹ ; (ref.null ğ‘¡) (i32.const ğ‘–) (array.get_sx ? ğ‘¥) Ë“â†’ trap
array.set ğ‘¥
1. Let ğ¹ be the current frame.
2. Assert: due to validation, the defined type ğ¹.module.types[ğ‘¥] exists.
3. Let deftype be the defined type ğ¹.module.types[ğ‘¥].
4. Assert: due to validation, the expansion of deftype is an array type.
5. Let array ft be the expanded array type of deftype.
6. Assert: due to validation, a value is on the top of the stack.
7. Pop the value val from the stack.
8. Assert: due to validation, a value of type i32 is on the top of the stack.
9. Pop the value i32.const ğ‘– from the stack.
10. Assert: due to validation, a value of type (ref null ğ‘¥) is on the top of the stack.
11. Pop the value ref from the stack.
12. If ref is ref.null ğ‘¡, then:

4.6. Instructions

127

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

a. Trap.
13. Assert: due to validation, ref is an array reference.
14. Let ref.array ğ‘ be the reference value ref .
15. Assert: due to validation, the array instance ğ‘†.arrays[ğ‘] exists.
16. If ğ‘› is larger than or equal to the length of ğ‘†.arrays[ğ‘].fields, then:
a. Trap.
17. Let fieldval be the result of computing packft (val )).
18. Replace the field value ğ‘†.arrays[ğ‘].fields[ğ‘–] with fieldval .
ğ‘†; ğ¹ ; (ref.array ğ‘) (i32.const ğ‘–) val (array.set ğ‘¥) Ë“â†’ trap
(if ğ‘– â‰¥ |arrays[ğ‘].fields|)
ğ‘†; ğ¹ ; (ref.array ğ‘) (i32.const ğ‘–) val (array.set ğ‘¥) Ë“â†’ ğ‘† â€² ; ğœ–
(if expand(ğ¹.module.types[ğ‘¥]) = array ft
âˆ§ ğ‘† â€² = ğ‘† with arrays[ğ‘].fields[ğ‘–] = packft (val ))
ğ‘†; ğ¹ ; (ref.null ğ‘¡) (i32.const ğ‘–) val (array.set ğ‘¥) Ë“â†’ trap
array.len
1. Assert: due to validation, a value of type (ref null array) is on the top of the stack.
2. Pop the value ref from the stack.
3. If ref is ref.null ğ‘¡, then:
a. Trap.
4. Assert: due to validation, ref is an array reference.
5. Let ref.array ğ‘ be the reference value ref .
6. Assert: due to validation, the array instance ğ‘†.arrays[ğ‘] exists.
7. Let ğ‘› be the length of ğ‘†.arrays[ğ‘].fields.
8. Push the value (i32.const ğ‘›) to the stack.
ğ‘†; (ref.array ğ‘) array.len
ğ‘†; (ref.null ğ‘¡) array.len

Ë“â†’ (i32.const |ğ‘†.arrays[ğ‘].fields|)
Ë“â†’ trap

array.fill ğ‘¥
1. Assert: due to validation, a value of type i32 is on the top of the stack.
2. Pop the value ğ‘› from the stack.
3. Assert: due to validation, a value is on the top of the stack.
4. Pop the value val from the stack.
5. Assert: due to validation, a value of type i32 is on the top of the stack.
6. Pop the value ğ‘‘ from the stack.
7. Assert: due to validation, a value of type (ref null ğ‘¥) is on the top of the stack.
8. Pop the value ref from the stack.
9. If ref is ref.null ğ‘¡, then:
a. Trap.
10. Assert: due to validation, ref is an array reference.
11. Let ref.array ğ‘ be the reference value ref .

128

Chapter 4. Execution

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

12. Assert: due to validation, the array instance ğ‘†.arrays[ğ‘] exists.
13. If ğ‘‘ + ğ‘› is larger than the length of ğ‘†.arrays[ğ‘].fields, then:
a. Trap.
14. If ğ‘› = 0, then:
a. Return.
15. Push the value ref.array ğ‘ to the stack.
16. Push the value i32.const ğ‘‘ to the stack.
17. Push the value val to the stack.
18. Execute the instruction array.set ğ‘¥.
19. Push the value ref.array ğ‘ to the stack.
20. Assert: due to the earlier check against the array size, ğ‘‘ + 1 < 232 .
21. Push the value i32.const (ğ‘‘ + 1) to the stack.
22. Push the value val to the stack.
23. Push the value i32.const (ğ‘› âˆ’ 1) to the stack.
24. Execute the instruction array.fill ğ‘¥.
ğ‘†; (ref.array ğ‘) (i32.const ğ‘‘) val (i32.const ğ‘›) (array.fill ğ‘¥)
(if ğ‘‘ + ğ‘› > |ğ‘†.arrays[ğ‘].fields|)

Ë“â†’

trap

ğ‘†; (ref.array ğ‘) (i32.const ğ‘‘) val (i32.const 0) (array.fill ğ‘¥)
(otherwise)

Ë“â†’

ğœ–

ğ‘†; (ref.array ğ‘) (i32.const ğ‘‘) val (i32.const ğ‘› + 1) (array.fill ğ‘¥)
(ref.array ğ‘) (i32.const ğ‘‘) val (array.set ğ‘¥)
(ref.array ğ‘) (i32.const ğ‘‘ + 1) val (i32.const ğ‘›) (array.fill ğ‘¥)
(otherwise)

Ë“â†’

ğ‘†; (ref.null ğ‘¡) (i32.const ğ‘‘) val (i32.const ğ‘›) (array.fill ğ‘¥)

trap

Ë“â†’

array.copy ğ‘¥ ğ‘¦
1. Let ğ¹ be the current frame.
2. Assert: due to validation, the defined type ğ¹.module.types[ğ‘¦] exists.
3. Let deftype be the defined type ğ¹.module.types[ğ‘¦].
4. Assert: due to validation, the expansion of deftype is an array type.
5. Let array mut st be the expanded array type deftype.
6. Assert: due to validation, a value of type i32 is on the top of the stack.
7. Pop the value i32.const ğ‘› from the stack.
8. Assert: due to validation, a value of type i32 is on the top of the stack.
9. Pop the value i32.const ğ‘  from the stack.
10. Assert: due to validation, a value of type (ref null ğ‘¦) is on the top of the stack.
11. Pop the value ref 2 from the stack.
12. Assert: due to validation, a value of type i32 is on the top of the stack.
13. Pop the value i32.const ğ‘‘ from the stack.
14. Assert: due to validation, a value of type (ref null ğ‘¥) is on the top of the stack.
15. Pop the value ref 1 from the stack.
4.6. Instructions

129

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

16. If ref 1 is ref.null ğ‘¡, then:
a. Trap.
17. Assert: due to validation, ref 1 is an array reference.
18. Let ref.array ğ‘1 be the reference value ref 1 .
19. If ref 2 is ref.null ğ‘¡, then:
a. Trap.
20. Assert: due to validation, ref 2 is an array reference.
21. Let ref.array ğ‘2 be the reference value ref 2 .
22. Assert: due to validation, the array instance ğ‘†.arrays[ğ‘1 ] exists.
23. Assert: due to validation, the array instance ğ‘†.arrays[ğ‘2 ] exists.
24. If ğ‘‘ + ğ‘› is larger than the length of ğ‘†.arrays[ğ‘1 ].fields, then:
a. Trap.
25. If ğ‘  + ğ‘› is larger than the length of ğ‘†.arrays[ğ‘2 ].fields, then:
a. Trap.
26. If ğ‘› = 0, then:
a. Return.
27. If ğ‘‘ â‰¤ ğ‘ , then:
a. Push the value ref.array ğ‘1 to the stack.
b. Push the value i32.const ğ‘‘ to the stack.
c. Push the value ref.array ğ‘2 to the stack.
d. Push the value i32.const ğ‘  to the stack.
e. Execute getfield(st).
f. Execute the instruction array.set ğ‘¥.
g. Push the value ref.array ğ‘1 to the stack.
h. Assert: due to the earlier check against the array size, ğ‘‘ + 1 < 232 .
i. Push the value i32.const (ğ‘‘ + 1) to the stack.
j. Push the value ref.array ğ‘2 to the stack.
k. Assert: due to the earlier check against the array size, ğ‘  + 1 < 232 .
l. Push the value i32.const (ğ‘  + 1) to the stack.
28. Else:
a. Push the value ref.array ğ‘1 to the stack.
b. Assert: due to the earlier check against the array size, ğ‘‘ + ğ‘› âˆ’ 1 < 232 .
c. Push the value i32.const (ğ‘‘ + ğ‘› âˆ’ 1) to the stack.
d. Push the value ref.array ğ‘2 to the stack.
e. Assert: due to the earlier check against the array size, ğ‘  + ğ‘› âˆ’ 1 < 232 .
f. Push the value i32.const (ğ‘  + ğ‘› âˆ’ 1) to the stack.
g. Execute getfield(st).
h. Execute the instruction array.set ğ‘¥.
i. Push the value ref.array ğ‘1 to the stack.

130

Chapter 4. Execution

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

j. Push the value i32.const ğ‘‘ to the stack.
k. Push the value ref.array ğ‘2 to the stack.
l. Push the value i32.const ğ‘  to the stack.
29. Push the value i32.const (ğ‘› âˆ’ 1) to the stack.
30. Execute the instruction array.copy ğ‘¥ ğ‘¦.
ğ‘†; ğ¹ ; (ref.array ğ‘1 ) (i32.const ğ‘‘) (ref.array ğ‘2 ) (i32.const ğ‘ ) (i32.const ğ‘›) (array.copy ğ‘¥ ğ‘¦)
(if ğ‘‘ + ğ‘› > |ğ‘†.arrays[ğ‘1 ].fields| âˆ¨ ğ‘  + ğ‘› > |ğ‘†.arrays[ğ‘2 ].fields|)

Ë“â†’

trap

ğ‘†; ğ¹ ; (ref.array ğ‘1 ) (i32.const ğ‘‘) (ref.array ğ‘2 ) (i32.const ğ‘ ) (i32.const 0) (array.copy ğ‘¥ ğ‘¦)
(otherwise)

Ë“â†’

ğœ–

ğ‘†; ğ¹ ; (ref.array ğ‘1 ) (i32.const ğ‘‘) (ref.array ğ‘2 ) (i32.const ğ‘ ) (i32.const ğ‘› + 1) (array.copy ğ‘¥ ğ‘¦) Ë“â†’
(ref.array ğ‘1 ) (i32.const ğ‘‘)
(ref.array ğ‘2 ) (i32.const ğ‘ ) getfield(st)
(array.set ğ‘¥)
(ref.array ğ‘1 ) (i32.const ğ‘‘ + 1) (ref.array ğ‘2 ) (i32.const ğ‘  + 1) (i32.const ğ‘›) (array.copy ğ‘¥ ğ‘¦)
(otherwise, if ğ‘‘ â‰¤ ğ‘  âˆ§ ğ¹.module.types[ğ‘¦] = array mut st)
ğ‘†; ğ¹ ; (ref.array ğ‘1 ) (i32.const ğ‘‘) (ref.array ğ‘2 ) (i32.const ğ‘ ) (i32.const ğ‘› + 1) (array.copy ğ‘¥ ğ‘¦)
(ref.array ğ‘1 ) (i32.const ğ‘‘ + ğ‘›)
(ref.array ğ‘2 ) (i32.const ğ‘  + ğ‘›) getfield(st)
(array.set ğ‘¥)
(ref.array ğ‘1 ) (i32.const ğ‘‘) (ref.array ğ‘2 ) (i32.const ğ‘ ) (i32.const ğ‘›) (array.copy ğ‘¥ ğ‘¦)
(otherwise, if ğ‘‘ > ğ‘  âˆ§ ğ¹.module.types[ğ‘¦] = array mut st)
ğ‘†; ğ¹ ; (ref.null ğ‘¡) (i32.const ğ‘‘) val (i32.const ğ‘ ) (i32.const ğ‘›) (array.copy ğ‘¥ ğ‘¦)

Ë“â†’

trap

ğ‘†; ğ¹ ; val (i32.const ğ‘‘) (ref.null ğ‘¡) (i32.const ğ‘ ) (i32.const ğ‘›) (array.copy ğ‘¥ ğ‘¦)

Ë“â†’

trap

Ë“â†’

Where:

getfield(valtype)
= array.get ğ‘¦
getfield(packedtype) = array.get_u ğ‘¦
array.init_data ğ‘¥ ğ‘¦
1. Let ğ¹ be the current frame.
2. Assert: due to validation, the defined type ğ¹.module.types[ğ‘¥] exists.
3. Let deftype be the defined type ğ¹.module.types[ğ‘¥].
4. Assert: due to validation, the expansion of deftype is an array type.
5. Let array ft be the expanded array type deftype.
6. Assert: due to validation, the data address ğ¹.module.dataaddrs[ğ‘¦] exists.
7. Let da be the data address ğ¹.module.dataaddrs[ğ‘¦].
8. Assert: due to validation, the data instance ğ‘†.datas[da] exists.
9. Let datainst be the data instance ğ‘†.datas[da].
10. Assert: due to validation, three values of type i32 are on the top of the stack.
11. Pop the value i32.const ğ‘› from the stack.
12. Pop the value i32.const ğ‘  from the stack.
13. Pop the value i32.const ğ‘‘ from the stack.

4.6. Instructions

131

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

14. Assert: due to validation, a value of type (ref null ğ‘¥) is on the top of the stack.
15. Pop the value ref from the stack.
16. If ref is ref.null ğ‘¡, then:
a. Trap.
17. Assert: due to validation, ref is an array reference.
18. Let ref.array ğ‘ be the reference value ref .
19. Assert: due to validation, the array instance ğ‘†.arrays[ğ‘] exists.
20. Assert: due to validation, the field type ft has a defined bit width.
21. Let ğ‘§ be the bit width of field type ft divided by eight.
22. If ğ‘‘ + ğ‘› is larger than the length of ğ‘†.arrays[ğ‘].fields, or the sum of ğ‘  and ğ‘› times ğ‘§ is larger than the length
of datainst.data, then:
a. Trap.
23. If ğ‘› = 0, then:
a. Return.
24. Let ğ‘* be the byte sequence datainst.data[ğ‘  : ğ‘§].
25. Let ğ‘¡ be the value type unpack(ft).
26. Assert: due to validation, bytesft is defined.
27. Let ğ‘ be the constant for which bytesft (ğ‘) is ğ‘* .
28. Push the value ref.array ğ‘ to the stack.
29. Push the value i32.const ğ‘‘ to the stack.
30. Push the value ğ‘¡.const ğ‘ to the stack.
31. Execute the instruction array.set ğ‘¥.
32. Push the value ref.array ğ‘ to the stack.
33. Push the value i32.const (ğ‘‘ + 1) to the stack.
34. Push the value i32.const (ğ‘  + ğ‘§) to the stack.
35. Push the value i32.const (ğ‘› âˆ’ 1) to the stack.
36. Execute the instruction array.init_data ğ‘¥ ğ‘¦.
ğ‘†; ğ¹ ; (ref.array ğ‘) (i32.const ğ‘‘) (i32.const ğ‘ ) (i32.const ğ‘›) (array.init_data ğ‘¥ ğ‘¦) Ë“â†’ trap
(if ğ‘‘ + ğ‘› > |ğ‘†.arrays[ğ‘].fields|
âˆ¨ (ğ¹.module.types[ğ‘¥] = array ft âˆ§ ğ‘  + ğ‘› Â· |ft|/8 > |ğ‘†.datas[ğ¹.module.dataaddrs[ğ‘¦]].data|))
ğ‘†; ğ¹ ; (ref.array ğ‘) (i32.const ğ‘‘) (i32.const ğ‘ ) (i32.const 0) (array.init_data ğ‘¥ ğ‘¦) Ë“â†’ ğœ–
(otherwise)
ğ‘†; ğ¹ ; (ref.array ğ‘) (i32.const ğ‘‘) (i32.const ğ‘ ) (i32.const ğ‘› + 1) (array.init_data ğ‘¥ ğ‘¦) Ë“â†’
(ref.array ğ‘) (i32.const ğ‘‘) (ğ‘¡.const ğ‘) (array.set ğ‘¥)
(ref.array ğ‘) (i32.const ğ‘‘ + 1) (i32.const ğ‘  + |ft|/8) (i32.const ğ‘›) (array.init_data ğ‘¥ ğ‘¦)
(otherwise, if ğ¹.module.types[ğ‘¥] = array ft
âˆ§ ğ‘¡ = unpack(ft)
âˆ§ bytesft (ğ‘) = ğ‘†.datas[ğ¹.module.dataaddrs[ğ‘¦]].data[ğ‘  : |ft|/8]
ğ‘†; ğ¹ ; (ref.null ğ‘¡) (i32.const ğ‘‘) (i32.const ğ‘ ) (i32.const ğ‘›) (array.init_data ğ‘¥ ğ‘¦) Ë“â†’ trap

132

Chapter 4. Execution

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

array.init_elem ğ‘¥ ğ‘¦
1. Let ğ¹ be the current frame.
2. Assert: due to validation, the defined type ğ¹.module.types[ğ‘¥] exists.
3. Let deftype be the defined type ğ¹.module.types[ğ‘¥].
4. Assert: due to validation, the expansion of deftype is an array type.
5. Let array ft be the expanded array type deftype.
6. Assert: due to validation, the element address ğ¹.module.elemaddrs[ğ‘¦] exists.
7. Let ea be the element address ğ¹.module.elemaddrs[ğ‘¦].
8. Assert: due to validation, the element instance ğ‘†.elems[ea] exists.
9. Let eleminst be the element instance ğ‘†.elems[ea].
10. Assert: due to validation, three values of type i32 are on the top of the stack.
11. Pop the value i32.const ğ‘› from the stack.
12. Pop the value i32.const ğ‘  from the stack.
13. Pop the value i32.const ğ‘‘ from the stack.
14. Assert: due to validation, a value of type (ref null ğ‘¥) is on the top of the stack.
15. Pop the value ref from the stack.
16. If ref is ref.null ğ‘¡, then:
a. Trap.
17. Assert: due to validation, ref is an array reference.
18. Let ref.array ğ‘ be the reference value ref .
19. Assert: due to validation, the array instance ğ‘†.arrays[ğ‘] exists.
20. If ğ‘‘ + ğ‘› is larger than the length of ğ‘†.arrays[ğ‘].fields, or ğ‘  + ğ‘› is larger than the length of eleminst.elem,
then:
a. Trap.
21. If ğ‘› = 0, then:
a. Return.
22. Let ref â€² be the reference value eleminst.elem[ğ‘ ].
23. Push the value ref.array ğ‘ to the stack.
24. Push the value i32.const ğ‘‘ to the stack.
25. Push the value ref â€² to the stack.
26. Execute the instruction array.set ğ‘¥.
27. Push the value ref.array ğ‘ to the stack.
28. Push the value i32.const (ğ‘‘ + 1) to the stack.
29. Push the value i32.const (ğ‘  + 1) to the stack.
30. Push the value i32.const (ğ‘› âˆ’ 1) to the stack.
31. Execute the instruction array.init_elem ğ‘¥ ğ‘¦.

4.6. Instructions

133

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

ğ‘†; ğ¹ ; (ref.array ğ‘) (i32.const ğ‘‘) (i32.const ğ‘ ) (i32.const ğ‘›) (array.init_elem ğ‘¥ ğ‘¦)
(if ğ‘‘ + ğ‘› > |ğ‘†.arrays[ğ‘].fields|
âˆ¨ ğ‘  + ğ‘› > |ğ‘†.elems[ğ¹.module.elemaddrs[ğ‘¦]].elem|)
ğ‘†; ğ¹ ; (ref.array ğ‘) (i32.const ğ‘‘) (i32.const ğ‘ ) (i32.const 0) (array.init_elem ğ‘¥ ğ‘¦)
(otherwise)

Ë“â†’

trap

Ë“â†’

ğœ–

ğ‘†; ğ¹ ; (ref.array ğ‘) (i32.const ğ‘‘) (i32.const ğ‘ ) (i32.const ğ‘› + 1) (array.init_elem ğ‘¥ ğ‘¦) Ë“â†’
(ref.array ğ‘) (i32.const ğ‘‘) ref (array.set ğ‘¥)
(ref.array ğ‘) (i32.const ğ‘‘ + 1) (i32.const ğ‘  + 1) (i32.const ğ‘›) (array.init_elem ğ‘¥ ğ‘¦)
(otherwise, if ref = ğ‘†.elems[ğ¹.module.elemaddrs[ğ‘¦]].elem[ğ‘ ])
ğ‘†; ğ¹ ; (ref.null ğ‘¡) (i32.const ğ‘‘) (i32.const ğ‘ ) (i32.const ğ‘›) (array.init_elem ğ‘¥ ğ‘¦)

Ë“â†’

trap

any.convert_extern
1. Assert: due to validation, a reference value is on the top of the stack.
2. Pop the value ref from the stack.
3. If ref is ref.null ht, then:
a. Push the reference value (ref.null any) to the stack.
4. Else:
a. Assert: due to validation, a ref is an external reference.
b. Let ref.extern ref â€² be the reference value ref .
c. Push the reference value ref â€² to the stack.
(ref.null ht) any.convert_extern
(ref.extern ref ) any.convert_extern

Ë“â†’
Ë“â†’

(ref.null any)
ref

extern.convert_any
1. Assert: due to validation, a reference value is on the top of the stack.
2. Pop the value ref from the stack.
3. If ref is ref.null ht, then:
a. Push the reference value (ref.null extern) to the stack.
4. Else:
a. Let ref â€² be the reference value (ref.extern ref ).
b. Push the reference value ref â€² to the stack.
(ref.null ht) extern.convert_any
ref extern.convert_any

Ë“â†’ (ref.null extern)
Ë“â†’ (ref.extern ref )

(if ref Ì¸= (ref.null ht))

4.6.3 Vector Instructions
Vector instructions that operate bitwise are handled as integer operations of respective width.
op vğ‘ (ğ‘–1 , . . . , ğ‘–ğ‘˜ )

=

iop ğ‘ (ğ‘–1 , . . . , ğ‘–ğ‘˜ )

Most other vector instructions are defined in terms of numeric operators that are applied lane-wise according to
the given shape.
op ğ‘¡xğ‘ (ğ‘›1 , . . . , ğ‘›ğ‘˜ )

134

=

*
lanesâˆ’1
ğ‘¡xğ‘ (op ğ‘¡ (ğ‘–1 , . . . , ğ‘–ğ‘˜ ) )

(if ğ‘–*1 = lanesğ‘¡xğ‘ (ğ‘›1 ) âˆ§ Â· Â· Â· âˆ§ ğ‘–*ğ‘˜ = lanesğ‘¡xğ‘ (ğ‘›ğ‘˜ )

Chapter 4. Execution

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

Ã² Note
For example, the result of instruction i32x4.add applied to operands ğ‘£1 , ğ‘£2 invokes addi32x4 (ğ‘£1 , ğ‘£2 ), which
*
*
*
maps to lanesâˆ’1
i32x4 (addi32 (ğ‘–1 , ğ‘–2 ) ), where ğ‘–1 and ğ‘–2 are sequences resulting from invoking lanesi32x4 (ğ‘£1 ) and
lanesi32x4 (ğ‘£2 ) respectively.
For non-deterministic operators this definition is generalized to sets:
op ğ‘¡xğ‘ (ğ‘›1 , . . . , ğ‘›ğ‘˜ )

*
*
*
*
*
= {lanesâˆ’1
ğ‘¡xğ‘ (ğ‘– ) | ğ‘– âˆˆ Ã—op ğ‘¡ (ğ‘–1 , . . . , ğ‘–ğ‘˜ ) âˆ§ ğ‘–1 = lanesğ‘¡xğ‘ (ğ‘›1 ) âˆ§ Â· Â· Â· âˆ§ ğ‘–ğ‘˜ = lanesğ‘¡xğ‘ (ğ‘›ğ‘˜ )}

where Ã—{ğ‘¥* }ğ‘ transforms a sequence of ğ‘ sets of values into a set of sequences of ğ‘ values by computing the
set product:
Ã—(ğ‘†1 . . . ğ‘†ğ‘ )

=

{ğ‘¥1 . . . ğ‘¥ğ‘ | ğ‘¥1 âˆˆ ğ‘†1 âˆ§ Â· Â· Â· âˆ§ ğ‘¥ğ‘ âˆˆ ğ‘†ğ‘ }

v128.const ğ‘
1. Push the value v128.const ğ‘ to the stack.
Ã² Note
No formal reduction rule is required for this instruction, since const instructions coincide with values.
v128.vvunop
1. Assert: due to validation, a value of value type v128 is on the top of the stack.
2. Pop the value v128.const ğ‘1 from the stack.
3. Let ğ‘ be the result of computing vvunop v128 (ğ‘1 ).
4. Push the value v128.const ğ‘ to the stack.
(v128.const ğ‘1 ) v128.vvunop

Ë“â†’ (v128.const ğ‘)

(if ğ‘ = vvunop v128 (ğ‘1 ))

v128.vvbinop
1. Assert: due to validation, two values of value type v128 are on the top of the stack.
2. Pop the value v128.const ğ‘2 from the stack.
3. Pop the value v128.const ğ‘1 from the stack.
4. Let ğ‘ be the result of computing vvbinop v128 (ğ‘1 , ğ‘2 ).
5. Push the value v128.const ğ‘ to the stack.
(v128.const ğ‘1 ) (v128.const ğ‘2 ) v128.vvbinop

Ë“â†’ (v128.const ğ‘)

(if ğ‘ = vvbinop v128 (ğ‘1 , ğ‘2 ))

v128.vvternop
1. Assert: due to validation, three values of value type v128 are on the top of the stack.
2. Pop the value v128.const ğ‘3 from the stack.
3. Pop the value v128.const ğ‘2 from the stack.
4. Pop the value v128.const ğ‘1 from the stack.
5. Let ğ‘ be the result of computing vvternop v128 (ğ‘1 , ğ‘2 , ğ‘3 ).
6. Push the value v128.const ğ‘ to the stack.
(v128.const ğ‘1 ) (v128.const ğ‘2 ) (v128.const ğ‘3 ) v128.vvternop
4.6. Instructions

Ë“â†’ (v128.const ğ‘)

(if ğ‘ = vvternop v128 (ğ‘1 , ğ‘2 , ğ‘3 ))
135

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

v128.any_true
1. Assert: due to validation, a value of value type v128 is on the top of the stack.
2. Pop the value v128.const ğ‘1 from the stack.
3. Let ğ‘– be the result of computing ine128 (ğ‘1 , 0).
4. Push the value i32.const ğ‘– onto the stack.
(v128.const ğ‘1 ) v128.any_true Ë“â†’ (i32.const ğ‘–)

(if ğ‘– = ine128 (ğ‘1 , 0))

i8x16.swizzle
1. Assert: due to validation, two values of value type v128 are on the top of the stack.
2. Pop the value v128.const ğ‘2 from the stack.
3. Let ğ‘–* be the result of computing lanesi8x16 (ğ‘2 ).
4. Pop the value v128.const ğ‘1 from the stack.
5. Let ğ‘— * be the result of computing lanesi8x16 (ğ‘1 ).
6. Let ğ‘* be the concatenation of the two sequences ğ‘— * and 0240 .
âˆ’1
7. Let ğ‘â€² be the result of computing lanesi8x16
(ğ‘* [ğ‘–* [0]] . . . ğ‘* [ğ‘–* [15]]).

8. Push the value v128.const ğ‘â€² onto the stack.
(v128.const ğ‘1 ) (v128.const ğ‘2 ) i8x16.swizzle
(if ğ‘–* = lanesi8x16 (ğ‘2 )
âˆ§ ğ‘* = lanesi8x16 (ğ‘1 ) 0240
* *
* *
âˆ§ ğ‘â€² = lanesâˆ’1
i8x16 (ğ‘ [ğ‘– [0]] . . . ğ‘ [ğ‘– [15]]))

Ë“â†’ (v128.const ğ‘â€² )

i8x16.relaxed_swizzle
1. Assert: due to validation, two values of value type v128 are on the top of the stack.
2. Pop the value v128.const ğ‘2 from the stack.
3. Pop the value v128.const ğ‘1 from the stack.
4. Let ğ‘â€² be the result of computing lanesâˆ’1
i8x16 (frelaxed_swizzle(lanesi8x16 (ğ‘1 ), lanesi8x16 (ğ‘2 ))).
5. Push the value v128.const ğ‘â€² onto the stack.
(v128.const ğ‘1 ) (v128.const ğ‘2 ) i8x16.frelaxed_swizzle Ë“â†’ (v128.const ğ‘â€² )
(if ğ‘â€² = lanesâˆ’1
i8x16 (frelaxed_swizzle(lanesi8x16 (ğ‘1 ), lanesi8x16 (ğ‘2 )))
i8x16.shuffle ğ‘¥*
1. Assert: due to validation, two values of value type v128 are on the top of the stack.
2. Assert: due to validation, for all ğ‘¥ğ‘– in ğ‘¥* it holds that ğ‘¥ğ‘– < 32.
3. Pop the value v128.const ğ‘2 from the stack.
4. Let ğ‘–*2 be the result of computing lanesi8x16 (ğ‘2 ).
5. Pop the value v128.const ğ‘1 from the stack.
6. Let ğ‘–*1 be the result of computing lanesi8x16 (ğ‘1 ).
7. Let ğ‘–* be the concatenation of the two sequences ğ‘–*1 and ğ‘–*2 .
* *
* *
8. Let ğ‘ be the result of computing lanesâˆ’1
i8x16 (ğ‘– [ğ‘¥ [0]] . . . ğ‘– [ğ‘¥ [15]]).

9. Push the value v128.const ğ‘ onto the stack.
(v128.const ğ‘1 ) (v128.const ğ‘2 ) (i8x16.shuffle ğ‘¥* ) Ë“â†’ (v128.const ğ‘)
(if ğ‘–* = lanesi8x16 (ğ‘1 ) lanesi8x16 (ğ‘2 )
* *
* *
âˆ§ ğ‘ = lanesâˆ’1
i8x16 (ğ‘– [ğ‘¥ [0]] . . . ğ‘– [ğ‘¥ [15]]))
136

Chapter 4. Execution

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

shape.splat
1. Let ğ‘¡ be the type unpack(shape).
2. Assert: due to validation, a value of value type ğ‘¡ is on the top of the stack.
3. Pop the value ğ‘¡.const ğ‘1 from the stack.
4. Let ğ‘ be the integer dim(shape).
ğ‘
5. Let ğ‘ be the result of computing lanesâˆ’1
shape (ğ‘1 ).

6. Push the value v128.const ğ‘ to the stack.
(ğ‘¡.const ğ‘1 ) shape.splat

Ë“â†’ (v128.const ğ‘)

dim(shape)

(if ğ‘¡ = unpack(shape) âˆ§ ğ‘ = lanesâˆ’1
shape (ğ‘1

))

ğ‘¡1 xğ‘.extract_lane_sx ? ğ‘¥
1. Assert: due to validation, ğ‘¥ < ğ‘ .
2. Assert: due to validation, a value of value type v128 is on the top of the stack.
3. Pop the value v128.const ğ‘1 from the stack.
4. Let ğ‘–* be the result of computing lanesğ‘¡1 xğ‘ (ğ‘1 ).
5. Let ğ‘¡2 be the type unpack(ğ‘¡1 xğ‘ ).
?

*
6. Let ğ‘2 be the result of computing extendğ‘ ğ‘¥
ğ‘¡1 ,ğ‘¡2 (ğ‘– [ğ‘¥]).

7. Push the value ğ‘¡2 .const ğ‘2 to the stack.
(v128.const ğ‘1 ) (ğ‘¡1 xğ‘.extract_lane ğ‘¥) Ë“â†’
(if ğ‘¡2 = unpack(ğ‘¡1 xğ‘ )
?
âˆ§ ğ‘2 = extendğ‘ ğ‘¥
ğ‘¡1 ,ğ‘¡2 (lanesğ‘¡1 xğ‘ (ğ‘1 )[ğ‘¥]))

(ğ‘¡2 .const ğ‘2 )

shape.replace_lane ğ‘¥
1. Assert: due to validation, ğ‘¥ < dim(shape).
2. Let ğ‘¡2 be the type unpack(shape).
3. Assert: due to validation, a value of value type ğ‘¡1 is on the top of the stack.
4. Pop the value ğ‘¡2 .const ğ‘2 from the stack.
5. Assert: due to validation, a value of value type v128 is on the top of the stack.
6. Pop the value v128.const ğ‘1 from the stack.
7. Let ğ‘–* be the result of computing lanesshape (ğ‘1 ).
*
8. Let ğ‘ be the result of computing lanesâˆ’1
shape (ğ‘– with [ğ‘¥] = ğ‘2 ).

9. Push v128.const ğ‘ on the stack.
(v128.const ğ‘1 ) (ğ‘¡2 .const ğ‘2 ) (shape.replace_lane ğ‘¥) Ë“â†’ (v128.const ğ‘)
(if ğ‘–* = lanesshape (ğ‘1 )
*
âˆ§ ğ‘ = lanesâˆ’1
shape (ğ‘– with [ğ‘¥] = ğ‘2 ))
shape.vunop
1. Assert: due to validation, a value of value type v128 is on the top of the stack.
2. Pop the value v128.const ğ‘1 from the stack.
3. Let ğ‘ be the result of computing vunop shape (ğ‘1 ).
4. Push the value v128.const ğ‘ to the stack.
(v128.const ğ‘1 ) shape.vunop

4.6. Instructions

Ë“â†’ (v128.const ğ‘)

(if ğ‘ = vunop shape (ğ‘1 ))

137

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

shape.vbinop
1. Assert: due to validation, two values of value type v128 are on the top of the stack.
2. Pop the value v128.const ğ‘2 from the stack.
3. Pop the value v128.const ğ‘1 from the stack.
4. If vbinop shape (ğ‘1 , ğ‘2 ) is defined:
a. Let ğ‘ be a possible result of computing vbinop shape (ğ‘1 , ğ‘2 ).
b. Push the value v128.const ğ‘ to the stack.
5. Else:
a. Trap.
(v128.const ğ‘1 ) (v128.const ğ‘2 ) shape.vbinop
(v128.const ğ‘1 ) (v128.const ğ‘2 ) shape.vbinop

Ë“â†’
Ë“â†’

(v128.const ğ‘)
trap

(if ğ‘ âˆˆ vbinop shape (ğ‘1 , ğ‘2 ))
(if vbinop shape (ğ‘1 , ğ‘2 ) = {})

shape.vternop
1. Assert: due to validation, three values of value type v128 are on the top of the stack.
2. Pop the value v128.const ğ‘3 from the stack.
3. Pop the value v128.const ğ‘2 from the stack.
4. Pop the value v128.const ğ‘1 from the stack.
5. Let ğ‘ be the result of computing vternop shape (ğ‘1 , ğ‘2 , ğ‘3 ).
6. Push the value v128.const ğ‘ to the stack.
(v128.const ğ‘1 ) (v128.const ğ‘2 ) (v128.const ğ‘3 ) v128.vternop
(if ğ‘ = vternop shape (ğ‘1 , ğ‘2 , ğ‘3 ))

Ë“â†’

(v128.const ğ‘)

ğ‘¡xğ‘.relaxed_laneselect
1. Assert: due to validation, three values of value type v128 are on the top of the stack.
2. Pop the value v128.const ğ‘3 from the stack.
3. Pop the value v128.const ğ‘2 from the stack.
4. Pop the value v128.const ğ‘1 from the stack.
5. Let ğ‘ be the bit width |ğ‘¡| of value type ğ‘¡.
6. Let ğ‘ be the result of computing irelaxed_laneselectğ‘¡xğ‘ (ğ‘1 , ğ‘2 , ğ‘3 ).
7. Push the value v128.const ğ‘ to the stack.
(v128.const ğ‘1 ) (v128.const ğ‘2 ) (v128.const ğ‘3 ) v128.relaxed_laneselect
(if ğ‘ = irelaxed_laneselectğ‘¡xğ‘ (ğ‘1 , ğ‘2 , ğ‘3 )*

Ë“â†’

(v128.const ğ‘)

ğ‘¡xğ‘.vrelop
1. Assert: due to validation, two values of value type v128 are on the top of the stack.
2. Pop the value v128.const ğ‘2 from the stack.
3. Pop the value v128.const ğ‘1 from the stack.
4. Let ğ‘–*1 be the result of computing lanesğ‘¡xğ‘ (ğ‘1 ).
5. Let ğ‘–*2 be the result of computing lanesğ‘¡xğ‘ (ğ‘2 ).
6. Let ğ‘–* be the result of computing vrelop ğ‘¡ (ğ‘–*1 , ğ‘–*2 ).
7. Let ğ‘— * be the result of computing extends 1,|ğ‘¡| (ğ‘–* ).
*
8. Let ğ‘ be the result of computing lanesâˆ’1
ğ‘¡xğ‘ (ğ‘— ).

138

Chapter 4. Execution

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

9. Push the value v128.const ğ‘ to the stack.
(v128.const ğ‘1 ) (v128.const ğ‘2 ) ğ‘¡xğ‘.vrelop Ë“â†’ (v128.const ğ‘)
s
(if ğ‘ = lanesâˆ’1
ğ‘¡xğ‘ (extend 1,|ğ‘¡| (vrelop ğ‘¡ (lanesğ‘¡xğ‘ (ğ‘1 ), lanesğ‘¡xğ‘ (ğ‘2 )))))
ğ‘¡xğ‘.vishiftop
1. Assert: due to validation, a value of value type i32 is on the top of the stack.
2. Pop the value i32.const ğ‘  from the stack.
3. Assert: due to validation, a value of value type v128 is on the top of the stack.
4. Pop the value v128.const ğ‘1 from the stack.
5. Let ğ‘–* be the result of computing lanesğ‘¡xğ‘ (ğ‘1 ).
6. Let ğ‘— * be the result of computing vishiftop ğ‘¡ (ğ‘–* , ğ‘ ğ‘ ).
*
7. Let ğ‘ be the result of computing lanesâˆ’1
ğ‘¡xğ‘ (ğ‘— ).

8. Push the value v128.const ğ‘ to the stack.
(v128.const ğ‘1 ) (i32.const ğ‘ ) ğ‘¡xğ‘.vishiftop
(if ğ‘–* = lanesğ‘¡xğ‘ (ğ‘1 )
* ğ‘
âˆ§ ğ‘ = lanesâˆ’1
ğ‘¡xğ‘ (vishiftop ğ‘¡ (ğ‘– , ğ‘  )))

Ë“â†’ (v128.const ğ‘)

shape.all_true
1. Assert: due to validation, a value of value type v128 is on the top of the stack.
2. Pop the value v128.const ğ‘ from the stack.
3. Let ğ‘–*1 be the result of computing lanesshape (ğ‘).
â‹€ï¸€
4. Let ğ‘– be the result of computing bool( (ğ‘–1 Ì¸= 0)* ).
5. Push the value i32.const ğ‘– onto the stack.
(v128.const ğ‘) shape.all_true Ë“â†’ (i32.const ğ‘–)
(if ğ‘–*1 = lanesâ‹€ï¸€shape (ğ‘)
âˆ§ ğ‘– = bool( (ğ‘–1 Ì¸= 0)* ))
ğ‘¡xğ‘.bitmask
1. Assert: due to validation, a value of value type v128 is on the top of the stack.
2. Pop the value v128.const ğ‘ from the stack.
3. Let ğ‘–ğ‘
1 be the result of computing lanesğ‘¡xğ‘ (ğ‘).
4. Let ğµ be the bit width |ğ‘¡| of value type ğ‘¡.
ğ‘
ğ‘
5. Let ğ‘–ğ‘
2 be the result of computing ilt_sğµ (ğ‘–1 , 0 ).
32âˆ’ğ‘
6. Let ğ‘— * be the concatenation of the two sequences ğ‘–ğ‘
.
2 and 0
*
7. Let ğ‘– be the result of computing ibitsâˆ’1
32 (ğ‘— ).

8. Push the value i32.const ğ‘– onto the stack.
(v128.const ğ‘) ğ‘¡xğ‘.bitmask Ë“â†’

(i32.const ğ‘–)

ğ‘
32âˆ’ğ‘
(if ğ‘– = ibitsâˆ’1
))
32 (ilt_s|ğ‘¡| (lanesğ‘¡xğ‘ (ğ‘), (0) )(0)

ğ‘¡2 xğ‘.narrow_ğ‘¡1 xğ‘€ _sx
1. Assert: due to syntax, ğ‘ = 2 Â· ğ‘€ .
2. Assert: due to validation, two values of value type v128 are on the top of the stack.
3. Pop the value v128.const ğ‘2 from the stack.
4. Let ğ‘–ğ‘€
2 be the result of computing lanesğ‘¡1 xğ‘€ (ğ‘2 ).
4.6. Instructions

139

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

sx
ğ‘€
5. Let ğ‘‘ğ‘€
2 be the result of computing narrow|ğ‘¡1 |,|ğ‘¡2 | (ğ‘–2 ).

6. Pop the value v128.const ğ‘1 from the stack.
7. Let ğ‘–ğ‘€
1 be the result of computing lanesğ‘¡1 xğ‘€ (ğ‘1 ).
sx
ğ‘€
8. Let ğ‘‘ğ‘€
1 be the result of computing narrow|ğ‘¡1 |,|ğ‘¡2 | (ğ‘–1 ).
ğ‘€
9. Let ğ‘— ğ‘ be the concatenation of the two sequences ğ‘‘ğ‘€
1 and ğ‘‘2 .
ğ‘
10. Let ğ‘ be the result of computing lanesâˆ’1
ğ‘¡2 xğ‘ (ğ‘— ).

11. Push the value v128.const ğ‘ onto the stack.
(v128.const ğ‘1 ) (v128.const ğ‘2 ) ğ‘¡2 xğ‘.narrow_ğ‘¡1 xğ‘€ _sx
sx
(if ğ‘‘ğ‘€
1 = narrow|ğ‘¡1 |,|ğ‘¡2 | (lanesğ‘¡1 xğ‘€ (ğ‘1 ))
sx
âˆ§ ğ‘‘ğ‘€
2 = narrow|ğ‘¡1 |,|ğ‘¡2 | (lanesğ‘¡1 xğ‘€ (ğ‘2 ))
âˆ’1
ğ‘€
âˆ§ ğ‘ = lanesğ‘¡2 xğ‘ (ğ‘‘ğ‘€
1 ğ‘‘2 ))

Ë“â†’ (v128.const ğ‘)

ğ‘¡2 xğ‘.vcvtop_ğ‘¡1 xğ‘€ _sx
1. Assert: due to syntax, ğ‘ = ğ‘€ .
2. Assert: due to validation, a value of value type v128 is on the top of the stack.
3. Pop the value v128.const ğ‘1 from the stack.
4. Let ğ‘–* be the result of computing lanesğ‘¡1 xğ‘€ (ğ‘1 ).
*
5. Let ğ‘— * be the result of computing vcvtop sx
|ğ‘¡1 |,|ğ‘¡2 | (ğ‘– ).
*
6. Let ğ‘ be the result of computing lanesâˆ’1
ğ‘¡2 xğ‘ (ğ‘— ).

7. Push the value v128.const ğ‘ onto the stack.
(v128.const ğ‘1 ) ğ‘¡2 xğ‘.vcvtop_ğ‘¡1 xğ‘€ _sx Ë“â†’ (v128.const ğ‘)
sx
(if ğ‘ = lanesâˆ’1
ğ‘¡2 xğ‘ (vcvtop |ğ‘¡1 |,|ğ‘¡2 | (lanesğ‘¡1 xğ‘€ (ğ‘1 ))))
ğ‘¡2 xğ‘.vcvtop_half _ğ‘¡1 xğ‘€ _sx ?
1. Assert: due to syntax, ğ‘ = ğ‘€/2.
2. Assert: due to validation, a value of value type v128 is on the top of the stack.
3. Pop the value v128.const ğ‘1 from the stack.
4. Let ğ‘–* be the result of computing lanesğ‘¡1 xğ‘€ (ğ‘1 ).
5. If half is low, then:
a. Let ğ‘— * be the sequence ğ‘–* [0 : ğ‘ ].
6. Else:
a. Let ğ‘— * be the sequence ğ‘–* [ğ‘ : ğ‘ ].
?

*
7. Let ğ‘˜ * be the result of computing vcvtop sx
|ğ‘¡1 |,|ğ‘¡2 | (ğ‘— ).
*
8. Let ğ‘ be the result of computing lanesâˆ’1
ğ‘¡2 xğ‘ (ğ‘˜ ).

9. Push the value v128.const ğ‘ onto the stack.
(v128.const ğ‘1 ) ğ‘¡2 xğ‘.vcvtop_half _ğ‘¡1 xğ‘€ _sx ? Ë“â†’ (v128.const ğ‘)
sx ?
(if ğ‘ = lanesâˆ’1
ğ‘¡2 xğ‘ (vcvtop |ğ‘¡1 |,|ğ‘¡2 | (lanesğ‘¡1 xğ‘€ (ğ‘1 )[half (0, ğ‘ ) : ğ‘ ])))
where:
low(ğ‘¥, ğ‘¦)
high(ğ‘¥, ğ‘¦)

140

= ğ‘¥
= ğ‘¦

Chapter 4. Execution

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

ğ‘¡2 xğ‘.vcvtop_ğ‘¡1 xğ‘€ _sx ? _zero
1. Assert: due to syntax, ğ‘ = 2 Â· ğ‘€ .
2. Assert: due to validation, a value of value type v128 is on the top of the stack.
3. Pop the value v128.const ğ‘1 from the stack.
4. Let ğ‘–* be the result of computing lanesğ‘¡1 xğ‘€ (ğ‘1 ).
?

*
5. Let ğ‘— * be the result of computing vcvtop sx
|ğ‘¡1 |,|ğ‘¡2 | (ğ‘– ).

6. Let ğ‘˜ * be the concatenation of the two sequences ğ‘— * and 0ğ‘€ .
*
7. Let ğ‘ be the result of computing lanesâˆ’1
ğ‘¡2 xğ‘ (ğ‘˜ ).

8. Push the value v128.const ğ‘ onto the stack.
(v128.const ğ‘1 ) ğ‘¡2 xğ‘.vcvtop_ğ‘¡1 xğ‘€ _sx ? _zero Ë“â†’ (v128.const ğ‘)
sx ?
ğ‘€
(if ğ‘ = lanesâˆ’1
ğ‘¡2 xğ‘ (vcvtop |ğ‘¡1 |,|ğ‘¡2 | (lanesğ‘¡1 xğ‘€ (ğ‘1 )) 0 ))
i32x4.dot_i16x8_s
1. Assert: due to validation, two values of value type v128 are on the top of the stack.
2. Pop the value v128.const ğ‘2 from the stack.
3. Pop the value v128.const ğ‘1 from the stack.
4. Let ğ‘–*1 be the result of computing lanesi16x8 (ğ‘1 ).
5. Let ğ‘—1* be the result of computing extends 16,32 (ğ‘–*1 ).
6. Let ğ‘–*2 be the result of computing lanesi16x8 (ğ‘2 ).
7. Let ğ‘—2* be the result of computing extends 16,32 (ğ‘–*2 ).
8. Let (ğ‘˜1 ğ‘˜2 )* be the result of computing imul32 (ğ‘—1* , ğ‘—2* ).
9. Let ğ‘˜ * be the result of computing iadd32 (ğ‘˜1 , ğ‘˜2 )* .
*
10. Let ğ‘ be the result of computing lanesâˆ’1
i32x4 (ğ‘˜ ).

11. Push the value v128.const ğ‘ onto the stack.
(v128.const ğ‘1 ) (v128.const ğ‘2 ) i32x4.dot_i16x8_s Ë“â†’ (v128.const ğ‘)
(if (ğ‘–1 ğ‘–2 )* = imul32 (extends 16,32 (lanesi16x8 (ğ‘1 )), extends 16,32 (lanesi16x8 (ğ‘2 )))
âˆ§ ğ‘— * = iadd32 (ğ‘–1 , ğ‘–2 )*
*
âˆ§ ğ‘ = lanesâˆ’1
i32x4 (ğ‘— ))
i16x8.relaxed_dot_i8x16_i7x16_s
1. Assert: due to validation, two values of value type v128 are on the top of the stack.
2. Pop the value v128.const ğ‘2 from the stack.
3. Pop the value v128.const ğ‘1 from the stack.
4. Let (ğ‘–1 ğ‘–2 )8 be the result of computing irelaxed_dot_mul8,16 (lanesi8x16 (ğ‘1 ), lanesi8x16 (ğ‘2 ))
5. Let ğ‘— 8 be the result of computing iadd_sat_s16 (ğ‘–1 , ğ‘–2 )8 .
8
6. Let ğ‘ be the result of computing lanesâˆ’1
i16x8 (ğ‘— ).

7. Push the value v128.const ğ‘ onto the stack.
(v128.const ğ‘1 ) (v128.const ğ‘2 ) i16x8.relaxed_dot_i8x16_i7x16_s Ë“â†’ (v128.const ğ‘)
(if (ğ‘–1 ğ‘–2 )8 = irelaxed_dot_mul8,16 (lanesi8x16 (ğ‘1 ), lanesi8x16 (ğ‘2 ))
âˆ§ ğ‘— 8 = iadd_sat_s16 (ğ‘–1 , ğ‘–2 )8
8
âˆ§ ğ‘ = lanesâˆ’1
i16x8 (ğ‘— ))

4.6. Instructions

141

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

i32x4.relaxed_dot_i8x16_i7x16_add_s
1. Assert: due to validation, three values of value type v128 are on the top of the stack.
2. Pop the value v128.const ğ‘3 from the stack.
3. Pop the value v128.const ğ‘2 from the stack.
4. Pop the value v128.const ğ‘1 from the stack.
5. Let (ğ‘–1 ğ‘–2 )8 be the result of computing irelaxed_dot_mul8,16 (lanesi8x16 (ğ‘1 ), lanesi8x16 (ğ‘2 ))
6. Let (ğ‘—1 ğ‘—2 )4 be the result of computing iadd_sat_s16 (ğ‘–1 , ğ‘–2 )8 .
7. Let ğ‘— 4 be the result of computing iadd32 (extends 16,32 (ğ‘—1 ), extends 16,32 (ğ‘—2 ))4 .
8. Let ğ‘˜ 4 be the result of computing lanesi32x4 (ğ‘3 ).
9. Let ğ‘™4 be the result of computing iadd32 (ğ‘—, ğ‘˜)4 .
4
10. Let ğ‘ be the result of computing lanesâˆ’1
i32x4 (ğ‘™ ).

11. Push the value v128.const ğ‘ onto the stack.
(v128.const ğ‘1 ) (v128.const ğ‘2 ) (v128.const ğ‘3 ) i32x4.relaxed_dot_i8x16_i7x16_add_s Ë“â†’
(if (ğ‘–1 ğ‘–2 )8 = irelaxed_dot_mul8,16 (lanesi8x16 (ğ‘1 ), lanesi8x16 (ğ‘2 ))
âˆ§ (ğ‘—1 ğ‘—2 )4 = iadd_sat_s16 (ğ‘–1 , ğ‘–2 )8
âˆ§ ğ‘— 4 = iadd32 (extends 16,32 (ğ‘—1 ), extends 16,32 (ğ‘—2 ))4
âˆ§ ğ‘˜ 4 = lanesi32x4 (ğ‘3 )
âˆ§ ğ‘™4 = iadd32 (ğ‘—, ğ‘˜)4
4
âˆ§ ğ‘ = lanesâˆ’1
i32x4 (ğ‘™ ))

(v128.const ğ‘)

ğ‘¡2 xğ‘.extmul_half _ğ‘¡1 xğ‘€ _sx
1. Assert: due to syntax, ğ‘ = ğ‘€/2.
2. Assert: due to validation, two values of value type v128 are on the top of the stack.
3. Pop the value v128.const ğ‘2 from the stack.
4. Pop the value v128.const ğ‘1 from the stack.
5. Let ğ‘–*1 be the result of computing lanesğ‘¡1 xğ‘€ (ğ‘1 ).
6. Let ğ‘–*2 be the result of computing lanesğ‘¡1 xğ‘€ (ğ‘2 ).
7. If half is low, then:
a. Let ğ‘—1* be the sequence ğ‘–*1 [0 : ğ‘ ].
b. Let ğ‘—2* be the sequence ğ‘–*2 [0 : ğ‘ ].
8. Else:
a. Let ğ‘—1* be the sequence ğ‘–*1 [ğ‘ : ğ‘ ].
b. Let ğ‘—2* be the sequence ğ‘–*2 [ğ‘ : ğ‘ ].
*
9. Let ğ‘˜1* be the result of computing extendsx
|ğ‘¡1 |,|ğ‘¡2 | (ğ‘—1 ).
*
10. Let ğ‘˜2* be the result of computing extendsx
|ğ‘¡1 |,|ğ‘¡2 | (ğ‘—2 ).

11. Let ğ‘˜ * be the result of computing imul|ğ‘¡2 | (ğ‘˜1* , ğ‘˜2* ).
*
12. Let ğ‘ be the result of computing lanesâˆ’1
ğ‘¡2 xğ‘ (ğ‘˜ ).

13. Push the value v128.const ğ‘ onto the stack.
(v128.const ğ‘1 ) (v128.const ğ‘2 ) ğ‘¡2 xğ‘.extmul_half _ğ‘¡1 xğ‘€ _sx

Ë“â†’ (v128.const ğ‘)

*

(if ğ‘– = lanesğ‘¡1 xğ‘€ (ğ‘1 )[half (0, ğ‘ ) : ğ‘ ]
âˆ§ ğ‘— * = lanesğ‘¡1 xğ‘€ (ğ‘2 )[half (0, ğ‘ ) : ğ‘ ]
sx
*
sx
*
âˆ§ ğ‘ = lanesâˆ’1
ğ‘¡2 xğ‘ (imul|ğ‘¡2 | (extend|ğ‘¡1 |,|ğ‘¡2 | (ğ‘– ), extend|ğ‘¡1 |,|ğ‘¡2 | (ğ‘— ))))

142

Chapter 4. Execution

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

where:
low(ğ‘¥, ğ‘¦)
high(ğ‘¥, ğ‘¦)

= ğ‘¥
= ğ‘¦

ğ‘¡2 xğ‘.extadd_pairwise_ğ‘¡1 xğ‘€ _sx
1. Assert: due to syntax, ğ‘ = ğ‘€/2.
2. Assert: due to validation, a value of value type v128 is on the top of the stack.
3. Pop the value v128.const ğ‘1 from the stack.
4. Let ğ‘–* be the result of computing lanesğ‘¡1 xğ‘€ (ğ‘1 ).
*
5. Let (ğ‘—1 ğ‘—2 )* be the result of computing extendsx
|ğ‘¡1 |,|ğ‘¡2 | (ğ‘– ).

6. Let ğ‘˜ * be the result of computing iadd|ğ‘¡2 | (ğ‘—1 , ğ‘—2 )* .
*
7. Let ğ‘ be the result of computing lanesâˆ’1
ğ‘¡2 xğ‘ (ğ‘˜ ).

8. Push the value v128.const ğ‘ to the stack.
(v128.const ğ‘1 ) ğ‘¡2 xğ‘.extadd_pairwise_ğ‘¡1 xğ‘€ _sx
(if (ğ‘–1 ğ‘–2 )* = extendsx
|ğ‘¡1 |,|ğ‘¡2 | (lanesğ‘¡1 xğ‘€ (ğ‘1 ))
âˆ§ ğ‘— * = iadd|ğ‘¡2 | (ğ‘–1 , ğ‘–2 )*
*
âˆ§ ğ‘ = lanesâˆ’1
ğ‘¡2 xğ‘ (ğ‘— ))

Ë“â†’ (v128.const ğ‘)

4.6.4 Parametric Instructions
drop
1. Assert: due to validation, a value is on the top of the stack.
2. Pop the value val from the stack.
val drop Ë“â†’ ğœ–
select (ğ‘¡* )?
1. Assert: due to validation, a value of value type i32 is on the top of the stack.
2. Pop the value i32.const ğ‘ from the stack.
3. Assert: due to validation, two more values (of the same value type) are on the top of the stack.
4. Pop the value val 2 from the stack.
5. Pop the value val 1 from the stack.
6. If ğ‘ is not 0, then:
a. Push the value val 1 back to the stack.
7. Else:
a. Push the value val 2 back to the stack.
val 1 val 2 (i32.const ğ‘) (select ğ‘¡? ) Ë“â†’
val 1 val 2 (i32.const ğ‘) (select ğ‘¡? ) Ë“â†’

val 1
val 2

(if ğ‘ Ì¸= 0)
(if ğ‘ = 0)

Ã² Note
In future versions of WebAssembly, select may allow more than one value per choice.

4.6. Instructions

143

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

4.6.5 Variable Instructions
local.get ğ‘¥
1. Let ğ¹ be the current frame.
2. Assert: due to validation, ğ¹.locals[ğ‘¥] exists and is non-empty.
3. Let val be the value ğ¹.locals[ğ‘¥].
4. Push the value val to the stack.
ğ¹ ; (local.get ğ‘¥) Ë“â†’

ğ¹ ; val

(if ğ¹.locals[ğ‘¥] = val )

local.set ğ‘¥
1. Let ğ¹ be the current frame.
2. Assert: due to validation, ğ¹.locals[ğ‘¥] exists.
3. Assert: due to validation, a value is on the top of the stack.
4. Pop the value val from the stack.
5. Replace ğ¹.locals[ğ‘¥] with the value val .
ğ¹ ; val (local.set ğ‘¥) Ë“â†’ ğ¹ â€² ; ğœ–

(if ğ¹ â€² = ğ¹ with locals[ğ‘¥] = val )

local.tee ğ‘¥
1. Assert: due to validation, a value is on the top of the stack.
2. Pop the value val from the stack.
3. Push the value val to the stack.
4. Push the value val to the stack.
5. Execute the instruction local.set ğ‘¥.
val (local.tee ğ‘¥) Ë“â†’ val val (local.set ğ‘¥)
global.get ğ‘¥
1. Let ğ¹ be the current frame.
2. Assert: due to validation, ğ¹.module.globaladdrs[ğ‘¥] exists.
3. Let ğ‘ be the global address ğ¹.module.globaladdrs[ğ‘¥].
4. Assert: due to validation, ğ‘†.globals[ğ‘] exists.
5. Let glob be the global instance ğ‘†.globals[ğ‘].
6. Let val be the value glob.value.
7. Push the value val to the stack.
ğ‘†; ğ¹ ; (global.get ğ‘¥) Ë“â†’ ğ‘†; ğ¹ ; val
(if ğ‘†.globals[ğ¹.module.globaladdrs[ğ‘¥]].value = val )
global.set ğ‘¥
1. Let ğ¹ be the current frame.
2. Assert: due to validation, ğ¹.module.globaladdrs[ğ‘¥] exists.
3. Let ğ‘ be the global address ğ¹.module.globaladdrs[ğ‘¥].
4. Assert: due to validation, ğ‘†.globals[ğ‘] exists.
5. Let glob be the global instance ğ‘†.globals[ğ‘].
144

Chapter 4. Execution

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

6. Assert: due to validation, a value is on the top of the stack.
7. Pop the value val from the stack.
8. Replace glob.value with the value val .
ğ‘†; ğ¹ ; val (global.set ğ‘¥) Ë“â†’ ğ‘† â€² ; ğ¹ ; ğœ–
(if ğ‘† â€² = ğ‘† with globals[ğ¹.module.globaladdrs[ğ‘¥]].value = val )
Ã² Note
Validation ensures that the global is, in fact, marked as mutable.

4.6.6 Table Instructions
table.get ğ‘¥
1. Let ğ¹ be the current frame.
2. Assert: due to validation, ğ¹.module.tableaddrs[ğ‘¥] exists.
3. Let ğ‘ be the table address ğ¹.module.tableaddrs[ğ‘¥].
4. Assert: due to validation, ğ‘†.tables[ğ‘] exists.
5. Let tab be the table instance ğ‘†.tables[ğ‘].
6. Assert: due to validation, a value of some address type at is on the top of the stack.
7. Pop the value at.const ğ‘– from the stack.
8. If ğ‘– is not smaller than the length of tab.elem, then:
a. Trap.
9. Let val be the value tab.elem[ğ‘–].
10. Push the value val to the stack.
ğ‘†; ğ¹ ; (at.const ğ‘–) (table.get ğ‘¥) Ë“â†’ ğ‘†; ğ¹ ; val
(if ğ‘†.tables[ğ¹.module.tableaddrs[ğ‘¥]].elem[ğ‘–] = val )
ğ‘†; ğ¹ ; (at.const ğ‘–) (table.get ğ‘¥) Ë“â†’ ğ‘†; ğ¹ ; trap
(otherwise)
table.set ğ‘¥
1. Let ğ¹ be the current frame.
2. Assert: due to validation, ğ¹.module.tableaddrs[ğ‘¥] exists.
3. Let ğ‘ be the table address ğ¹.module.tableaddrs[ğ‘¥].
4. Assert: due to validation, ğ‘†.tables[ğ‘] exists.
5. Let tab be the table instance ğ‘†.tables[ğ‘].
6. Assert: due to validation, a reference value is on the top of the stack.
7. Pop the value val from the stack.
8. Assert: due to validation, a value of some address type at is on the top of the stack.
9. Pop the value at.const ğ‘– from the stack.
10. If ğ‘– is not smaller than the length of tab.elem, then:
a. Trap.
11. Replace the element tab.elem[ğ‘–] with val .
4.6. Instructions

145

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

ğ‘†; ğ¹ ; (at.const ğ‘–) val (table.set ğ‘¥) Ë“â†’ ğ‘† â€² ; ğ¹ ; ğœ–
(if ğ‘† â€² = ğ‘† with tables[ğ¹.module.tableaddrs[ğ‘¥]].elem[ğ‘–] = val )
ğ‘†; ğ¹ ; (at.const ğ‘–) val (table.set ğ‘¥) Ë“â†’ ğ‘†; ğ¹ ; trap
(otherwise)
table.size ğ‘¥
1. Let ğ¹ be the current frame.
2. Assert: due to validation, ğ¹.module.tableaddrs[ğ‘¥] exists.
3. Let ğ‘ be the table address ğ¹.module.tableaddrs[ğ‘¥].
4. Assert: due to validation, ğ‘†.tables[ğ‘] exists.
5. Let tab be the table instance ğ‘†.tables[ğ‘].
6. Let at limits be the table type tab.type.
7. Let sz be the length of tab.elem.
8. Push the value at.const sz to the stack.
ğ‘†; ğ¹ ; (table.size ğ‘¥) Ë“â†’ ğ‘†; ğ¹ ; (at.const sz )
(if |ğ‘†.tables[ğ¹.module.tableaddrs[ğ‘¥]].elem| = sz
âˆ§ğ‘†.tables[ğ¹.module.tableaddrs[ğ‘¥]].type = at lim ğ‘¡)

table.grow ğ‘¥
1. Let ğ¹ be the current frame.
2. Assert: due to validation, ğ¹.module.tableaddrs[ğ‘¥] exists.
3. Let ğ‘ be the table address ğ¹.module.tableaddrs[ğ‘¥].
4. Assert: due to validation, ğ‘†.tables[ğ‘] exists.
5. Let tab be the table instance ğ‘†.tables[ğ‘].
6. Let sz be the length of ğ‘†.tables[ğ‘].
7. Assert: due to validation, a value of some address type at is on the top of the stack.
8. Pop the value ğ‘¡.const ğ‘› from the stack.
9. Assert: due to validation, a reference value is on the top of the stack.
10. Pop the value val from the stack.
11. Let err be the value 2|at| âˆ’ 1, for which signed|at| (err ) is âˆ’1.
12. Either:
a. If growing tab by ğ‘› entries with initialization value val succeeds, then:
i. Push the value at.const sz to the stack.
b. Else:
i. Push the value at.const err to the stack.
13. Or:
a. push the value at.const err to the stack.

146

Chapter 4. Execution

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

ğ‘†; ğ¹ ; val (at.const ğ‘›) (table.grow ğ‘¥) Ë“â†’ ğ‘† â€² ; ğ¹ ; (at.const sz )
(if ğ¹.module.tableaddrs[ğ‘¥] = ğ‘
âˆ§ sz = |ğ‘†.tables[ğ‘].elem|
âˆ§ ğ‘† â€² = ğ‘† with tables[ğ‘] = growtable(ğ‘†.tables[ğ‘], ğ‘›, val ))
ğ‘†; ğ¹ ; val (at.const ğ‘›) (table.grow ğ‘¥) Ë“â†’ ğ‘†; ğ¹ ; (at.const signedâˆ’1
|at| (âˆ’1))
Ã² Note
The table.grow instruction is non-deterministic. It may either succeed, returning the old table size sz , or fail,
returning âˆ’1. Failure must occur if the referenced table instance has a maximum size defined that would be
exceeded. However, failure can occur in other cases as well. In practice, the choice depends on the resources
available to the embedder.
table.fill ğ‘¥
1. Let ğ¹ be the current frame.
2. Assert: due to validation, ğ¹.module.tableaddrs[ğ‘¥] exists.
3. Let ta be the table address ğ¹.module.tableaddrs[ğ‘¥].
4. Assert: due to validation, ğ‘†.tables[ta] exists.
5. Let tab be the table instance ğ‘†.tables[ta].
6. Assert: due to validation, a value of some address type at is on the top of the stack.
7. Pop the value at.const ğ‘› from the stack.
8. Assert: due to validation, a reference value is on the top of the stack.
9. Pop the value val from the stack.
10. Assert: due to validation, a value of address type at is on the top of the stack.
11. Pop the value at.const ğ‘– from the stack.
12. If ğ‘– + ğ‘› is larger than the length of tab.elem, then:
a. Trap.
13. If ğ‘› is 0, then:
a. Return.
14. Push the value at.const ğ‘– to the stack.
15. Push the value val to the stack.
16. Execute the instruction table.set ğ‘¥.
17. Push the value at.const (ğ‘– + 1) to the stack.
18. Push the value val to the stack.
19. Push the value at.const (ğ‘› âˆ’ 1) to the stack.
20. Execute the instruction table.fill ğ‘¥.
ğ‘†; ğ¹ ; (at.const ğ‘–) val (at.const ğ‘›) (table.fill ğ‘¥) Ë“â†’ ğ‘†; ğ¹ ; trap
(if ğ‘– + ğ‘› > |ğ‘†.tables[ğ¹.module.tableaddrs[ğ‘¥]].elem|)
ğ‘†; ğ¹ ; (at.const ğ‘–) val (at.const 0) (table.fill ğ‘¥)
(otherwise)

Ë“â†’

ğ‘†; ğ¹ ; ğœ–

ğ‘†; ğ¹ ; (at.const ğ‘–) val (at.const ğ‘› + 1) (table.fill ğ‘¥) Ë“â†’
ğ‘†; ğ¹ ; (at.const ğ‘–) val (table.set ğ‘¥)
(at.const ğ‘– + 1) val (at.const ğ‘›) (table.fill ğ‘¥)
(otherwise)
4.6. Instructions

147

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

table.copy ğ‘¥ ğ‘¦
1. Let ğ¹ be the current frame.
2. Assert: due to validation, ğ¹.module.tableaddrs[ğ‘¥] exists.
3. Let ta ğ‘¥ be the table address ğ¹.module.tableaddrs[ğ‘¥].
4. Assert: due to validation, ğ‘†.tables[ta ğ‘¥ ] exists.
5. Let tab ğ‘¥ be the table instance ğ‘†.tables[ta ğ‘¥ ].
6. Assert: due to validation, ğ¹.module.tableaddrs[ğ‘¦] exists.
7. Let ta ğ‘¦ be the table address ğ¹.module.tableaddrs[ğ‘¦].
8. Assert: due to validation, ğ‘†.tables[ta ğ‘¦ ] exists.
9. Let tab ğ‘¦ be the table instance ğ‘†.tables[ta ğ‘¦ ].
10. Assert: due to validation, a value of some address type at ğ‘› is on the top of the stack.
11. Pop the value at ğ‘› .const ğ‘› from the stack.
12. Assert: due to validation, a value of some address type at ğ‘  is on the top of the stack.
13. Pop the value at ğ‘  .const ğ‘  from the stack.
14. Assert: due to validation, a value of some address type at ğ‘‘ is on the top of the stack.
15. Pop the value at ğ‘‘ .const ğ‘‘ from the stack.
16. If ğ‘  + ğ‘› is larger than the length of tab ğ‘¦ .elem or ğ‘‘ + ğ‘› is larger than the length of tab ğ‘¥ .elem, then:
a. Trap.
20. If ğ‘› = 0, then:
a. Return.
21. If ğ‘‘ â‰¤ ğ‘ , then:
a. Push the value at ğ‘‘ .const ğ‘‘ to the stack.
b. Push the value at ğ‘  .const ğ‘  to the stack.
c. Execute the instruction table.get ğ‘¦.
d. Execute the instruction table.set ğ‘¥.
e. Assert: due to the earlier check against the table size, ğ‘‘ + 1 < 232 .
f. Push the value at ğ‘‘ .const (ğ‘‘ + 1) to the stack.
g. Assert: due to the earlier check against the table size, ğ‘  + 1 < 232 .
h. Push the value at ğ‘  .const (ğ‘  + 1) to the stack.
22. Else:
a. Assert: due to the earlier check against the table size, ğ‘‘ + ğ‘› âˆ’ 1 < 232 .
b. Push the value at ğ‘‘ .const (ğ‘‘ + ğ‘› âˆ’ 1) to the stack.
c. Assert: due to the earlier check against the table size, ğ‘  + ğ‘› âˆ’ 1 < 232 .
d. Push the value at ğ‘  .const (ğ‘  + ğ‘› âˆ’ 1) to the stack.
c. Execute the instruction table.get ğ‘¦.
f. Execute the instruction table.set ğ‘¥.
g. Push the value at ğ‘‘ .const ğ‘‘ to the stack.
h. Push the value at ğ‘  .const ğ‘  to the stack.
23. Push the value at ğ‘› .const (ğ‘› âˆ’ 1) to the stack.

148

Chapter 4. Execution

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

24. Execute the instruction table.copy ğ‘¥ ğ‘¦.
ğ‘†; ğ¹ ; (at ğ‘‘ .const ğ‘‘) (at ğ‘  .const ğ‘ ) (at ğ‘› .const ğ‘›) (table.copy ğ‘¥ ğ‘¦)
(if ğ‘  + ğ‘› > |ğ‘†.tables[ğ¹.module.tableaddrs[ğ‘¦]].elem|
âˆ¨ ğ‘‘ + ğ‘› > |ğ‘†.tables[ğ¹.module.tableaddrs[ğ‘¥]].elem|)

Ë“â†’

ğ‘†; ğ¹ ; trap

ğ‘†; ğ¹ ; (at ğ‘‘ .const ğ‘‘) (at ğ‘  .const ğ‘ ) (at ğ‘› .const 0) (table.copy ğ‘¥ ğ‘¦)
(otherwise)

Ë“â†’

ğ‘†; ğ¹ ; ğœ–

ğ‘†; ğ¹ ; (at ğ‘‘ .const ğ‘‘) (at ğ‘  .const ğ‘ ) (at ğ‘› .const ğ‘› + 1) (table.copy ğ‘¥ ğ‘¦) Ë“â†’
ğ‘†; ğ¹ ; (at ğ‘‘ .const ğ‘‘) (at ğ‘  .const ğ‘ ) (table.get ğ‘¦) (table.set ğ‘¥)
(at ğ‘‘ .const ğ‘‘ + 1) (at ğ‘  .const ğ‘  + 1) (at ğ‘› .const ğ‘›) (table.copy ğ‘¥ ğ‘¦)
(otherwise, if ğ‘‘ â‰¤ ğ‘ )
ğ‘†; ğ¹ ; (at ğ‘‘ .const ğ‘‘) (at ğ‘  .const ğ‘ ) (at ğ‘› .const ğ‘› + 1) (table.copy ğ‘¥ ğ‘¦) Ë“â†’
ğ‘†; ğ¹ ; (at ğ‘‘ .const ğ‘‘ + ğ‘›) (at ğ‘  .const ğ‘  + ğ‘›) (table.get ğ‘¦) (table.set ğ‘¥)
(at ğ‘‘ .const ğ‘‘) (at ğ‘  .const ğ‘ ) (at ğ‘› .const ğ‘›) (table.copy ğ‘¥ ğ‘¦)
(otherwise, if ğ‘‘ > ğ‘ )
table.init ğ‘¥ ğ‘¦
1. Let ğ¹ be the current frame.
2. Assert: due to validation, ğ¹.module.tableaddrs[ğ‘¥] exists.
3. Let ta be the table address ğ¹.module.tableaddrs[ğ‘¥].
4. Assert: due to validation, ğ‘†.tables[ta] exists.
5. Let tab be the table instance ğ‘†.tables[ta].
6. Assert: due to validation, ğ¹.module.elemaddrs[ğ‘¦] exists.
7. Let ea be the element address ğ¹.module.elemaddrs[ğ‘¦].
8. Assert: due to validation, ğ‘†.elems[ea] exists.
9. Let elem be the element instance ğ‘†.elems[ea].
10. Assert: due to validation, a value of value type i32 is on the top of the stack.
11. Pop the value i32.const ğ‘› from the stack.
12. Assert: due to validation, a value of value type i32 is on the top of the stack.
13. Pop the value i32.const ğ‘  from the stack.
14. Assert: due to validation, a value of some address type at is on the top of the stack.
15. Pop the value at.const ğ‘‘ from the stack.
16. If ğ‘  + ğ‘› is larger than the length of elem.elem or ğ‘‘ + ğ‘› is larger than the length of tab.elem, then:
a. Trap.
17. If ğ‘› = 0, then:
a. Return.
18. Let val be the reference value elem.elem[ğ‘ ].
19. Push the value at.const ğ‘‘ to the stack.
20. Push the value val to the stack.
21. Execute the instruction table.set ğ‘¥.
22. Assert: due to the earlier check against the table size, ğ‘‘ + 1 < 232 .
23. Push the value at.const (ğ‘‘ + 1) to the stack.
24. Assert: due to the earlier check against the segment size, ğ‘  + 1 < 232 .

4.6. Instructions

149

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

25. Push the value i32.const (ğ‘  + 1) to the stack.
26. Push the value i32.const (ğ‘› âˆ’ 1) to the stack.
27. Execute the instruction table.init ğ‘¥ ğ‘¦.
ğ‘†; ğ¹ ; (at.const ğ‘‘) (i32.const ğ‘ ) (i32.const ğ‘›) (table.init ğ‘¥ ğ‘¦)
(if ğ‘  + ğ‘› > |ğ‘†.elems[ğ¹.module.elemaddrs[ğ‘¦]].elem|
âˆ¨ ğ‘‘ + ğ‘› > |ğ‘†.tables[ğ¹.module.tableaddrs[ğ‘¥]].elem|)

Ë“â†’

ğ‘†; ğ¹ ; trap

ğ‘†; ğ¹ ; (at.const ğ‘‘) (i32.const ğ‘ ) (i32.const 0) (table.init ğ‘¥ ğ‘¦)
(otherwise)

Ë“â†’

ğ‘†; ğ¹ ; ğœ–

ğ‘†; ğ¹ ; (at.const ğ‘‘) (i32.const ğ‘ ) (i32.const ğ‘› + 1) (table.init ğ‘¥ ğ‘¦) Ë“â†’
ğ‘†; ğ¹ ; (at.const ğ‘‘) val (table.set ğ‘¥)
(at.const ğ‘‘ + 1) (i32.const ğ‘  + 1) (i32.const ğ‘›) (table.init ğ‘¥ ğ‘¦)
(otherwise, if val = ğ‘†.elems[ğ¹.module.elemaddrs[ğ‘¦]].elem[ğ‘ ])
elem.drop ğ‘¥
1. Let ğ¹ be the current frame.
2. Assert: due to validation, ğ¹.module.elemaddrs[ğ‘¥] exists.
3. Let ğ‘ be the element address ğ¹.module.elemaddrs[ğ‘¥].
4. Assert: due to validation, ğ‘†.elems[ğ‘] exists.
5. Replace ğ‘†.elems[ğ‘].elem with ğœ–.
ğ‘†; ğ¹ ; (elem.drop ğ‘¥) Ë“â†’ ğ‘† â€² ; ğ¹ ; ğœ–
(if ğ‘† â€² = ğ‘† with elems[ğ¹.module.elemaddrs[ğ‘¥]].elem = ğœ–)

4.6.7 Memory Instructions
Ã² Note
The alignment memarg.align in load and store instructions does not affect the semantics. It is an indication
that the offset ea at which the memory is accessed is intended to satisfy the property ea mod 2memarg.align = 0.
A WebAssembly implementation can use this hint to optimize for the intended use. Unaligned access violating
that property is still allowed and must succeed regardless of the annotation. However, it may be substantially
slower on some hardware.
ğ‘¡.load ğ‘¥ memarg and ğ‘¡.loadğ‘ _sx ğ‘¥ memarg
1. Let ğ¹ be the current frame.
2. Assert: due to validation, ğ¹.module.memaddrs[ğ‘¥] exists.
3. Let ğ‘ be the memory address ğ¹.module.memaddrs[ğ‘¥].
4. Assert: due to validation, ğ‘†.mems[ğ‘] exists.
5. Let mem be the memory instance ğ‘†.mems[ğ‘].
6. Assert: due to validation, a value of some address type at is on the top of the stack.
7. Pop the value at.const ğ‘– from the stack.
8. Let ea be the integer ğ‘– + memarg.offset.
9. If ğ‘ is not part of the instruction, then:
a. Let ğ‘ be the bit width |ğ‘¡| of number type ğ‘¡.

150

Chapter 4. Execution

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

10. If ea + ğ‘/8 is larger than the length of mem.data, then:
a. Trap.
11. Let ğ‘* be the byte sequence mem.data[ea : ğ‘/8].
12. If ğ‘ and sx are part of the instruction, then:
a. Let ğ‘› be the integer for which bytesiğ‘ (ğ‘›) = ğ‘* .
b. Let ğ‘ be the result of computing extendsx
ğ‘,|ğ‘¡| (ğ‘›).
13. Else:
a. Let ğ‘ be the constant for which bytesğ‘¡ (ğ‘) = ğ‘* .
14. Push the value ğ‘¡.const ğ‘ to the stack.
ğ‘†; ğ¹ ; (at.const ğ‘–) (ğ‘¡.load ğ‘¥ memarg) Ë“â†’ ğ‘†; ğ¹ ; (ğ‘¡.const ğ‘)
(if ea = ğ‘– + memarg.offset
âˆ§ ea + |ğ‘¡|/8 â‰¤ |ğ‘†.mems[ğ¹.module.memaddrs[ğ‘¥]].data|
âˆ§ bytesğ‘¡ (ğ‘) = ğ‘†.mems[ğ¹.module.memaddrs[ğ‘¥]].data[ea : |ğ‘¡|/8])
ğ‘†; ğ¹ ; (at.const ğ‘–) (ğ‘¡.loadğ‘ _sx ğ‘¥ memarg) Ë“â†’ ğ‘†; ğ¹ ; (ğ‘¡.const extendsx
ğ‘,|ğ‘¡| (ğ‘›))
(if ea = ğ‘– + memarg.offset
âˆ§ ea + ğ‘/8 â‰¤ |ğ‘†.mems[ğ¹.module.memaddrs[ğ‘¥]].data|
âˆ§ bytesiğ‘ (ğ‘›) = ğ‘†.mems[ğ¹.module.memaddrs[ğ‘¥]].data[ea : ğ‘/8])
ğ‘†; ğ¹ ; (at.const ğ‘–) (ğ‘¡.load(ğ‘ _sx )? ğ‘¥ memarg) Ë“â†’ ğ‘†; ğ¹ ; trap
(otherwise)
v128.loadğ‘€ xğ‘ _sx ğ‘¥ memarg
1. Let ğ¹ be the current frame.
2. Assert: due to validation, ğ¹.module.memaddrs[ğ‘¥] exists.
3. Let ğ‘ be the memory address ğ¹.module.memaddrs[ğ‘¥].
4. Assert: due to validation, ğ‘†.mems[ğ‘] exists.
5. Let mem be the memory instance ğ‘†.mems[ğ‘].
6. Assert: due to validation, a value of some address type at is on the top of the stack.
7. Pop the value at.const ğ‘– from the stack.
8. Let ea be the integer ğ‘– + memarg.offset.
9. If ea + ğ‘€ Â· ğ‘/8 is larger than the length of mem.data, then:
a. Trap.
10. Let ğ‘* be the byte sequence mem.data[ea : ğ‘€ Â· ğ‘/8].
11. Let ğ‘šğ‘˜ be the integer for which bytesiğ‘€ (ğ‘šğ‘˜ ) = ğ‘* [ğ‘˜ Â· ğ‘€/8 : ğ‘€/8].
12. Let ğ‘Š be the integer ğ‘€ Â· 2.
13. Let ğ‘›ğ‘˜ be the result of computing extendsx
ğ‘€,ğ‘Š (ğ‘šğ‘˜ ).
14. Let ğ‘ be the result of computing lanesâˆ’1
iğ‘Š xğ‘ (ğ‘›0 . . . ğ‘›ğ‘ âˆ’1 ).
15. Push the value v128.const ğ‘ to the stack.

4.6. Instructions

151

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

ğ‘†; ğ¹ ; (at.const ğ‘–) (v128.loadğ‘€ xğ‘ _sx ğ‘¥ memarg) Ë“â†’ ğ‘†; ğ¹ ; (v128.const ğ‘)
(if ea = ğ‘– + memarg.offset
âˆ§ ea + ğ‘€ Â· ğ‘/8 â‰¤ |ğ‘†.mems[ğ¹.module.memaddrs[ğ‘¥]].data|
âˆ§ bytesiğ‘€ (ğ‘šğ‘˜ ) = ğ‘†.mems[ğ¹.module.memaddrs[ğ‘¥]].data[ea + ğ‘˜ Â· ğ‘€/8 : ğ‘€/8])
âˆ§ğ‘Š =ğ‘€ Â·2
sx
sx
âˆ§ ğ‘ = lanesâˆ’1
iğ‘Š xğ‘ (extendğ‘€,ğ‘Š (ğ‘š0 ) . . . extendğ‘€,ğ‘Š (ğ‘šğ‘ âˆ’1 )))
ğ‘†; ğ¹ ; (at.const ğ‘–) (v128.loadğ‘€ xğ‘ _sx ğ‘¥ memarg) Ë“â†’ ğ‘†; ğ¹ ; trap
(otherwise)
v128.loadğ‘ _splat ğ‘¥ memarg
1. Let ğ¹ be the current frame.
2. Assert: due to validation, ğ¹.module.memaddrs[ğ‘¥] exists.
3. Let ğ‘ be the memory address ğ¹.module.memaddrs[ğ‘¥].
4. Assert: due to validation, ğ‘†.mems[ğ‘] exists.
5. Let mem be the memory instance ğ‘†.mems[ğ‘].
6. Assert: due to validation, a value of some address type at is on the top of the stack.
7. Pop the value at.const ğ‘– from the stack.
8. Let ea be the integer ğ‘– + memarg.offset.
9. If ea + ğ‘/8 is larger than the length of mem.data, then:
a. Trap.
10. Let ğ‘* be the byte sequence mem.data[ea : ğ‘/8].
11. Let ğ‘› be the integer for which bytesiğ‘ (ğ‘›) = ğ‘* .
12. Let ğ¿ be the integer 128/ğ‘ .
ğ¿
13. Let ğ‘ be the result of computing lanesâˆ’1
iğ‘ xğ¿ (ğ‘› ).

14. Push the value v128.const ğ‘ to the stack.
ğ‘†; ğ¹ ; (at.const ğ‘–) (v128.loadğ‘ _splat ğ‘¥ memarg) Ë“â†’ ğ‘†; ğ¹ ; (v128.const ğ‘)
(if ea = ğ‘– + memarg.offset
âˆ§ ea + ğ‘/8 â‰¤ |ğ‘†.mems[ğ¹.module.memaddrs[ğ‘¥]].data|
âˆ§ bytesiğ‘ (ğ‘›) = ğ‘†.mems[ğ¹.module.memaddrs[ğ‘¥]].data[ea : ğ‘/8]
ğ¿
âˆ§ ğ‘ = lanesâˆ’1
iğ‘ xğ¿ (ğ‘› ))
ğ‘†; ğ¹ ; (at.const ğ‘–) (v128.loadğ‘ _splat ğ‘¥ memarg) Ë“â†’ ğ‘†; ğ¹ ; trap
(otherwise)
v128.loadğ‘ _zero ğ‘¥ memarg
1. Let ğ¹ be the current frame.
2. Assert: due to validation, ğ¹.module.memaddrs[ğ‘¥] exists.
3. Let ğ‘ be the memory address ğ¹.module.memaddrs[ğ‘¥].
4. Assert: due to validation, ğ‘†.mems[ğ‘] exists.
5. Let mem be the memory instance ğ‘†.mems[ğ‘].
6. Assert: due to validation, a value of some address type at is on the top of the stack.
7. Pop the value at.const ğ‘– from the stack.
8. Let ea be the integer ğ‘– + memarg.offset.
9. If ea + ğ‘/8 is larger than the length of mem.data, then:

152

Chapter 4. Execution

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

a. Trap.
10. Let ğ‘* be the byte sequence mem.data[ea : ğ‘/8].
11. Let ğ‘› be the integer for which bytesiğ‘ (ğ‘›) = ğ‘* .
12. Let ğ‘ be the result of computing extendu ğ‘,128 (ğ‘›).
13. Push the value v128.const ğ‘ to the stack.
ğ‘†; ğ¹ ; (at.const ğ‘–) (v128.loadğ‘ _zero ğ‘¥ memarg) Ë“â†’ ğ‘†; ğ¹ ; (v128.const ğ‘)
(if ea = ğ‘– + memarg.offset
âˆ§ ea + ğ‘/8 â‰¤ |ğ‘†.mems[ğ¹.module.memaddrs[ğ‘¥]].data|
âˆ§ bytesiğ‘ (ğ‘›) = ğ‘†.mems[ğ¹.module.memaddrs[ğ‘¥]].data[ea : ğ‘/8])
âˆ§ ğ‘ = extendu ğ‘,128 (ğ‘›)
ğ‘†; ğ¹ ; (at.const ğ‘–) (v128.loadğ‘ _zero ğ‘¥ memarg) Ë“â†’ ğ‘†; ğ¹ ; trap
(otherwise)
v128.loadğ‘ _lane ğ‘¥ memarg ğ‘¦
1. Let ğ¹ be the current frame.
2. Assert: due to validation, ğ¹.module.memaddrs[ğ‘¥] exists.
3. Let ğ‘ be the memory address ğ¹.module.memaddrs[ğ‘¥].
4. Assert: due to validation, ğ‘†.mems[ğ‘] exists.
5. Let mem be the memory instance ğ‘†.mems[ğ‘].
6. Assert: due to validation, a value of value type v128 is on the top of the stack.
7. Pop the value v128.const ğ‘£ from the stack.
8. Assert: due to validation, a value of some address type at is on the top of the stack.
9. Pop the value at.const ğ‘– from the stack.
10. Let ea be the integer ğ‘– + memarg.offset.
11. If ea + ğ‘/8 is larger than the length of mem.data, then:
a. Trap.
12. Let ğ‘* be the byte sequence mem.data[ea : ğ‘/8].
13. Let ğ‘Ÿ be the constant for which bytesiğ‘ (ğ‘Ÿ) = ğ‘* .
14. Let ğ¿ be 128/ğ‘ .
15. Let ğ‘— * be the result of computing lanesiğ‘ xğ¿ (ğ‘£).
*
16. Let ğ‘ be the result of computing lanesâˆ’1
iğ‘ xğ¿ (ğ‘— with [ğ‘¦] = ğ‘Ÿ).

17. Push the value v128.const ğ‘ to the stack.
ğ‘†; ğ¹ ; (at.const ğ‘–) (v128.const ğ‘£) (v128.loadğ‘ _lane ğ‘¥ memarg ğ‘¦) Ë“â†’ ğ‘†; ğ¹ ; (v128.const ğ‘)
(if ea = ğ‘– + memarg.offset
âˆ§ ea + ğ‘/8 â‰¤ |ğ‘†.mems[ğ¹.module.memaddrs[ğ‘¥]].data|
âˆ§ bytesiğ‘ (ğ‘Ÿ) = ğ‘†.mems[ğ¹.module.memaddrs[ğ‘¥]].data[ea : ğ‘/8])
âˆ§ ğ¿ = 128/ğ‘
âˆ§ ğ‘ = lanesâˆ’1
iğ‘ xğ¿ (lanesiğ‘ xğ¿ (ğ‘£) with [ğ‘¦] = ğ‘Ÿ))
ğ‘†; ğ¹ ; (at.const ğ‘–) (v128.const ğ‘£) (v128.loadğ‘ _lane ğ‘¥ memarg ğ‘¦) Ë“â†’ ğ‘†; ğ¹ ; trap
(otherwise)

4.6. Instructions

153

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

ğ‘¡.store ğ‘¥ memarg and ğ‘¡.storeğ‘ ğ‘¥ memarg
1. Let ğ¹ be the current frame.
2. Assert: due to validation, ğ¹.module.memaddrs[ğ‘¥] exists.
3. Let ğ‘ be the memory address ğ¹.module.memaddrs[ğ‘¥].
4. Assert: due to validation, ğ‘†.mems[ğ‘] exists.
5. Let mem be the memory instance ğ‘†.mems[ğ‘].
6. Assert: due to validation, a value of value type ğ‘¡ is on the top of the stack.
7. Pop the value ğ‘¡.const ğ‘ from the stack.
8. Assert: due to validation, a value of some address type at is on the top of the stack.
9. Pop the value at.const ğ‘– from the stack.
10. Let ea be the integer ğ‘– + memarg.offset.
11. If ğ‘ is not part of the instruction, then:
a. Let ğ‘ be the bit width |ğ‘¡| of number type ğ‘¡.
12. If ea + ğ‘/8 is larger than the length of mem.data, then:
a. Trap.
13. If ğ‘ is part of the instruction, then:
a. Let ğ‘› be the result of computing wrap|ğ‘¡|,ğ‘ (ğ‘).
b. Let ğ‘* be the byte sequence bytesiğ‘ (ğ‘›).
14. Else:
a. Let ğ‘* be the byte sequence bytesğ‘¡ (ğ‘).
15. Replace the bytes mem.data[ea : ğ‘/8] with ğ‘* .
ğ‘†; ğ¹ ; (at.const ğ‘–) (ğ‘¡.const ğ‘) (ğ‘¡.store ğ‘¥ memarg) Ë“â†’ ğ‘† â€² ; ğ¹ ; ğœ–
(if ea = ğ‘– + memarg.offset
âˆ§ ea + |ğ‘¡|/8 â‰¤ |ğ‘†.mems[ğ¹.module.memaddrs[ğ‘¥]].data|
âˆ§ ğ‘† â€² = ğ‘† with mems[ğ¹.module.memaddrs[ğ‘¥]].data[ea : |ğ‘¡|/8] = bytesğ‘¡ (ğ‘))
ğ‘†; ğ¹ ; (at.const ğ‘–) (ğ‘¡.const ğ‘) (ğ‘¡.storeğ‘ ğ‘¥ memarg) Ë“â†’ ğ‘† â€² ; ğ¹ ; ğœ–
(if ea = ğ‘– + memarg.offset
âˆ§ ea + ğ‘/8 â‰¤ |ğ‘†.mems[ğ¹.module.memaddrs[ğ‘¥]].data|
âˆ§ ğ‘† â€² = ğ‘† with mems[ğ¹.module.memaddrs[ğ‘¥]].data[ea : ğ‘/8] = bytesiğ‘ (wrap|ğ‘¡|,ğ‘ (ğ‘))
ğ‘†; ğ¹ ; (at.const ğ‘–) (ğ‘¡.const ğ‘) (ğ‘¡.storeğ‘ ? ğ‘¥ memarg) Ë“â†’ ğ‘†; ğ¹ ; trap
(otherwise)
v128.storeğ‘ _lane ğ‘¥ memarg ğ‘¦
1. Let ğ¹ be the current frame.
2. Assert: due to validation, ğ¹.module.memaddrs[ğ‘¥] exists.
3. Let ğ‘ be the memory address ğ¹.module.memaddrs[ğ‘¥].
4. Assert: due to validation, ğ‘†.mems[ğ‘] exists.
5. Let mem be the memory instance ğ‘†.mems[ğ‘].
6. Assert: due to validation, a value of value type v128 is on the top of the stack.
7. Pop the value v128.const ğ‘ from the stack.
8. Assert: due to validation, a value of some address type at is on the top of the stack.

154

Chapter 4. Execution

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

9. Pop the value at.const ğ‘– from the stack.
10. Let ea be the integer ğ‘– + memarg.offset.
11. If ea + ğ‘/8 is larger than the length of mem.data, then:
a. Trap.
12. Let ğ¿ be 128/ğ‘ .
13. Let ğ‘— * be the result of computing lanesiğ‘ xğ¿ (ğ‘).
14. Let ğ‘* be the result of computing bytesiğ‘ (ğ‘— * [ğ‘¦]).
15. Replace the bytes mem.data[ea : ğ‘/8] with ğ‘* .
ğ‘†; ğ¹ ; (at.const ğ‘–) (v128.const ğ‘) (v128.storeğ‘ _lane ğ‘¥ memarg ğ‘¦) Ë“â†’ ğ‘† â€² ; ğ¹ ; ğœ–
(if ea = ğ‘– + memarg.offset
âˆ§ ea + ğ‘ â‰¤ |ğ‘†.mems[ğ¹.module.memaddrs[ğ‘¥]].data|
âˆ§ ğ¿ = 128/ğ‘
âˆ§ ğ‘† â€² = ğ‘† with mems[ğ¹.module.memaddrs[ğ‘¥]].data[ea : ğ‘/8] = bytesiğ‘ (lanesiğ‘ xğ¿ (ğ‘)[ğ‘¦]))
ğ‘†; ğ¹ ; (at.const ğ‘–) (v128.const ğ‘) (v128.storeğ‘ _lane ğ‘¥ memarg ğ‘¦) Ë“â†’ ğ‘†; ğ¹ ; trap
(otherwise)
memory.size ğ‘¥
1. Let ğ¹ be the current frame.
2. Assert: due to validation, ğ¹.module.memaddrs[ğ‘¥] exists.
3. Let ğ‘ be the memory address ğ¹.module.memaddrs[ğ‘¥].
4. Assert: due to validation, ğ‘†.mems[ğ‘] exists.
5. Let mem be the memory instance ğ‘†.mems[ğ‘].
6. Let at limits be the memory type mem.type.
7. Let sz be the length of mem.data divided by the page size.
8. Push the value at.const sz to the stack.
ğ‘†; ğ¹ ; (memory.size ğ‘¥) Ë“â†’ ğ‘†; ğ¹ ; (at.const sz )
(if |ğ‘†.mems[ğ¹.module.memaddrs[ğ‘¥]].data| = sz Â· 64 Ki
âˆ§ğ‘†.mems[ğ¹.module.memaddrs[ğ‘¥]].type = at lim)

memory.grow ğ‘¥
1. Let ğ¹ be the current frame.
2. Assert: due to validation, ğ¹.module.memaddrs[ğ‘¥] exists.
3. Let ğ‘ be the memory address ğ¹.module.memaddrs[ğ‘¥].
4. Assert: due to validation, ğ‘†.mems[ğ‘] exists.
5. Let mem be the memory instance ğ‘†.mems[ğ‘].
6. Let sz be the length of ğ‘†.mems[ğ‘] divided by the page size.
7. Assert: due to validation, a value of some address type at is on the top of the stack.
8. Pop the value at.const ğ‘› from the stack.
9. Let err be the at value 2|at| âˆ’ 1, for which signed|at| (err ) is âˆ’1.
10. Either:
a. If growing mem by ğ‘› pages succeeds, then:
i. Push the value at.const sz to the stack.
4.6. Instructions

155

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

b. Else:
i. Push the value at.const err to the stack.
11. Or:
a. Push the value at.const err to the stack.
ğ‘†; ğ¹ ; (at.const ğ‘›) (memory.grow ğ‘¥) Ë“â†’ ğ‘† â€² ; ğ¹ ; (at.const sz )
(if ğ¹.module.memaddrs[ğ‘¥] = ğ‘
âˆ§ sz = |ğ‘†.mems[ğ‘].data|/64 Ki
âˆ§ ğ‘† â€² = ğ‘† with mems[ğ‘] = growmem(ğ‘†.mems[ğ‘], ğ‘›))
ğ‘†; ğ¹ ; (at.const ğ‘›) (memory.grow ğ‘¥) Ë“â†’

ğ‘†; ğ¹ ; (at.const signedâˆ’1
|at| (âˆ’1))

Ã² Note
The memory.grow instruction is non-deterministic. It may either succeed, returning the old memory size sz ,
or fail, returning âˆ’1. Failure must occur if the referenced memory instance has a maximum size defined that
would be exceeded. However, failure can occur in other cases as well. In practice, the choice depends on the
resources available to the embedder.
memory.fill ğ‘¥
1. Let ğ¹ be the current frame.
2. Assert: due to validation, ğ¹.module.memaddrs[ğ‘¥] exists.
3. Let ma be the memory address ğ¹.module.memaddrs[ğ‘¥].
4. Assert: due to validation, ğ‘†.mems[ma] exists.
5. Let mem be the memory instance ğ‘†.mems[ma].
6. Assert: due to validation, a value of some address type at is on the top of the stack.
7. Pop the value at.const ğ‘› from the stack.
8. Assert: due to validation, a value is on the top of the stack.
9. Pop the value val from the stack.
10. Assert: due to validation, a value of address type at is on the top of the stack.
11. Pop the value at.const ğ‘‘ from the stack.
12. If ğ‘‘ + ğ‘› is larger than the length of mem.data, then:
a. Trap.
13. If ğ‘› = 0, then:
a. Return.
14. Push the value i32.const ğ‘‘ to the stack.
15. Push the value val to the stack.
16. Execute the instruction at.store8 {offset 0, align 0}.
17. Assert: due to the earlier check against the memory size, ğ‘‘ + 1 < 232 .
18. Push the value at.const (ğ‘‘ + 1) to the stack.
19. Push the value val to the stack.
20. Push the value at.const (ğ‘› âˆ’ 1) to the stack.
21. Execute the instruction memory.fill ğ‘¥.

156

Chapter 4. Execution

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

ğ‘†; ğ¹ ; (at.const ğ‘‘) val (at.const ğ‘›) memory.fill ğ‘¥ Ë“â†’ ğ‘†; ğ¹ ; trap
(if ğ‘‘ + ğ‘› > |ğ‘†.mems[ğ¹.module.memaddrs[ğ‘¥]].data|)
ğ‘†; ğ¹ ; (at.const ğ‘‘) val (at.const 0) memory.fill ğ‘¥
(otherwise)

Ë“â†’

ğ‘†; ğ¹ ; ğœ–

ğ‘†; ğ¹ ; (at.const ğ‘‘) val (at.const ğ‘› + 1) memory.fill ğ‘¥ Ë“â†’
ğ‘†; ğ¹ ; (at.const ğ‘‘) val (at.store8 ğ‘¥ {offset 0, align 0})
(at.const ğ‘‘ + 1) val (at.const ğ‘›) memory.fill ğ‘¥
(otherwise)
memory.copy ğ‘¥ ğ‘¦
1. Let ğ¹ be the current frame.
2. Assert: due to validation, ğ¹.module.memaddrs[ğ‘¥] exists.
3. Assert: due to validation, ğ¹.module.memaddrs[ğ‘¦] exists.
4. Let da be the memory address ğ¹.module.memaddrs[ğ‘¥].
5. Let sa be the memory address ğ¹.module.memaddrs[ğ‘¦].
6. Assert: due to validation, ğ‘†.mems[da] exists.
7. Assert: due to validation, ğ‘†.mems[sa] exists.
8. Let mem ğ‘‘ be the memory instance ğ‘†.mems[da].
9. Let mem ğ‘  be the memory instance ğ‘†.mems[sa].
10. Assert: due to validation, a value of some address type at ğ‘› is on the top of the stack.
11. Pop the value at ğ‘› .const ğ‘› from the stack.
12. Assert: due to validation, a value of some address type at ğ‘  is on the top of the stack.
13. Pop the value at ğ‘  .const ğ‘  from the stack.
14. Assert: due to validation, a value of some address type at ğ‘‘ is on the top of the stack.
15. Pop the value at ğ‘‘ .const ğ‘‘ from the stack.
16. If ğ‘  + ğ‘› is larger than the length of mem ğ‘  .data or ğ‘‘ + ğ‘› is larger than the length of mem ğ‘‘ .data, then:
a. Trap.
17. If ğ‘› = 0, then:
a. Return.
18. If ğ‘‘ â‰¤ ğ‘ , then:
a. Push the value at ğ‘‘ .const ğ‘‘ to the stack.
b. Push the value at ğ‘  .const ğ‘  to the stack.
c. Execute the instruction i32.load8_u ğ‘¦ {offset 0, align 0}.
d. Execute the instruction i32.store8 ğ‘¥ {offset 0, align 0}.
e. Assert: due to the earlier check against the memory size, ğ‘‘ + 1 < 232 .
f. Push the value at ğ‘‘ .const (ğ‘‘ + 1) to the stack.
g. Assert: due to the earlier check against the memory size, ğ‘  + 1 < 232 .
h. Push the value at ğ‘  .const (ğ‘  + 1) to the stack.
19. Else:
a. Assert: due to the earlier check against the memory size, ğ‘‘ + ğ‘› âˆ’ 1 < 232 .
b. Push the value at ğ‘‘ .const (ğ‘‘ + ğ‘› âˆ’ 1) to the stack.
4.6. Instructions

157

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

c. Assert: due to the earlier check against the memory size, ğ‘  + ğ‘› âˆ’ 1 < 232 .
d. Push the value at ğ‘  .const (ğ‘  + ğ‘› âˆ’ 1) to the stack.
e. Execute the instruction i32.load8_u ğ‘¦ {offset 0, align 0}.
f. Execute the instruction i32.store8 ğ‘¥ {offset 0, align 0}.
g. Push the value at ğ‘‘ .const ğ‘‘ to the stack.
h. Push the value at ğ‘  .const ğ‘  to the stack.
20. Push the value at ğ‘› .const (ğ‘› âˆ’ 1) to the stack.
21. Execute the instruction memory.copy ğ‘¥ ğ‘¦.
ğ‘†; ğ¹ ; (at ğ‘¥ .const ğ‘‘) (at ğ‘¦ .const ğ‘ ) (at ğ‘› .const ğ‘›) memory.copy ğ‘¥ ğ‘¦
(if (ğ‘‘ + ğ‘› > |ğ‘†.mems[ğ¹.module.memaddrs[ğ‘¥]].data|
âˆ¨ ğ‘  + ğ‘› > |ğ‘†.mems[ğ¹.module.memaddrs[ğ‘¦]].data|))
ğ‘†; ğ¹ ; (at ğ‘¥ .const ğ‘‘) (at ğ‘¦ .const ğ‘ ) (at ğ‘› .const 0) memory.copy ğ‘¥ ğ‘¦
(otherwise)

Ë“â†’

ğ‘†; ğ¹ ; trap

Ë“â†’

ğ‘†; ğ¹ ; ğœ–

ğ‘†; ğ¹ ; (at ğ‘¥ .const ğ‘‘) (at ğ‘¦ .const ğ‘ ) (at ğ‘› .const ğ‘› + 1) memory.copy ğ‘¥ ğ‘¦ Ë“â†’
ğ‘†; ğ¹ ; (at ğ‘¥ .const ğ‘‘)
(at ğ‘¦ .const ğ‘ ) (i32.load8_u ğ‘¦ {offset 0, align 0})
(i32.store8 ğ‘¥ {offset 0, align 0})
(at ğ‘¥ .const ğ‘‘ + 1) (at ğ‘¦ .const ğ‘  + 1) (at ğ‘› .const ğ‘›) memory.copy ğ‘¥ ğ‘¦
(otherwise, if ğ‘‘ â‰¤ ğ‘ )
ğ‘†; ğ¹ ; (at ğ‘¥ .const ğ‘‘) (at ğ‘¦ .const ğ‘ ) (at ğ‘› .const ğ‘› + 1) memory.copy ğ‘¥ ğ‘¦
ğ‘†; ğ¹ ; (at ğ‘¥ .const ğ‘‘ + ğ‘›)
(at ğ‘¦ .const ğ‘  + ğ‘›) (i32.load8_u ğ‘¦ {offset 0, align 0})
(i32.store8 ğ‘¥ {offset 0, align 0})
(at ğ‘¥ .const ğ‘‘) (at ğ‘¦ .const ğ‘ ) (at ğ‘› .const ğ‘›) memory.copy ğ‘¥ ğ‘¦
(otherwise, if ğ‘‘ > ğ‘ )

Ë“â†’

memory.init ğ‘¥ ğ‘¦
1. Let ğ¹ be the current frame.
2. Assert: due to validation, ğ¹.module.memaddrs[ğ‘¥] exists.
3. Let ma be the memory address ğ¹.module.memaddrs[ğ‘¥].
4. Assert: due to validation, ğ‘†.mems[ma] exists.
5. Let mem be the memory instance ğ‘†.mems[ma].
6. Assert: due to validation, ğ¹.module.dataaddrs[ğ‘¦] exists.
7. Let da be the data address ğ¹.module.dataaddrs[ğ‘¦].
8. Assert: due to validation, ğ‘†.datas[da] exists.
9. Let data be the data instance ğ‘†.datas[da].
10. Assert: due to validation, a value of value type i32 is on the top of the stack.
11. Pop the value i32.const ğ‘› from the stack.
12. Assert: due to validation, a value of value type i32 is on the top of the stack.
13. Pop the value i32.const ğ‘  from the stack.
14. Assert: due to validation, a value of some address type at is on the top of the stack.
15. Pop the value at.const ğ‘‘ from the stack.
16. If ğ‘  + ğ‘› is larger than the length of data.data or ğ‘‘ + ğ‘› is larger than the length of mem.data, then:
a. Trap.
158

Chapter 4. Execution

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

17. If ğ‘› = 0, then:
a. Return.
18. Let ğ‘ be the byte data.data[ğ‘ ].
19. Push the value at.const ğ‘‘ to the stack.
20. Push the value i32.const ğ‘ to the stack.
21. Execute the instruction i32.store8 ğ‘¥ {offset 0, align 0}.
22. Assert: due to the earlier check against the memory size, ğ‘‘ + 1 < 232 .
23. Push the value at.const (ğ‘‘ + 1) to the stack.
24. Assert: due to the earlier check against the memory size, ğ‘  + 1 < 232 .
25. Push the value i32.const (ğ‘  + 1) to the stack.
26. Push the value i32.const (ğ‘› âˆ’ 1) to the stack.
27. Execute the instruction memory.init ğ‘¥ ğ‘¦.
ğ‘†; ğ¹ ; (at.const ğ‘‘) (i32.const ğ‘ ) (i32.const ğ‘›) (memory.init ğ‘¥ ğ‘¦)
(if ğ‘‘ + ğ‘› > |ğ‘†.mems[ğ¹.module.memaddrs[ğ‘¥]].data|
âˆ¨ ğ‘  + ğ‘› > |ğ‘†.datas[ğ¹.module.dataaddrs[ğ‘¦]].data|)

Ë“â†’

ğ‘†; ğ¹ ; trap

ğ‘†; ğ¹ ; (at.const ğ‘‘) (i32.const ğ‘ ) (i32.const 0) (memory.init ğ‘¥ ğ‘¦)
(otherwise)

Ë“â†’

ğ‘†; ğ¹ ; ğœ–

ğ‘†; ğ¹ ; (at.const ğ‘‘) (i32.const ğ‘ ) (i32.const ğ‘› + 1) (memory.init ğ‘¥ ğ‘¦) Ë“â†’
ğ‘†; ğ¹ ; (at.const ğ‘‘) (i32.const ğ‘) (i32.store8 ğ‘¥ {offset 0, align 0})
(at.const ğ‘‘ + 1) (i32.const ğ‘  + 1) (i32.const ğ‘›) (memory.init ğ‘¥ ğ‘¦)
(otherwise, if ğ‘ = ğ‘†.datas[ğ¹.module.dataaddrs[ğ‘¦]].data[ğ‘ ])
data.drop ğ‘¥
1. Let ğ¹ be the current frame.
2. Assert: due to validation, ğ¹.module.dataaddrs[ğ‘¥] exists.
3. Let ğ‘ be the data address ğ¹.module.dataaddrs[ğ‘¥].
4. Assert: due to validation, ğ‘†.datas[ğ‘] exists.
5. Replace ğ‘†.datas[ğ‘] with the data instance {data ğœ–}.
ğ‘†; ğ¹ ; (data.drop ğ‘¥) Ë“â†’ ğ‘† â€² ; ğ¹ ; ğœ–
(if ğ‘† â€² = ğ‘† with datas[ğ¹.module.dataaddrs[ğ‘¥]] = {data ğœ–})

4.6.8 Control Instructions
nop
1. Do nothing.
nop Ë“â†’ ğœ–
unreachable
1. Trap.
unreachable Ë“â†’ trap

4.6. Instructions

159

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

block blocktype instr * end
1. Let ğ¹ be the current frame.
2. Assert: due to validation, instrtypeğ‘†;ğ¹ (blocktype) is defined.
ğ‘›
3. Let [ğ‘¡ğ‘š
1 ] â†’ [ğ‘¡2 ] be the instruction type instrtypeğ‘†;ğ¹ (blocktype).

4. Let ğ¿ be the label whose arity is ğ‘› and whose continuation is the end of the block.
5. Assert: due to validation, there are at least ğ‘š values on the top of the stack.
6. Pop the values val ğ‘š from the stack.
7. Enter the block instr * with label ğ¿ and values val ğ‘š .
ğ‘†; ğ¹ ; val ğ‘š block bt instr * end Ë“â†’

ğ‘†; ğ¹ ; labelğ‘› {ğœ–} val ğ‘š instr * end
ğ‘›
(if instrtypeğ‘†;ğ¹ (bt) = [ğ‘¡ğ‘š
1 ] â†’ [ğ‘¡2 ])

loop blocktype instr * end
1. Let ğ¹ be the current frame.
2. Assert: due to validation, instrtypeğ‘†;ğ¹ (blocktype) is defined.
ğ‘›
3. Let [ğ‘¡ğ‘š
1 ] â†’ [ğ‘¡2 ] be the instruction type instrtypeğ‘†;ğ¹ (blocktype).

4. Let ğ¿ be the label whose arity is ğ‘š and whose continuation is the start of the loop.
5. Assert: due to validation, there are at least ğ‘š values on the top of the stack.
6. Pop the values val ğ‘š from the stack.
7. Enter the block instr * with label ğ¿ and values val ğ‘š .
ğ‘†; ğ¹ ; val ğ‘š loop bt instr * end Ë“â†’

ğ‘†; ğ¹ ; labelğ‘š {loop bt instr * end} val ğ‘š instr * end
ğ‘›
(if instrtypeğ‘†;ğ¹ (bt) = [ğ‘¡ğ‘š
1 ] â†’ [ğ‘¡2 ])

if blocktype instr *1 else instr *2 end
1. Assert: due to validation, a value of value type i32 is on the top of the stack.
2. Pop the value i32.const ğ‘ from the stack.
3. If ğ‘ is non-zero, then:
a. Execute the block instruction block blocktype instr *1 end.
4. Else:
a. Execute the block instruction block blocktype instr *2 end.
(i32.const ğ‘) if bt instr *1 else instr *2 end Ë“â†’ block bt instr *1 end
(if ğ‘ Ì¸= 0)
(i32.const ğ‘) if bt instr *1 else instr *2 end Ë“â†’ block bt instr *2 end
(if ğ‘ = 0)
throw ğ‘¥
1. Let ğ¹ be the current frame.
2. Assert: due to validation, ğ¹.module.tagaddrs[ğ‘¥] exists.
3. Let ta be the tag address ğ¹.module.tagaddrs[ğ‘¥].
4. Assert: due to validation, ğ‘†.tags[ta] exists.
5. Let ti be the tag instance ğ‘†.tags[ta].

160

Chapter 4. Execution

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

*

6. Let [ğ‘¡ğ‘› ] â†’ [ğ‘¡â€² ] be the tag type ti .type.
7. Assert: due to validation, there are at least ğ‘› values on the top of the stack.
8. Pop the ğ‘› values val ğ‘› from the stack.
9. Let exn be the exception instance {tag ta, fields val ğ‘› }.
10. Let ea be the length of ğ‘†.exns.
11. Append exn to ğ‘†.exns.
12. Push the value ref.exn ea to the stack.
13. Execute the instruction throw_ref.
ğ‘†; ğ¹ ; val ğ‘› (throw ğ‘¥) Ë“â†’ ğ‘† â€² ; ğ¹ ; (ref.exn |ğ‘†.exns|) throw_ref

(if ğ¹.module.tagaddrs[ğ‘¥] = ğ‘
âˆ§ ğ‘†.tags[ğ‘].type = [ğ‘¡ğ‘› ] â†’ []
âˆ§ exn = {tag ğ‘, fields val ğ‘› }
âˆ§ ğ‘† â€² = ğ‘† with exns = ğ‘†.exns exn)

throw_ref
1. Assert: due to validation, a reference is on the top of the stack.
2. Pop the reference ref from the stack.
3. If ref is ref.null ht, then:
a. Trap.
4. Assert: due to validation, ref is an exception reference.
5. Let ref.exn ea be ref .
6. Assert: due to validation, ğ‘†.exns[ea] exists.
7. Let exn be the exception instance ğ‘†.exns[ea].
8. Let ğ‘ be the tag address exn.tag.
9. While the stack is not empty and the top of the stack is not an exception handler, do:
a. Pop the top element from the stack.
10. Assert: the stack is now either empty, or there is an exception handler on the top of the stack.
11. If the stack is empty, then:
a. Return the exception (ref.exn ğ‘) as a result.
12. Assert: there is an exception handler on the top of the stack.
13. Pop the exception handler handlerğ‘› {catch * } from the stack.
14. If catch * is empty, then:
a. Push the exception reference ref.exn ea back to the stack.
b. Execute the instruction throw_ref again.
15. Else:
a. Let ğ¹ be the current frame.
*

b. Let catch 1 be the first catch clause in catch * and catch â€² the remaining clauses.
c. If catch 1 is of the form catch ğ‘¥ ğ‘™ and the tag address ğ‘ equals ğ¹.module.tagaddrs[ğ‘¥], then:
i. Push the values exn.fields to the stack.
ii. Execute the instruction br ğ‘™.
d. Else if catch 1 is of the form catch_ref ğ‘¥ ğ‘™ and the tag address ğ‘ equals ğ¹.module.tagaddrs[ğ‘¥], then:
4.6. Instructions

161

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

i. Push the values exn.fields to the stack.
ii. Push the exception reference ref.exn ea to the stack.
iii. Execute the instruction br ğ‘™.
e. Else if catch 1 is of the form catch_all ğ‘™, then:
i. Execute the instruction br ğ‘™.
f. Else if catch 1 is of the form catch_all_ref ğ‘™, then:
i. Push the exception reference ref.exn ea to the stack.
ii. Execute the instruction br ğ‘™.
g. Else:
*

1. Push the modified handler handlerğ‘› {catch â€² } back to the stack.
2. Push the exception reference ref.exn ea back to the stack.
3. Execute the instruction throw_ref again.
(ref.null ht) throw_ref Ë“â†’
handlerğ‘› {} ğ‘‡ [(ref.exn ğ‘) throw_ref] end Ë“â†’
ğ‘†; ğ¹ ; handlerğ‘› {(catch ğ‘¥ ğ‘™) catch * } ğ‘‡ [(ref.exn ğ‘) throw_ref] end Ë“â†’
ğ‘†; ğ¹ ; handlerğ‘› {(catch_ref ğ‘¥ ğ‘™) catch * } ğ‘‡ [(ref.exn ğ‘) throw_ref] end Ë“â†’
handlerğ‘› {(catch_all ğ‘™) catch * } ğ‘‡ [(ref.exn ğ‘) throw_ref] end Ë“â†’
handlerğ‘› {(catch_all_ref ğ‘™) catch * } ğ‘‡ [(ref.exn ğ‘) throw_ref] end Ë“â†’
handlerğ‘› {catch 1 catch * } ğ‘‡ [(ref.exn ğ‘) throw_ref] end Ë“â†’

trap
(ref.exn ğ‘) throw_ref
exn.fields (br ğ‘™)
(if exn = ğ‘†.exns[ğ‘]
âˆ§ exn.tag = ğ¹.module.tagaddrs[ğ‘¥])
exn.fields (ref.exn ğ‘) (br ğ‘™)
(if exn = ğ‘†.exns[ğ‘]
âˆ§ exn.tag = ğ¹.module.tagaddrs[ğ‘¥])
(br ğ‘™)
(ref.exn ğ‘) (br ğ‘™)
handlerğ‘› {catch * } ğ‘‡ [(ref.exn ğ‘) throw_ref] end
(otherwise)

try_table blocktype catch * instr * end
1. Assert: due to validation, instrtypeğ‘†;ğ¹ (blocktype) is defined.
ğ‘›
2. Let [ğ‘¡ğ‘š
1 ] â†’ [ğ‘¡2 ] be the instruction type instrtypeğ‘†;ğ¹ (blocktype).

3. Assert: due to validation, there are at least ğ‘š values on the top of the stack.
4. Pop the values val ğ‘š from the stack.
5. Let ğ¿ be the label whose arity is ğ‘› and whose continuation is the end of the try_table instruction.
6. Enter the block val ğ‘š instr *1 with label ğ¿ and exception handler handlerğ‘› {catch * }.
ğ¹ ; val ğ‘š (try_table bt catch * instr * end Ë“â†’ ğ¹ ; handlerğ‘› {catch * } (labelğ‘› {ğœ–} val ğ‘š instr * end) end
ğ‘›
*
(if instrtypeğ‘†;ğ¹ (bt) = [ğ‘¡ğ‘š
1 ] â†’ [ğ‘¡2 ] âˆ§ (ğ¹.module.tagaddrs[ğ‘¥] = ğ‘ğ‘¥ ) )
br ğ‘™
1. Assert: due to validation, the stack contains at least ğ‘™ + 1 labels.
2. Let ğ¿ be the ğ‘™-th label appearing on the stack, starting from the top and counting from zero.
3. Let ğ‘› be the arity of ğ¿.
4. Assert: due to validation, there are at least ğ‘› values on the top of the stack.
5. Pop the values val ğ‘› from the stack.
6. Repeat ğ‘™ + 1 times:
a. While the top of the stack is a value or a handler, do:
162

Chapter 4. Execution

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

i. Pop the value or handler from the stack.
b. Assert: due to validation, the top of the stack now is a label.
c. Pop the label from the stack.
7. Push the values val ğ‘› to the stack.
8. Jump to the continuation of ğ¿.
labelğ‘› {instr * } ğµ ğ‘™ [val ğ‘› (br ğ‘™)] end

Ë“â†’ val ğ‘› instr *

br_if ğ‘™
1. Assert: due to validation, a value of value type i32 is on the top of the stack.
2. Pop the value i32.const ğ‘ from the stack.
3. If ğ‘ is non-zero, then:
a. Execute the instruction br ğ‘™.
4. Else:
a. Do nothing.
(i32.const ğ‘) (br_if ğ‘™) Ë“â†’ (br ğ‘™)
(i32.const ğ‘) (br_if ğ‘™) Ë“â†’ ğœ–

(if ğ‘ Ì¸= 0)
(if ğ‘ = 0)

br_table ğ‘™* ğ‘™ğ‘
1. Assert: due to validation, a value of value type i32 is on the top of the stack.
2. Pop the value i32.const ğ‘– from the stack.
3. If ğ‘– is smaller than the length of ğ‘™* , then:
a. Let ğ‘™ğ‘– be the label ğ‘™* [ğ‘–].
b. Execute the instruction br ğ‘™ğ‘– .
4. Else:
a. Execute the instruction br ğ‘™ğ‘ .
(i32.const ğ‘–) (br_table ğ‘™* ğ‘™ğ‘ ) Ë“â†’ (br ğ‘™ğ‘– )
(i32.const ğ‘–) (br_table ğ‘™* ğ‘™ğ‘ ) Ë“â†’ (br ğ‘™ğ‘ )

(if ğ‘™* [ğ‘–] = ğ‘™ğ‘– )
(if |ğ‘™* | â‰¤ ğ‘–)

br_on_null ğ‘™
1. Assert: due to validation, a reference value is on the top of the stack.
2. Pop the value ref from the stack.
3. If ref is ref.null ht, then:
a. Execute the instruction (br ğ‘™).
4. Else:
a. Push the value ref back to the stack.
ref (br_on_null ğ‘™) Ë“â†’ (br ğ‘™)
ref (br_on_null ğ‘™) Ë“â†’ ref

4.6. Instructions

(if ref = ref.null ht)
(otherwise)

163

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

br_on_non_null ğ‘™
1. Assert: due to validation, a reference value is on the top of the stack.
2. Pop the value ref from the stack.
3. If ref is ref.null ht, then:
a. Do nothing.
4. Else:
a. Push the value ref back to the stack.
b. Execute the instruction (br ğ‘™).
ref (br_on_non_null ğ‘™) Ë“â†’
ref (br_on_non_null ğ‘™) Ë“â†’

ğœ–
ref (br ğ‘™)

(if ref = ref.null ht)
(otherwise)

br_on_cast ğ‘™ rt 1 rt 2
1. Let ğ¹ be the current frame.
2. Let rt â€²2 be the reference type closğ¹.module (rt 2 ).
3. Assert: due to validation, rt â€²2 is closed.
4. Assert: due to validation, a reference value is on the top of the stack.
5. Pop the value ref from the stack.
6. Assert: due to validation, the reference value is valid with some reference type.
7. Let rt be the reference type of ref .
8. Push the value ref back to the stack.
9. If the reference type rt matches rt â€²2 , then:
a. Execute the instruction (br ğ‘™).
ğ‘†; ğ¹ ; ref (br_on_cast ğ‘™ rt 1 rt 2 ) Ë“â†’
ğ‘†; ğ¹ ; ref (br_on_cast ğ‘™ rt 1 rt 2 ) Ë“â†’

ref (br ğ‘™)
ref

(if ğ‘† âŠ¢ ref : rt âˆ§ âŠ¢ rt â‰¤ closğ¹.module (rt 2 ))
(otherwise)

br_on_cast_fail ğ‘™ rt 1 rt 2
1. Let ğ¹ be the current frame.
2. Let rt â€²2 be the reference type closğ¹.module (rt 2 ).
3. Assert: due to validation, rt â€²2 is closed.
4. Assert: due to validation, a reference value is on the top of the stack.
5. Pop the value ref from the stack.
6. Assert: due to validation, the reference value is valid with some reference type.
7. Let rt be the reference type of ref .
8. Push the value ref back to the stack.
9. If the reference type rt does not match rt â€²2 , then:
a. Execute the instruction (br ğ‘™).
ğ‘†; ğ¹ ; ref (br_on_cast_fail ğ‘™ rt 1 rt 2 ) Ë“â†’ ref
ğ‘†; ğ¹ ; ref (br_on_cast_fail ğ‘™ rt 1 rt 2 ) Ë“â†’ ref (br ğ‘™)

164

(if ğ‘† âŠ¢ ref : rt âˆ§ âŠ¢ rt â‰¤ closğ¹.module (rt 2 ))
(otherwise)

Chapter 4. Execution

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

return
1. Let ğ¹ be the current frame.
2. Let ğ‘› be the arity of ğ¹ .
3. Assert: due to validation, there are at least ğ‘› values on the top of the stack.
4. Pop the results val ğ‘› from the stack.
5. Assert: due to validation, the stack contains at least one frame.
6. While the top of the stack is not a frame, do:
a. Pop the top element from the stack.
7. Assert: the top of the stack is the frame ğ¹ .
8. Pop the frame from the stack.
9. Push val ğ‘› to the stack.
10. Jump to the instruction after the original call that pushed the frame.
frameğ‘› {ğ¹ } ğµ * [val ğ‘› return] end Ë“â†’ val ğ‘›
call ğ‘¥
1. Let ğ¹ be the current frame.
2. Assert: due to validation, ğ¹.module.funcaddrs[ğ‘¥] exists.
3. Let ğ‘ be the function address ğ¹.module.funcaddrs[ğ‘¥].
4. Invoke the function instance at address ğ‘.
ğ¹ ; (call ğ‘¥) Ë“â†’ ğ¹ ; (invoke ğ‘)

(if ğ¹.module.funcaddrs[ğ‘¥] = ğ‘)

call_ref ğ‘¥
1. Assert: due to validation, a null or function reference is on the top of the stack.
2. Pop the reference value ğ‘Ÿ from the stack.
3. If ğ‘Ÿ is ref.null ht, then:
a. Trap.
4. Assert: due to validation, ğ‘Ÿ is a function reference.
5. Let ref.func ğ‘ be the reference ğ‘Ÿ.
6. Invoke the function instance at address ğ‘.
ğ¹ ; (ref.func ğ‘) (call_ref ğ‘¥) Ë“â†’ ğ¹ ; (invoke ğ‘)
ğ¹ ; (ref.null ht) (call_ref ğ‘¥) Ë“â†’ ğ¹ ; trap
call_indirect ğ‘¥ ğ‘¦
1. Let ğ¹ be the current frame.
2. Assert: due to validation, ğ¹.module.tableaddrs[ğ‘¥] exists.
3. Let ta be the table address ğ¹.module.tableaddrs[ğ‘¥].
4. Assert: due to validation, ğ‘†.tables[ta] exists.
5. Let tab be the table instance ğ‘†.tables[ta].
6. Assert: due to validation, ğ¹.module.types[ğ‘¦] is defined.
7. Let dt expect be the defined type ğ¹.module.types[ğ‘¦].

4.6. Instructions

165

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

8. Assert: due to validation, a value with value type i32 is on the top of the stack.
9. Pop the value i32.const ğ‘– from the stack.
10. If ğ‘– is not smaller than the length of tab.elem, then:
a. Trap.
11. Let ğ‘Ÿ be the reference tab.elem[ğ‘–].
12. If ğ‘Ÿ is ref.null ht, then:
a. Trap.
13. Assert: due to validation of table mutation, ğ‘Ÿ is a function reference.
14. Let ref.func ğ‘ be the function reference ğ‘Ÿ.
15. Assert: due to validation of table mutation, ğ‘†.funcs[ğ‘] exists.
16. Let f be the function instance ğ‘†.funcs[ğ‘].
17. Let dt actual be the defined type f .type.
18. If dt actual does not match dt expect , then:
a. Trap.
19. Invoke the function instance at address ğ‘.
ğ‘†; ğ¹ ; (i32.const ğ‘–) (call_indirect ğ‘¥ ğ‘¦) Ë“â†’ ğ‘†; ğ¹ ; (invoke ğ‘)
(if ğ‘†.tables[ğ¹.module.tableaddrs[ğ‘¥]].elem[ğ‘–] = ref.func ğ‘
âˆ§ ğ‘†.funcs[ğ‘] = ğ‘“
âˆ§ ğ‘† âŠ¢ ğ‘“.type â‰¤ ğ¹.module.types[ğ‘¦])
ğ‘†; ğ¹ ; (i32.const ğ‘–) (call_indirect ğ‘¥ ğ‘¦) Ë“â†’ ğ‘†; ğ¹ ; trap
(otherwise)
return_call ğ‘¥
1. Let ğ¹ be the current frame.
2. Assert: due to validation, ğ¹.module.funcaddrs[ğ‘¥] exists.
3. Let ğ‘ be the function address ğ¹.module.funcaddrs[ğ‘¥].
4. Tail-invoke the function instance at address ğ‘.
(return_call ğ‘¥) Ë“â†’

(return_invoke ğ‘)

(if (call ğ‘¥) Ë“â†’ (invoke ğ‘))

return_call_ref ğ‘¥
1. Assert: due to validation, a function reference is on the top of the stack.
2. Pop the reference value ğ‘Ÿ from the stack.
3. If ğ‘Ÿ is ref.null ht, then:
a. Trap.
4. Assert: due to validation, ğ‘Ÿ is a function reference.
5. Let ref.func ğ‘ be the reference ğ‘Ÿ.
6. Tail-invoke the function instance at address ğ‘.
val (return_call_ref ğ‘¥) Ë“â†’
val (return_call_ref ğ‘¥) Ë“â†’

166

(return_invoke ğ‘)
trap

(if val (call_ref ğ‘¥) Ë“â†’ (invoke ğ‘))
(if val (call_ref ğ‘¥) Ë“â†’ trap)

Chapter 4. Execution

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

return_call_indirect ğ‘¥ ğ‘¦
1. Let ğ¹ be the current frame.
2. Assert: due to validation, ğ¹.module.tableaddrs[ğ‘¥] exists.
3. Let ta be the table address ğ¹.module.tableaddrs[ğ‘¥].
4. Assert: due to validation, ğ‘†.tables[ta] exists.
5. Let tab be the table instance ğ‘†.tables[ta].
6. Assert: due to validation, ğ¹.module.types[ğ‘¦] exists.
7. Let dt expect be the defined type ğ¹.module.types[ğ‘¦].
8. Assert: due to validation, a value with value type i32 is on the top of the stack.
9. Pop the value i32.const ğ‘– from the stack.
10. If ğ‘– is not smaller than the length of tab.elem, then:
a. Trap.
11. If tab.elem[ğ‘–] is uninitialized, then:
a. Trap.
12. Let ğ‘ be the function address tab.elem[ğ‘–].
13. Assert: due to validation, ğ‘†.funcs[ğ‘] exists.
14. Let f be the function instance ğ‘†.funcs[ğ‘].
15. Let dt actual be the defined type f .type.
16. If dt actual does not match dt expect , then:
a. Trap.
17. Tail-invoke the function instance at address ğ‘.
val (return_call_indirect ğ‘¥ ğ‘¦) Ë“â†’
val (return_call_indirect ğ‘¥ ğ‘¦) Ë“â†’

(return_invoke ğ‘)
trap

(if val (call_indirect ğ‘¥ ğ‘¦) Ë“â†’ (invoke ğ‘))
(if val (call_indirect ğ‘¥ ğ‘¦) Ë“â†’ trap)

4.6.9 Blocks
The following auxiliary rules define the semantics of executing an instruction sequence that forms a block.
Entering instr * with label ğ¿ and values val *
1. Push ğ¿ to the stack.
2. Push the values val * to the stack.
3. Jump to the start of the instruction sequence instr * .
Ã² Note
No formal reduction rule is needed for entering an instruction sequence, because the label ğ¿ is embedded in
the administrative instruction that structured control instructions reduce to directly.
Exiting instr * with label ğ¿
When the end of a block is reached without a jump, exception, or trap aborting it, then the following steps are
performed.
1. Pop all values val * from the top of the stack.

4.6. Instructions

167

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

2. Assert: due to validation, the label ğ¿ is now on the top of the stack.
3. Pop the label from the stack.
4. Push val * back to the stack.
5. Jump to the position after the end of the structured control instruction associated with the label ğ¿.
labelğ‘› {instr * } val * end Ë“â†’ val *

Ã² Note
This semantics also applies to the instruction sequence contained in a loop instruction. Therefore, execution of
a loop falls off the end, unless a backwards branch is performed explicitly.

4.6.10 Exception Handling
The following auxiliary rules define the semantics of entering and exiting try_table blocks.
Entering instr * with label ğ¿ and exception handler ğ»
1. Push ğ» to the stack.
2. Push ğ¿ onto the stack.
3. Jump to the start of the instruction sequence instr * .
Ã² Note
No formal reduction rule is needed for entering an exception handler because it is an administrative instruction
that the try_table instruction reduces to directly.
Exiting an exception handler
When the end of a try_table block is reached without a jump, exception, or trap, then the following steps are
performed.
1. Let ğ‘š be the number of values on the top of the stack.
2. Pop the values val ğ‘š from the stack.
3. Assert: due to validation, a handler and a label are now on the top of the stack.
4. Pop the label from the stack.
5. Pop the handler ğ» from the stack.
6. Push val ğ‘š back to the stack.
7. Jump to the position after the end of the administrative instruction associated with the handler ğ».
handlerğ‘š {catch * } val ğ‘š end Ë“â†’

val ğ‘š

4.6.11 Function Calls
The following auxiliary rules define the semantics of invoking a function instance through one of the call instructions and returning from it.

168

Chapter 4. Execution

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

Invocation of function address ğ‘
1. Assert: due to validation, ğ‘†.funcs[ğ‘] exists.
2. Let ğ‘“ be the function instance, ğ‘†.funcs[ğ‘].
3. Let func [ğ‘¡ğ‘›1 ] â†’ [ğ‘¡ğ‘š
2 ] be the composite type expand(f .type).
4. Let local * be the list of locals ğ‘“.code.locals.
5. Let instr * end be the expression ğ‘“.code.body.
6. Assert: due to validation, ğ‘› values are on the top of the stack.
7. Pop the values val ğ‘› from the stack.
8. Let ğ¹ be the frame {module ğ‘“.module, locals val ğ‘› (defaultğ‘¡ )* }.
9. Push the activation of ğ¹ with arity ğ‘š to the stack.
10. Let ğ¿ be the label whose arity is ğ‘š and whose continuation is the end of the function.
11. Enter the instruction sequence instr * with label ğ¿ and no values.
ğ‘†; val ğ‘› (invoke ğ‘) Ë“â†’ ğ‘†; frameğ‘š {ğ¹ } labelğ‘š {} instr * end end
(if ğ‘†.funcs[ğ‘] = ğ‘“
âˆ§ expand(ğ‘“.type) = func [ğ‘¡ğ‘›1 ] â†’ [ğ‘¡ğ‘š
2 ]
âˆ§ ğ‘“.code = {type ğ‘¥, locals {type ğ‘¡}ğ‘˜ , body instr * end}
âˆ§ ğ¹ = {module ğ‘“.module, locals val ğ‘› (defaultğ‘¡ )ğ‘˜ })

Ã² Note
For non-defaultable types, the respective local is left uninitialized by these rules.
Tail-invocation of function address ğ‘
1. Assert: due to validation, ğ‘†.funcs[ğ‘] exists.
2. Let func [ğ‘¡ğ‘›1 ] â†’ [ğ‘¡ğ‘š
2 ] be the composite type expand(ğ‘†.funcs[ğ‘].type).
3. Assert: due to validation, there are at least ğ‘› values on the top of the stack.
4. Pop the results val ğ‘› from the stack.
5. Assert: due to validation, the stack contains at least one frame.
6. While the top of the stack is not a frame, do:
a. Pop the top element from the stack.
7. Assert: the top of the stack is a frame.
8. Pop the frame from the stack.
9. Push val ğ‘› to the stack.
10. Invoke the function instance at address ğ‘.
ğ‘†; frameğ‘š {ğ¹ } ğµ * [val ğ‘› (return_invoke ğ‘)] end Ë“â†’

val ğ‘› (invoke ğ‘)

(if expand(ğ‘†.funcs[ğ‘].type) = func [ğ‘¡ğ‘›1 ] â†’ [ğ‘¡ğ‘š
2 ])

Returning from a function
When the end of a function is reached without a jump (including through return), or an exception or trap aborting
it, then the following steps are performed.
1. Let ğ¹ be the current frame.
2. Let ğ‘› be the arity of the activation of ğ¹ .
4.6. Instructions

169

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

3. Assert: due to validation, there are ğ‘› values on the top of the stack.
4. Pop the results val ğ‘› from the stack.
5. Assert: due to validation, the frame ğ¹ is now on the top of the stack.
6. Pop the frame from the stack.
7. Push val ğ‘› back to the stack.
8. Jump to the instruction after the original call.
frameğ‘› {ğ¹ } val ğ‘› end Ë“â†’ val ğ‘›

Host Functions
Invoking a host function has non-deterministic behavior. It may either terminate with a trap, an exception, or return
regularly. However, in the latter case, it must consume and produce the right number and types of WebAssembly
values on the stack, according to its function type.
A host function may also modify the store. However, all store modifications must result in an extension of the
original store, i.e., they must only modify mutable contents and must not have instances removed. Furthermore,
the resulting store must be valid, i.e., all data and code in it is well-typed.
ğ‘†; val ğ‘› (invoke ğ‘) Ë“â†’ ğ‘† â€² ; result
(if ğ‘†.funcs[ğ‘] = {type deftype, hostcode hf }
âˆ§ expand(deftype) = func [ğ‘¡ğ‘›1 ] â†’ [ğ‘¡ğ‘š
2 ]
âˆ§ (ğ‘† â€² ; result) âˆˆ hf (ğ‘†; val ğ‘› ))
ğ‘†; val ğ‘› (invoke ğ‘) Ë“â†’ ğ‘†; val ğ‘› (invoke ğ‘)
(if ğ‘†.funcs[ğ‘] = {type deftype, hostcode hf }
âˆ§ expand(deftype) = func [ğ‘¡ğ‘›1 ] â†’ [ğ‘¡ğ‘š
2 ]
âˆ§ âŠ¥ âˆˆ hf (ğ‘†; val ğ‘› ))
Here, hf (ğ‘†; val ğ‘› ) denotes the implementation-defined execution of host function hf in current store ğ‘† with arguments val ğ‘› . It yields a set of possible outcomes, where each element is either a pair of a modified store ğ‘† â€² and
a result or the special value âŠ¥ indicating divergence. A host function is non-deterministic if there is at least one
argument for which the set of outcomes is not singular.
For a WebAssembly implementation to be sound in the presence of host functions, every host function instance
must be valid, which means that it adheres to suitable pre- and post-conditions: under a valid store ğ‘†, and given
arguments val ğ‘› matching the ascribed parameter types ğ‘¡ğ‘›1 , executing the host function must yield a non-empty set
of possible outcomes each of which is either divergence or consists of a valid store ğ‘† â€² that is an extension of ğ‘† and
a result matching the ascribed return types ğ‘¡ğ‘š
2 . All these notions are made precise in the Appendix.
Ã² Note
A host function can call back into WebAssembly by invoking a function exported from a module. However,
the effects of any such call are subsumed by the non-deterministic behavior allowed for the host function.

4.6.12 Expressions
An expression is evaluated relative to a current frame pointing to its containing module instance.
1. Jump to the start of the instruction sequence instr * of the expression.
2. Execute the instruction sequence.
3. Assert: due to validation, the top of the stack contains a value.
4. Pop the value val from the stack.

170

Chapter 4. Execution

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

The value val is the result of the evaluation.
ğ‘†; ğ¹ ; instr * Ë“â†’ ğ‘† â€² ; ğ¹ â€² ; instr â€²*

(if ğ‘†; ğ¹ ; instr * end Ë“â†’ ğ‘† â€² ; ğ¹ â€² ; instr â€²* end)

Ã² Note
Evaluation iterates this reduction rule until reaching a value. Expressions constituting function bodies are
executed during function invocation.

4.7 Modules
For modules, the execution semantics primarily defines instantiation, which allocates instances for a module and
its contained definitions, initializes tables and memories from contained element and data segments, and invokes
the start function if present. It also includes invocation of exported functions.

4.7.1 Allocation
New instances of functions, tables, memories, globals, tags, element segments, and data segments, as well as
dynamic data types like structures, arrays, or exceptions, are allocated in a store ğ‘†, as defined by the following
auxiliary functions.
Functions
1. Let func be the function to allocate and moduleinst its module instance.
2. Let deftype be the defined type moduleinst.types[func.type].
3. Let ğ‘ be the first free function address in ğ‘†.
4. Let funcinst be the function instance {type deftype, module moduleinst, code func}.
6. Append funcinst to the funcs of ğ‘†.
7. Return ğ‘.
allocfunc(ğ‘†, func, moduleinst)
where:
deftype
funcaddr
funcinst
ğ‘†â€²

= ğ‘† â€² , funcaddr
=
=
=
=

moduleinst.types[func.type]
|ğ‘†.funcs|
{type deftype, module moduleinst, code func}
ğ‘† âŠ• {funcs funcinst}

Host Functions
1. Let hostfunc be the host function to allocate and deftype its defined type.
2. Let ğ‘ be the first free function address in ğ‘†.
3. Let funcinst be the function instance {type deftype, hostcode hostfunc}.
4. Append funcinst to the funcs of ğ‘†.
5. Return ğ‘.
allochostfunc(ğ‘†, deftype, hostfunc)
where:
funcaddr
funcinst
ğ‘†â€²
4.7. Modules

= ğ‘† â€² , funcaddr
= |ğ‘†.funcs|
= {type deftype, hostcode hostfunc}
= ğ‘† âŠ• {funcs funcinst}
171

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

Ã² Note
Host functions are never allocated by the WebAssembly semantics itself, but may be allocated by the embedder.

Tables
1. Let tabletype be the table type of the table to allocate and ref the initialization value.
2. Let (addrtype {min ğ‘›, max ğ‘š? } reftype) be the structure of table type tabletype.
3. Let ğ‘ be the first free table address in ğ‘†.
4. Let tableinst be the table instance {type tabletype, elem ref ğ‘› } with ğ‘› elements set to ref .
5. Append tableinst to the tables of ğ‘†.
6. Return ğ‘.
alloctable(ğ‘†, tabletype, ref )
where:
tabletype
tableaddr
tableinst
ğ‘†â€²

= ğ‘† â€² , tableaddr
=
=
=
=

addrtype {min ğ‘›, max ğ‘š? } reftype
|ğ‘†.tables|
{type tabletype, elem ref ğ‘› }
ğ‘† âŠ• {tables tableinst}

Memories
1. Let memtype be the memory type of the memory to allocate.
2. Let (addrtype {min ğ‘›, max ğ‘š? }) be the structure of memory type memtype.
3. Let ğ‘ be the first free memory address in ğ‘†.
4. Let meminst be the memory instance {type memtype, data (0x00)ğ‘›Â·64 Ki } that contains ğ‘› pages of zeroed
bytes.
5. Append meminst to the mems of ğ‘†.
6. Return ğ‘.
allocmem(ğ‘†, memtype)
where:
memtype
memaddr
meminst
ğ‘†â€²

= ğ‘† â€² , memaddr
=
=
=
=

addrtype {min ğ‘›, max ğ‘š? }
|ğ‘†.mems|
{type memtype, data (0x00)ğ‘›Â·64 Ki }
ğ‘† âŠ• {mems meminst}

Tags
1. Let tagtype be the tag type to allocate.
2. Let ğ‘ be the first free tag address in ğ‘†.
3. Let taginst be the tag instance {type tagtype}.
4. Append taginst to the tags of ğ‘†.
5. Return ğ‘.

172

alloctag(ğ‘†, tagtype)

=

ğ‘† â€² , tagaddr

where:
tagaddr
taginst
ğ‘†â€²

=
=
=

|ğ‘†.tags|
{type tagtype}
ğ‘† âŠ• {tags taginst}

Chapter 4. Execution

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

Globals
1. Let globaltype be the global type of the global to allocate and val its initialization value.
2. Let ğ‘ be the first free global address in ğ‘†.
3. Let globalinst be the global instance {type globaltype, value val }.
4. Append globalinst to the globals of ğ‘†.
5. Return ğ‘.
allocglobal(ğ‘†, globaltype, val )
where:
globaladdr
globalinst
ğ‘†â€²

= ğ‘† â€² , globaladdr
= |ğ‘†.globals|
= {type globaltype, value val }
= ğ‘† âŠ• {globals globalinst}

Element segments
1. Let reftype be the elementsâ€™ type and ref * the vector of references to allocate.
2. Let ğ‘ be the first free element address in ğ‘†.
3. Let eleminst be the element instance {type reftype, elem ref * }.
4. Append eleminst to the elems of ğ‘†.
5. Return ğ‘.
allocelem(ğ‘†, reftype, ref * )
where:
elemaddr
eleminst
ğ‘†â€²

= ğ‘† â€² , elemaddr
= |ğ‘†.elems|
= {type reftype, elem ref * }
= ğ‘† âŠ• {elems eleminst}

Data segments
1. Let ğ‘* be the vector of bytes to allocate.
2. Let ğ‘ be the first free data address in ğ‘†.
3. Let datainst be the data instance {data ğ‘* }.
4. Append datainst to the datas of ğ‘†.
5. Return ğ‘.
allocdata(ğ‘†, ğ‘* )
where:
dataaddr
datainst
ğ‘†â€²

= ğ‘† â€² , dataaddr
= |ğ‘†.datas|
= {data ğ‘* }
= ğ‘† âŠ• {datas datainst}

Growing tables
1. Let tableinst be the table instance to grow, ğ‘› the number of elements by which to grow it, and ref the
initialization value.
2. Let len be ğ‘› added to the length of tableinst.elem.
3. Let (addrtype limits reftype) be the structure of table type tableinst.type.
4. Let limits â€² be limits with min updated to len.
5. If the table type (addrtype limits â€² reftype) is not valid, then fail.
4.7. Modules

173

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

6. Append ref ğ‘› to tableinst.elem.
7. Set tableinst.type to the table type (addrtype limits â€² reftype).
growtable(tableinst, ğ‘›, ref )

=

tableinst with type = addrtype limits â€² reftype with elem = tableinst.elem ref ğ‘›
(if len = ğ‘› + |tableinst.elem|
âˆ§ addrtype limits reftype = tableinst.type
âˆ§ limits â€² = limits with min = len
âˆ§ âŠ¢ addrtype limits â€² reftype ok)

Growing memories
1. Let meminst be the memory instance to grow and ğ‘› the number of pages by which to grow it.
2. Assert: The length of meminst.data is divisible by the page size 64 Ki.
3. Let len be ğ‘› added to the length of meminst.data divided by the page size 64 Ki.
4. Let (addrtype limits) be the structure of memory type meminst.type.
5. Let limits â€² be limits with min updated to len.
6. If the memory type (addrtype limits â€² ) is not valid, then fail.
7. Append ğ‘› times 64 Ki bytes with value 0x00 to meminst.data.
8. Set meminst.type to the memory type (addrtype limits â€² ).
growmem(meminst, ğ‘›)

= meminst with type = addrtype limits â€² with data = meminst.data (0x00)ğ‘›Â·64 Ki
(if len = ğ‘› + |meminst.data|/64 Ki
âˆ§ addrtype limits = meminst.type
âˆ§ limits â€² = limits with min = len
âˆ§ âŠ¢ addrtype limits â€² ok)

Modules
v Todo
update prose for types
The allocation function for modules requires a suitable list of external values that are assumed to match the import
vector of the module, a list of initialization values for the moduleâ€™s globals, and list of reference vectors for the
moduleâ€™s element segments.
1. Let module be the module to allocate and externval *im the vector of external values providing the moduleâ€™s
imports, val *g the initialization values of the moduleâ€™s globals, ref *t the initializer reference of the moduleâ€™s
tables, and (ref *e )* the reference vectors of the moduleâ€™s element segments.
2. For each defined type deftype â€²ğ‘– in module.types, do:
a. Let deftype ğ‘– be the instantiation deftype â€²ğ‘– in moduleinst defined below.
3. For each function func ğ‘– in module.funcs, do:
a. Let funcaddr ğ‘– be the function address resulting from allocating func ğ‘– for the module instance
moduleinst defined below.
4. For each table table ğ‘– in module.tables, do:
a. Let limits ğ‘– ğ‘¡ğ‘– be the table type obtained by instantiating table ğ‘– .type in moduleinst defined below.
b. Let tableaddr ğ‘– be the table address resulting from allocating table ğ‘– .type with initialization value
ref *t [ğ‘–].
5. For each memory mem ğ‘– in module.mems, do:
174

Chapter 4. Execution

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

a. Let memtype ğ‘– be the memory type obtained by insantiating mem ğ‘– .type in moduleinst defined below.
b. Let memaddr ğ‘– be the memory address resulting from allocating memtype ğ‘– .
6. For each global global ğ‘– in module.globals, do:
a. Let globaltype ğ‘– be the global type obtained by instantiating global ğ‘– .type in moduleinst defined below.
b. Let globaladdr ğ‘– be the global address resulting from allocating globaltype ğ‘– with initializer value val *g [ğ‘–].
7. For each tag tag ğ‘– in module.tags, do:
a. Let tagtype be the tag type module.types[tag ğ‘– .type].
b. Let tagaddr ğ‘– be the tag address resulting from allocating tagtype.
8. For each element segment elem ğ‘– in module.elems, do:
a. Let reftype ğ‘– be the element reference type obtained by instantiating elem ğ‘– .type in moduleinst defined
below.
b. Let elemaddr ğ‘– be the element address resulting from allocating a element instance of reference type
reftype ğ‘– with contents (ref *e )* [ğ‘–].
9. For each data segment data ğ‘– in module.datas, do:
a. Let dataaddr ğ‘– be the data address resulting from allocating a data instance with contents data ğ‘– .init.
10. Let deftype * be the concatenation of the defined types deftype ğ‘– in index order.
11. Let funcaddr * be the concatenation of the function addresses funcaddr ğ‘– in index order.
12. Let tableaddr * be the concatenation of the table addresses tableaddr ğ‘– in index order.
13. Let memaddr * be the concatenation of the memory addresses memaddr ğ‘– in index order.
14. Let globaladdr * be the concatenation of the global addresses globaladdr ğ‘– in index order.
15. Let tagaddr * be the concatenation of the tag addresses tagaddr ğ‘– in index order.
16. Let elemaddr * be the concatenation of the element addresses elemaddr ğ‘– in index order.
17. Let dataaddr * be the concatenation of the data addresses dataaddr ğ‘– in index order.
18. Let funcaddr *mod be the list of function addresses extracted from externval *im , concatenated with funcaddr * .
19. Let tableaddr *mod be the list of table addresses extracted from externval *im , concatenated with tableaddr * .
20. Let memaddr *mod be the list of memory addresses extracted from externval *im , concatenated with
memaddr * .
21. Let globaladdr *mod be the list of global addresses extracted from externval *im , concatenated with
globaladdr * .
22. Let tagaddr *mod be the list of tag addresses extracted from externval *im , concatenated with tagaddr * .
23. For each export export ğ‘– in module.exports, do:
a. If export ğ‘– is a function export for function index ğ‘¥, then let externval ğ‘– be the external value
func (funcaddr *mod [ğ‘¥]).
b. Else, if export ğ‘– is a table export for table index ğ‘¥, then let externval ğ‘– be the external value
table (tableaddr *mod [ğ‘¥]).
c. Else, if export ğ‘– is a memory export for memory index ğ‘¥, then let externval ğ‘– be the external value
mem (memaddr *mod [ğ‘¥]).
d. Else, if export ğ‘– is a global export for global index ğ‘¥, then let externval ğ‘– be the external value
global (globaladdr *mod [ğ‘¥]).
e. Else, if export ğ‘– is a tag export for tag index ğ‘¥, then let externval ğ‘– be the external value
tag (tagaddr *mod [ğ‘¥]).
f. Let exportinst ğ‘– be the export instance {name (export ğ‘– .name), value externval ğ‘– }.

4.7. Modules

175

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

24. Let exportinst * be the concatenation of the export instances exportinst ğ‘– in index order.
25. Let moduleinst be the module instance {types deftype * , funcaddrs funcaddr *mod , tableaddrs tableaddr *mod ,
memaddrs memaddr *mod , globaladdrs globaladdr *mod , tagaddrs tagaddr *mod , elemaddrs elemaddr * ,
dataaddrs dataaddr * , exports exportinst * }.
26. Return moduleinst.
allocmodule(ğ‘†, module, externval *im , val *g , ref *t , (ref *e )* )

=

ğ‘† â€² , moduleinst

where:
table *
mem *
global *
elem *
data *
export *
moduleinst

deftype *
ğ‘†1 , funcaddr *
ğ‘†2 , tableaddr *
ğ‘†3 , memaddr *
ğ‘†4 , globaladdr *
ğ‘†5 , tagaddr *
ğ‘†6 , elemaddr *
ğ‘† â€² , dataaddr *
exportinst *
funcs(externval *ex )
tables(externval *ex )
mems(externval *ex )
globals(externval *ex )
tags(externval *ex )

=
=
=
=
=
=

module.tables
module.mems
module.globals
module.elems
module.datas
module.exports

= { types deftype * ,
funcaddrs funcs(externval *im ) funcaddr * ,
tableaddrs tables(externval *im ) tableaddr * ,
memaddrs mems(externval *im ) memaddr * ,
globaladdrs globals(externval *im ) globaladdr * ,
tagaddrs tags(externval *im ) tagaddr * ,
elemaddrs elemaddr * ,
dataaddrs dataaddr * ,
exports exportinst * }
= alloctype* (module.types)
= allocfunc* (ğ‘†, module.funcs, moduleinst)
= alloctable* (ğ‘†1 , closmoduleinst (table.type)* , ref *t ) (where (table.type)* = (limits ğ‘¡)* )
= allocmem* (ğ‘†2 , closmoduleinst (mem.type)* )
= allocglobal* (ğ‘†3 , closmoduleinst (global .type)* , val *g )
= alloctag* (ğ‘†4 , closmoduleinst (tag)* ) (where tag * = module.tags)
= allocelem* (ğ‘†5 , closmoduleinst (elem.type)* , (ref *e )* )
= allocdata* (ğ‘†6 , data.init* )
= {name (export.name), value externval ex }*
=
=
=
=
=

(moduleinst.funcaddrs[ğ‘¥])*
(where ğ‘¥* = funcs(export * ))
*
(moduleinst.tableaddrs[ğ‘¥])
(where ğ‘¥* = tables(export * ))
*
(moduleinst.memaddrs[ğ‘¥])
(where ğ‘¥* = mems(export * ))
*
(moduleinst.globaladdrs[ğ‘¥])
(where ğ‘¥* = globals(export * ))
*
(moduleinst.tagaddrs[ğ‘¥])
(where ğ‘¥* = tags(export * ))

Here, the notation allocx* is shorthand for multiple allocations of object kind ğ‘‹, defined as follows:
allocx* (ğ‘†0 , ğ‘‹ ğ‘› , . . . )

=

ğ‘†ğ‘› , ğ‘ğ‘›

where for all ğ‘– < ğ‘›:
ğ‘†ğ‘–+1 , ğ‘ğ‘› [ğ‘–]

=

allocx(ğ‘†ğ‘– , ğ‘‹ ğ‘› [ğ‘–], . . . )

Moreover, if the dots . . . are a sequence ğ´ğ‘› (as for globals or tables), then the elements of this sequence are passed
to the allocation function pointwise.
For types, however, allocation is defined in terms of rolling and substitution of all preceding types to produce a list
of closed defined types:
alloctype* (rectype ğ‘› ) = deftype *
where for all ğ‘– < ğ‘›:
ğ‘–
rectype ğ‘› [ğ‘–] = rec subtype ğ‘š
ğ‘–
*
*
*
ğ‘–
deftype [ğ‘¥ğ‘– : ğ‘šğ‘– ] = roll ğ‘¥ğ‘– (rec subtype ğ‘š
ğ‘– )[:= deftype [0 : ğ‘¥ğ‘– ]]
ğ‘¥ğ‘–+1 = ğ‘¥ğ‘– + ğ‘šğ‘–
ğ‘¥ğ‘› = |deftype * |
176

Chapter 4. Execution

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

Ã² Note
The definition of module allocation is mutually recursive with the allocation of its associated functions, because
the resulting module instance moduleinst is passed to the allocators as an argument, in order to form the
necessary closures. In an implementation, this recursion is easily unraveled by mutating one or the other in a
secondary step.

4.7.2 Instantiation
Given a store ğ‘†, a module module is instantiated with a list of external values externval ğ‘› supplying the required
imports as follows.
Instantiation checks that the module is valid and the provided imports match the declared types, and may fail with
an error otherwise. Instantiation can also result in an exception or trap when initializing a table or memory from
an active segment or when executing the start function. It is up to the embedder to define how such conditions are
reported.
1. If module is not valid, then:
a. Fail.
2. Assert: module is valid with external types externtype ğ‘š
im classifying its imports.
3. If the number ğ‘š of imports is not equal to the number ğ‘› of provided external values, then:
a. Fail.
4. For each external value externval ğ‘– in externval ğ‘› and external type externtype â€²ğ‘– in externtype ğ‘›im , do:
a. If externval ğ‘– is not valid with an external type externtype ğ‘– in store ğ‘†, then:
i. Fail.
b. Let externtype â€²â€²ğ‘– be the external type obtained by instantiating externtype â€²ğ‘– in moduleinst defined
below.
c. If externtype ğ‘– does not match externtype â€²â€²ğ‘– , then:
i. Fail.
6. Let ğ¹ be the auxiliary frame {module moduleinst, locals ğœ–}, that consists of the final module instance
moduleinst, defined below.
7. Push the frame ğ¹ to the stack.
8. Let val *g be the vector of global initialization values determined by module and externval ğ‘› . These may be
calculated as follows.
a. For each global global ğ‘– in module.globals, do:
i. Let val gğ‘– be the result of evaluating the initializer expression global ğ‘– .init.
b. Assert: due to validation, the frame ğ¹ is now on the top of the stack.
c. Let val *g be the concatenation of val gğ‘– in index order.
9. Let ref *t be the vector of table initialization references determined by module and externval ğ‘› . These may
be calculated as follows.
a. For each table table ğ‘– in module.tables, do:
i. Let val tğ‘– be the result of evaluating the initializer expression table ğ‘– .init.
ii. Assert: due to validation, val tğ‘– is a reference.
iii. Let ref tğ‘– be the reference val tğ‘– .
b. Assert: due to validation, the frame ğ¹ is now on the top of the stack.
c. Let ref *t be the concatenation of ref ğ‘¡ğ‘– in index order.
4.7. Modules

177

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

10. Let (ref *e )* be the list of reference vectors determined by the element segments in module. These may be
calculated as follows.
a. For each element segment elem ğ‘– in module.elems, and for each element expression expr ğ‘–ğ‘— in
elem ğ‘– .init, do:
i. Let ref ğ‘–ğ‘— be the result of evaluating the initializer expression expr ğ‘–ğ‘— .
b. Let ref *ğ‘– be the concatenation of function elements ref ğ‘–ğ‘— in order of index ğ‘—.
c. Let (ref *e )* be the concatenation of function element vectors ref *ğ‘– in order of index ğ‘–.
11. Let moduleinst be a new module instance allocated from module in store ğ‘† with imports externval ğ‘› , global
initializer values val *g , table initializer values ref *t , and element segment contents (ref *e )* , and let ğ‘† â€² be the
extended store produced by module allocation.
12. For each element segment elem ğ‘– in
active {table tableidx ğ‘– , offset einstr *ğ‘– end}, do:

module.elems

whose

mode

is

of

the

form

the

form

a. Let ğ‘› be the length of the vector elem ğ‘– .init.
b. Execute the instruction sequence einstr *ğ‘– .
c. Execute the instruction i32.const 0.
d. Execute the instruction i32.const ğ‘›.
e. Execute the instruction table.init tableidx ğ‘– ğ‘–.
f. Execute the instruction elem.drop ğ‘–.
13. For each element segment elem ğ‘– in module.elems whose mode is of the form declarative, do:
a. Execute the instruction elem.drop ğ‘–.
14. For each data segment data ğ‘– in module.datas
active {memory memidx ğ‘– , offset dinstr *ğ‘– end}, do:

whose

mode

is

of

a. Let ğ‘› be the length of the vector data ğ‘– .init.
b. Execute the instruction sequence dinstr *ğ‘– .
c. Execute the instruction i32.const 0.
d. Execute the instruction i32.const ğ‘›.
e. Execute the instruction memory.init ğ‘–.
f. Execute the instruction data.drop ğ‘–.
15. If the start function module.start is not empty, then:
a. Let start be the start function module.start.
b. Execute the instruction call start.func.
16. Assert: due to validation, the frame ğ¹ is now on the top of the stack.
17. Pop the frame ğ¹ from the stack.

178

Chapter 4. Execution

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

instantiate(ğ‘†, module, externval ğ‘˜ )

(if
âˆ§
âˆ§

ğ‘† â€² ; ğ¹ ; runelem0 (elem ğ‘› [0]) . . . runelemğ‘›âˆ’1 (elem ğ‘› [ğ‘› âˆ’ 1])
rundata0 (data ğ‘š [0]) . . . rundatağ‘šâˆ’1 (data ğ‘š [ğ‘š âˆ’ 1])
(call start.func)?
âŠ¢ module : externtype ğ‘˜im â†’ externtype *ex
(ğ‘† â€² âŠ¢ externval : externtype)ğ‘˜
(ğ‘† â€² âŠ¢ externtype â‰¤ closmoduleinst (externtype im ))ğ‘˜

âˆ§
âˆ§
âˆ§
âˆ§
âˆ§
âˆ§
âˆ§

module.globals = global *
module.elems = elem ğ‘›
module.datas = data ğ‘š
module.start = start ?
(expr g = global .init)*
(expr t = table.init)*
(expr *e = elem.init)ğ‘›

âˆ§
âˆ§

ğ‘† â€² , moduleinst = allocmodule(ğ‘†, module, externval ğ‘˜ , val *g , ref *t , (ref *e )ğ‘› )
ğ¹ = {module moduleinst, locals ğœ–}

âˆ§
âˆ§
âˆ§

(ğ‘† â€² ; ğ¹ ; expr g Ë“â†’ * ğ‘† â€² ; ğ¹ ; val g end)*
(ğ‘† â€² ; ğ¹ ; expr t Ë“â†’ * ğ‘† â€² ; ğ¹ ; ref t end)*
((ğ‘† â€² ; ğ¹ ; expr e Ë“â†’ * ğ‘† â€² ; ğ¹ ; ref e end)* )ğ‘› )

=

where:
runelemğ‘– ({type et, init expr ğ‘› , mode passive}) = ğœ–
runelemğ‘– ({type et, init expr ğ‘› , mode active{table ğ‘¥, offset instr * end}})
instr * (i32.const 0) (i32.const ğ‘›) (table.init ğ‘¥ ğ‘–) (elem.drop ğ‘–)
runelemğ‘– ({type et, init expr ğ‘› , mode declarative}) =
(elem.drop ğ‘–)

=

rundatağ‘– ({init ğ‘ğ‘› , mode passive}) =
ğœ–
rundatağ‘– ({init ğ‘ğ‘› , mode active{memory ğ‘¥, offset instr * end}}) =
instr * (i32.const 0) (i32.const ğ‘›) (memory.init ğ‘¥ ğ‘–) (data.drop ğ‘–)

Ã² Note
Checking import types assumes that the module instance has already been allocated to compute the respective
closed defined types. However, this forward reference merely is a way to simplify the specification. In practice,
implementations will likely allocate or canonicalize types beforehand, when compiling a module, in a stage
before instantiation and before imports are checked.
Similarly, module allocation and the evaluation of global and table initializers as well as element segments are
mutually recursive because the global initialization values val *g , ref t , and element segment contents (ref * )*
are passed to the module allocator while depending on the module instance moduleinst and store ğ‘† â€² returned
by allocation. Again, this recursion is just a specification device. In practice, the initialization values can be
determined beforehand by staging module allocation such that first, the moduleâ€™s own function instances are
pre-allocated in the store, then the initializer expressions are evaluated in order, allocating globals on the way,
then the rest of the module instance is allocated, and finally the new function instancesâ€™ module fields are set to
that module instance. This is possible because validation ensures that initialization expressions cannot actually
call a function, only take their reference.
All failure conditions are checked before any observable mutation of the store takes place. Store mutation is
not atomic; it happens in individual steps that may be interleaved with other threads.
Evaluation of constant expressions does not affect the store.

4.7. Modules

179

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

4.7.3 Invocation
Once a module has been instantiated, any exported function can be invoked externally via its function address
funcaddr in the store ğ‘† and an appropriate list val * of argument values.
Invocation may fail with an error if the arguments do not fit the function type. Invocation can also result in an
exception or trap. It is up to the embedder to define how such conditions are reported.
Ã² Note
If the embedder API performs type checks itself, either statically or dynamically, before performing an invocation, then no failure other than traps or exceptions can occur.
The following steps are performed:
1. Assert: ğ‘†.funcs[funcaddr ] exists.
2. Let funcinst be the function instance ğ‘†.funcs[funcaddr ].
3. Let func [ğ‘¡ğ‘›1 ] â†’ [ğ‘¡ğ‘š
2 ] be the composite type expand(funcinst.type).
4. If the length |val * | of the provided argument values is different from the number ğ‘› of expected arguments,
then:
a. Fail.
5. For each value type ğ‘¡ğ‘– in ğ‘¡ğ‘›1 and corresponding value ğ‘£ğ‘ğ‘™ğ‘– in val * , do:
a. If val ğ‘– is not valid with value type ğ‘¡ğ‘– , then:
i. Fail.
6. Let ğ¹ be the dummy frame {module {}, locals ğœ–}.
7. Push the frame ğ¹ to the stack.
8. Push the values val * to the stack.
9. Invoke the function instance at address funcaddr .
Once the function has returned, the following steps are executed:
1. Assert: due to validation, ğ‘š values are on the top of the stack.
2. Pop val ğ‘š
res from the stack.
3. Assert: due to validation, the frame ğ¹ is now on the top of the stack.
4. Pop the frame ğ¹ from the stack.
The values val ğ‘š
res are returned as the results of the invocation.
invoke(ğ‘†, funcaddr , val ğ‘› )

180

=
(if
âˆ§
âˆ§

ğ‘†; ğ¹ ; val ğ‘› (invoke funcaddr )
expand(ğ‘†.funcs[funcaddr ].type) = func [ğ‘¡ğ‘›1 ] â†’ [ğ‘¡ğ‘š
2 ]
(ğ‘† âŠ¢ val : ğ‘¡1 )ğ‘›
ğ¹ = {module {}, locals ğœ–})

Chapter 4. Execution

CHAPTER

5

Binary Format

5.1 Conventions
The binary format for WebAssembly modules is a dense linear encoding of their abstract syntax.29
The format is defined by an attribute grammar whose only terminal symbols are bytes. A byte sequence is a
well-formed encoding of a module if and only if it is generated by the grammar.
Each production of this grammar has exactly one synthesized attribute: the abstract syntax that the respective byte
sequence encodes. Thus, the attribute grammar implicitly defines a decoding function (i.e., a parsing function for
the binary format).
Except for a few exceptions, the binary grammar closely mirrors the grammar of the abstract syntax.
Ã² Note
Some phrases of abstract syntax have multiple possible encodings in the binary format. For example, numbers
may be encoded as if they had optional leading zeros. Implementations of decoders must support all possible
alternatives; implementations of encoders can pick any allowed encoding.
The recommended extension for files containing WebAssembly modules in binary format is â€œ.wasmâ€ and the recommended Media Type28 is â€œapplication/wasmâ€.

5.1.1 Grammar
The following conventions are adopted in defining grammar rules for the binary format. They mirror the conventions used for abstract syntax. In order to distinguish symbols of the binary syntax from symbols of the abstract
syntax, typewriter font is adopted for the former.
â€¢ Terminal symbols are bytes expressed in hexadecimal notation: 0x0F.
â€¢ Nonterminal symbols are written in typewriter font: valtype, instr.
â€¢ ğµ ğ‘› is a sequence of ğ‘› â‰¥ 0 iterations of ğµ.
â€¢ ğµ * is a possibly empty sequence of iterations of ğµ. (This is a shorthand for ğµ ğ‘› used where ğ‘› is not relevant.)
29 Additional encoding layers â€“ for example, introducing compression â€“ may be defined on top of the basic representation defined here.
However, such layers are outside the scope of the current specification.
28 https://www.iana.org/assignments/media-types/media-types.xhtml

181

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

â€¢ ğµ ? is an optional occurrence of ğµ. (This is a shorthand for ğµ ğ‘› where ğ‘› â‰¤ 1.)
â€¢ ğ‘¥:ğµ denotes the same language as the nonterminal ğµ, but also binds the variable ğ‘¥ to the attribute synthesized
for ğµ. A pattern may also be used instead of a variable, e.g., 7:ğµ.
â€¢ Productions are written sym ::= ğµ1 â‡’ ğ´1 | . . . | ğµğ‘› â‡’ ğ´ğ‘› , where each ğ´ğ‘– is the attribute that is
synthesized for sym in the given case, usually from attribute variables bound in ğµğ‘– .
â€¢ Large productions may be split into multiple definitions, indicated by ending the first one with explicit ellipses, sym ::= ğµ1 â‡’ ğ´1 | . . ., and starting continuations with ellipses, sym ::= . . . | ğµ2 â‡’ ğ´2 .
â€¢ Some productions are augmented by side conditions in parentheses, which restrict the applicability of the
production. They provide a shorthand for a combinatorial expansion of the production into many separate
cases.
â€¢ If the same meta variable or non-terminal symbol appears multiple times in a production (in the syntax or
in an attribute), then all those occurrences must have the same instantiation. (This is a shorthand for a side
condition requiring multiple different variables to be equal.)
Ã² Note
For example, the binary grammar for number types is given as follows:
numtype

::=
|
|
|

0x7F
0x7E
0x7D
0x7C

â‡’
â‡’
â‡’
â‡’

i32
i64
f32
f64

Consequently, the byte 0x7F encodes the type i32, 0x7E encodes the type i64, and so forth. No other byte value
is allowed as the encoding of a number type.
The binary grammar for limits is defined as follows:
limits

::= 0x00 ğ‘›:u32
|
0x01 ğ‘›:u32 ğ‘š:u32

â‡’
â‡’

{min ğ‘›, max ğœ–}
{min ğ‘›, max ğ‘š}

That is, a limits pair is encoded as either the byte 0x00 followed by the encoding of a u32 value, or the byte 0x01
followed by two such encodings. The variables ğ‘› and ğ‘š name the attributes of the respective u32 nonterminals,
which in this case are the actual unsigned integers those decode into. The attribute of the complete production
then is the abstract syntax for the limit, expressed in terms of the former values.

5.1.2 Auxiliary Notation
When dealing with binary encodings the following notation is also used:
â€¢ ğœ– denotes the empty byte sequence.
â€¢ ||ğµ|| is the length of the byte sequence generated from the production ğµ in a derivation.

5.1.3 Vectors
Vectors are encoded with their u32 length followed by the encoding of their element sequence.
vec(B)

182

::= ğ‘›:u32 (ğ‘¥:B)ğ‘›

â‡’ ğ‘¥ğ‘›

Chapter 5. Binary Format

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

5.2 Values
5.2.1 Bytes
Bytes encode themselves.
byte ::= 0x00 â‡’
|
...
|
0xFF â‡’

0x00
0xFF

5.2.2 Integers
All integers are encoded using the LEB12830 variable-length integer encoding, in either unsigned or signed variant.
Unsigned integers are encoded in unsigned LEB12831 format. As an additional constraint, the total number of
bytes encoding a value of type uğ‘ must not exceed ceil(ğ‘/7) bytes.
uğ‘

::= ğ‘›:byte
â‡’
|
ğ‘›:byte ğ‘š:u(ğ‘ âˆ’7) â‡’

ğ‘›
27 Â· ğ‘š + (ğ‘› âˆ’ 27 )

(if ğ‘› < 27 âˆ§ ğ‘› < 2ğ‘ )
(if ğ‘› â‰¥ 27 âˆ§ ğ‘ > 7)

Signed integers are encoded in signed LEB12832 format, which uses a twoâ€™s complement representation. As an
additional constraint, the total number of bytes encoding a value of type sğ‘ must not exceed ceil(ğ‘/7) bytes.
sğ‘

::= ğ‘›:byte
â‡’ ğ‘›
|
ğ‘›:byte
â‡’ ğ‘› âˆ’ 27
|
ğ‘›:byte ğ‘š:s(ğ‘ âˆ’7) â‡’ 27 Â· ğ‘š + (ğ‘› âˆ’ 27 )

(if ğ‘› < 26 âˆ§ ğ‘› < 2ğ‘ âˆ’1 )
(if 26 â‰¤ ğ‘› < 27 âˆ§ ğ‘› â‰¥ 27 âˆ’ 2ğ‘ âˆ’1 )
(if ğ‘› â‰¥ 27 âˆ§ ğ‘ > 7)

Uninterpreted integers are encoded as signed integers.
iğ‘

::= ğ‘›:sğ‘

â‡’ ğ‘–

(if ğ‘› = signedğ‘ (ğ‘–))

Ã² Note
The side conditions ğ‘ > 7 in the productions for non-terminal bytes of the u and s encodings restrict the
encodingâ€™s length. However, â€œtrailing zerosâ€ are still allowed within these bounds. For example, 0x03 and
0x83 0x00 are both well-formed encodings for the value 3 as a u8 . Similarly, either of 0x7e and 0xFE 0x7F
and 0xFE 0xFF 0x7F are well-formed encodings of the value âˆ’2 as a s16 .
The side conditions on the value ğ‘› of terminal bytes further enforce that any unused bits in these bytes must
be 0 for positive values and 1 for negative ones. For example, 0x83 0x10 is malformed as a u8 encoding.
Similarly, both 0x83 0x3E and 0xFF 0x7B are malformed as s8 encodings.

5.2.3 Floating-Point
Floating-point values are encoded directly by their IEEE 75433 (Section 3.4) bit pattern in little endian34 byte order:
fğ‘

::=

ğ‘* : byteğ‘/8

â‡’

*
bytesâˆ’1
f ğ‘ (ğ‘ )

30 https://en.wikipedia.org/wiki/LEB128

31 https://en.wikipedia.org/wiki/LEB128#Unsigned_LEB128
32 https://en.wikipedia.org/wiki/LEB128#Signed_LEB128
33 https://ieeexplore.ieee.org/document/8766229

34 https://en.wikipedia.org/wiki/Endianness#Little-endian

5.2. Values

183

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

5.2.4 Names
Names are encoded as a vector of bytes containing the Unicode35 (Section 3.9) UTF-8 encoding of the nameâ€™s
character sequence.
name ::= ğ‘* :vec(byte) â‡’ name

(if utf8(name) = ğ‘* )

The auxiliary utf8 function expressing this encoding is defined as follows:
utf8(ğ‘* )

=

(utf8(ğ‘))*

utf8(ğ‘)

= ğ‘

utf8(ğ‘)

= ğ‘1 ğ‘2

utf8(ğ‘)

= ğ‘1 ğ‘2 ğ‘3

utf8(ğ‘)

= ğ‘1 ğ‘2 ğ‘3 ğ‘4

where ğ‘2 , ğ‘3 , ğ‘4 < 0xC0

(if ğ‘ < U+80
âˆ§ ğ‘ = ğ‘)
(if U+80 â‰¤ ğ‘ < U+800
âˆ§ ğ‘ = 26 (ğ‘1 âˆ’ 0xC0) + (ğ‘2 âˆ’ 0x80))
(if U+800 â‰¤ ğ‘ < U+D800 âˆ¨ U+E000 â‰¤ ğ‘ < U+10000
âˆ§ ğ‘ = 212 (ğ‘1 âˆ’ 0xE0) + 26 (ğ‘2 âˆ’ 0x80) + (ğ‘3 âˆ’ 0x80))
(if U+10000 â‰¤ ğ‘ < U+110000
âˆ§ ğ‘ = 218 (ğ‘1 âˆ’ 0xF0) + 212 (ğ‘2 âˆ’ 0x80) + 26 (ğ‘3 âˆ’ 0x80) + (ğ‘4 âˆ’ 0x80))

Ã² Note
Unlike in some other formats, name strings are not 0-terminated.

5.3 Types
Ã² Note
In some places, possible types include both type constructors or types denoted by type indices. Thus, the
binary format for type constructors corresponds to the encodings of small negative sğ‘ values, such that they
can unambiguously occur in the same place as (positive) type indices.

5.3.1 Number Types
Number types are encoded by a single byte.
â‡’
â‡’
â‡’
â‡’

i32
i64
f32
f64

vectype ::= 0x7B â‡’

v128

numtype ::=
|
|
|

0x7F
0x7E
0x7D
0x7C

5.3.2 Vector Types
Vector types are also encoded by a single byte.

35 https://www.unicode.org/versions/latest/

184

Chapter 5. Binary Format

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

5.3.3 Heap Types
Heap types are encoded as either a single byte, or as a type index encoded as a positive signed integer.
absheaptype ::=
|
|
|
|
|
|
|
|
|
|
|
heaptype
::=
|

0x74
0x73
0x72
0x71
0x70
0x6F
0x6E
0x6D
0x6C
0x6B
0x6A
0x69
ht:absheaptype
ğ‘¥:s33

â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’

noexn
nofunc
noextern
none
func
extern
any
eq
i31
struct
array
exn
ht
ğ‘¥

(if ğ‘¥ â‰¥ 0)

5.3.4 Reference Types
Reference types are either encoded by a single byte followed by a heap type, or, as a short form, directly as an
abstract heap type.
reftype ::= 0x64 ht:heaptype â‡’
|
0x63 ht:heaptype â‡’
|
ht:absheaptype
â‡’

ref ht
ref null ht
ref null ht

5.3.5 Value Types
Value types are encoded with their respective encoding as a number type, vector type, or reference type.
valtype ::=
|
|

ğ‘¡:numtype â‡’ ğ‘¡
ğ‘¡:vectype â‡’ ğ‘¡
ğ‘¡:reftype â‡’ ğ‘¡

Ã² Note
The type bot cannot occur in a module.
Value types can occur in contexts where type indices are also allowed, such as in the case of block types. Thus,
the binary format for types corresponds to the signed LEB12836 encoding of small negative sğ‘ values, so that
they can coexist with (positive) type indices in the future.

5.3.6 Result Types
Result types are encoded by the respective vectors of value types.
resulttype ::=

ğ‘¡* : vec(valtype) â‡’ [ğ‘¡* ]

5.3.7 Function Types
Function types are encoded by the respective vectors of parameter and result types.
functype ::=

rt 1 : resulttype rt 2 : resulttype â‡’ rt 1 â†’ rt 2

36 https://en.wikipedia.org/wiki/LEB128#Signed_LEB128

5.3. Types

185

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

5.3.8 Aggregate Types
Aggregate types are encoded with their respective field types.
arraytype
structtype
fieldtype
storagetype
packedtype

::=
::=
::=
::=
|
::=
|

ft: fieldtype
ft * : vec(fieldtype)
st:storagetype ğ‘š:mut
ğ‘¡:valtype
ğ‘¡:packedtype
0x78
0x77

â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’

ft
ft *
ğ‘š st
ğ‘¡
ğ‘¡
i8
i16

5.3.9 Composite Types
Composite types are encoded by a distinct byte followed by a type encoding of the respective form.
comptype ::= 0x5E at:arraytype â‡’ array at
|
0x5F st:structtype â‡’ struct st
|
0x60 ft:functype
â‡’ func ft

5.3.10 Recursive Types
Recursive types are encoded by the byte 0x4E followed by a vector of sub types. Additional shorthands are recognized for unary recursions and sub types without super types.
0x4E st * : vec(subtype)
st:subtype
0x50 ğ‘¥* : vec(typeidx) ct:comptype
0x4F ğ‘¥* : vec(typeidx) ct:comptype
ct:comptype

::=
|
subtype ::=
|
|

rectype

rec st *
rec st
sub ğ‘¥* ct
sub final ğ‘¥* ct
sub final ğœ– ct

â‡’
â‡’
â‡’
â‡’
â‡’

5.3.11 Limits
Limits are encoded with a preceding flag indicating whether a maximum is present, and a flag for the address type.
limits

::=
|
|
|

0x00 ğ‘›:u64
0x01 ğ‘›:u64 ğ‘š:u64
0x04 ğ‘›:u64
0x05 ğ‘›:u64 ğ‘š:u64

â‡’
â‡’
â‡’
â‡’

(i32, {min ğ‘›, max ğœ–})
(i32, {min ğ‘›, max ğ‘š})
(i64, {min ğ‘›, max ğœ–})
(i64, {min ğ‘›, max ğ‘š})

5.3.12 Memory Types
Memory types are encoded with their limits.
memtype ::=

(at, lim):limits â‡’

at lim

5.3.13 Table Types
Table types are encoded with their limits and the encoding of their element reference type.
tabletype

186

::= et:reftype (at, lim):limits

â‡’ at lim et

Chapter 5. Binary Format

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

5.3.14 Global Types
Global types are encoded by their value type and a flag for their mutability.
globaltype ::= ğ‘¡:valtype ğ‘š:mut
mut
::= 0x00
|
0x01

â‡’ ğ‘šğ‘¡
â‡’ const
â‡’ var

5.3.15 Tag Types
Tag types are encoded by a type index denoting a function type.
tagtype ::=

0x00 ğ‘¥:typeidx â‡’ ğ‘¥

Ã² Note
In future versions of WebAssembly, the preceding zero byte may encode additional flags.

5.4 Instructions
Instructions are encoded by opcodes. Each opcode is represented by a single byte, and is followed by the instructionâ€™s immediate arguments, where present. The only exception are structured control instructions, which consist
of several opcodes bracketing their nested instruction sequences.
Ã² Note
Gaps in the byte code ranges for encoding instructions are reserved for future extensions.

5.4.1 Control Instructions
Control instructions have varying encodings. For structured instructions, the instruction sequences forming nested
blocks are delimited with explicit opcodes for end and else.
Block types are encoded in special compressed form, by either the byte 0x40 indicating the empty type, as a single
value type, or as a type index encoded as a positive signed integer.

5.4. Instructions

187

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

blocktype ::=
|
|
instr
::=
|
|
|
|
|

catch

castflags

0x40
ğ‘¡:valtype
ğ‘¥:s33
0x00
0x01
0x02 bt:blocktype (in:instr)* 0x0B
0x03 bt:blocktype (in:instr)* 0x0B
0x04 bt:blocktype (in:instr)* 0x0B
0x04 bt:blocktype (in 1 :instr)*
0x05 (in 2 :instr)* 0x0B
|
0x08 ğ‘¥:tagidx
|
0x0A
|
0x0C ğ‘™:labelidx
|
0x0D ğ‘™:labelidx
|
0x0E ğ‘™* :vec(labelidx) ğ‘™ğ‘ :labelidx
|
0x0F
|
0x10 ğ‘¥:funcidx
|
0x11 ğ‘¦:typeidx ğ‘¥:tableidx
|
0x12 ğ‘¥:funcidx
|
0x13 ğ‘¦:typeidx ğ‘¥:tableidx
|
0x14 ğ‘¥:typeidx
|
0x15 ğ‘¥:typeidx
|
0x1F bt:blocktype ğ‘* :vec(catch)
(in:instr)* 0x0B
|
0xD5 ğ‘™:labelidx
|
0xD6 ğ‘™:labelidx
|
0xFB 24:u32 (null?1 , null?2 ):castflags
ğ‘™:labelidx ht 1 :heaptype ht 2 :heaptype
|
0xFB 25:u32 (null?1 , null?2 ):castflags
ğ‘™:labelidx ht 1 :heaptype ht 2 :heaptype
::= 0x00 ğ‘¥:tagidx ğ‘™:labelidx
|
0x01 ğ‘¥:tagidx ğ‘™:labelidx
|
0x02 ğ‘™:labelidx
|
0x03 ğ‘™:labelidx
::= 0:u8
|
1:u8
|
2:u8
|
3:u8
|
...

â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’

ğœ–
ğ‘¡
ğ‘¥
(if ğ‘¥ â‰¥ 0)
unreachable
nop
block bt in * end
loop bt in * end
if bt in * else ğœ– end

â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’

if bt in *1 else in *2 end
throw ğ‘¥
throw_ref
br ğ‘™
br_if ğ‘™
br_table ğ‘™* ğ‘™ğ‘
return
call ğ‘¥
call_indirect ğ‘¥ ğ‘¦
return_call ğ‘¥
return_call_indirect ğ‘¥ ğ‘¦
call_ref ğ‘¥
return_call_ref ğ‘¥

â‡’ try_table bt ğ‘* in * end
â‡’ br_on_null ğ‘™
â‡’ br_on_non_null ğ‘™
â‡’ br_on_cast ğ‘™ (ref null?1 ht 1 ) (ref null?2 ht 2 )
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’

br_on_cast_fail ğ‘™ (ref null?1 ht 1 ) (ref null?2 ht 2 )
catch ğ‘¥ ğ‘™
catch_ref ğ‘¥ ğ‘™
catch_all ğ‘™
catch_all_ref ğ‘™
(ğœ–, ğœ–)
(null, ğœ–)
(ğœ–, null)
(null, null)

Ã² Note
The else opcode 0x05 in the encoding of an if instruction can be omitted if the following instruction sequence
is empty.
Unlike any other occurrence, the type index in a block type is encoded as a positive signed integer, so that its
signed LEB128 bit pattern cannot collide with the encoding of value types or the special code 0x40, which
correspond to the LEB128 encoding of negative integers. To avoid any loss in the range of allowed indices, it
is treated as a 33 bit signed integer.

5.4.2 Reference Instructions
Generic reference instructions are represented by single byte codes, others use prefixes and type operands.

188

Chapter 5. Binary Format

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

instr

::=
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|

...
0xD0 ğ‘¡:heaptype
0xD1
0xD2 ğ‘¥:funcidx
0xD3
0xD4
0xFB 0:u32 ğ‘¥:typeidx
0xFB 1:u32 ğ‘¥:typeidx
0xFB 2:u32 ğ‘¥:typeidx ğ‘¦:fieldidx
0xFB 3:u32 ğ‘¥:typeidx ğ‘¦:fieldidx
0xFB 4:u32 ğ‘¥:typeidx ğ‘¦:fieldidx
0xFB 5:u32 ğ‘¥:typeidx ğ‘¦:fieldidx
0xFB 6:u32 ğ‘¥:typeidx
0xFB 7:u32 ğ‘¥:typeidx
0xFB 8:u32 ğ‘¥:typeidx ğ‘›:u32
0xFB 9:u32 ğ‘¥:typeidx ğ‘¦:dataidx
0xFB 10:u32 ğ‘¥:typeidx ğ‘¦:elemidx
0xFB 11:u32 ğ‘¥:typeidx
0xFB 12:u32 ğ‘¥:typeidx
0xFB 13:u32 ğ‘¥:typeidx
0xFB 14:u32 ğ‘¥:typeidx
0xFB 15:u32
0xFB 16:u32 ğ‘¥:typeidx
0xFB 17:u32 ğ‘¥:typeidx ğ‘¦:typeidx
0xFB 18:u32 ğ‘¥:typeidx ğ‘¦:dataidx
0xFB 19:u32 ğ‘¥:typeidx ğ‘¦:elemidx
0xFB 20:u32 ht:heaptype
0xFB 21:u32 ht:heaptype
0xFB 22:u32 ht:heaptype
0xFB 23:u32 ht:heaptype
0xFB 26:u32
0xFB 27:u32
0xFB 28:u32
0xFB 29:u32
0xFB 30:u32

â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’

ref.null ğ‘¡
ref.is_null
ref.func ğ‘¥
ref.eq
ref.as_non_null
struct.new ğ‘¥
struct.new_default ğ‘¥
struct.get ğ‘¥ ğ‘¦
struct.get_s ğ‘¥ ğ‘¦
struct.get_u ğ‘¥ ğ‘¦
struct.set ğ‘¥ ğ‘¦
array.new ğ‘¥
array.new_default ğ‘¥
array.new_fixed ğ‘¥ ğ‘›
array.new_data ğ‘¥ ğ‘¦
array.new_elem ğ‘¥ ğ‘¦
array.get ğ‘¥
array.get_s ğ‘¥
array.get_u ğ‘¥
array.set ğ‘¥
array.len
array.fill ğ‘¥
array.copy ğ‘¥ ğ‘¦
array.init_data ğ‘¥ ğ‘¦
array.init_elem ğ‘¥ ğ‘¦
ref.test (ref ht)
ref.test (ref null ht)
ref.cast (ref ht)
ref.cast (ref null ht)
any.convert_extern
extern.convert_any
ref.i31
i31.get_s
i31.get_u

5.4.3 Parametric Instructions
Parametric instructions are represented by single byte codes, possibly followed by a type annotation.

instr ::=
|
|
|

...
0x1A
â‡’ drop
0x1B
â‡’ select
0x1C ğ‘¡* :vec(valtype) â‡’ select ğ‘¡*

5.4.4 Variable Instructions
Variable instructions are represented by byte codes followed by the encoding of the respective index.

5.4. Instructions

189

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

instr ::=
|
|
|
|
|

...
0x20 ğ‘¥:localidx
0x21 ğ‘¥:localidx
0x22 ğ‘¥:localidx
0x23 ğ‘¥:globalidx
0x24 ğ‘¥:globalidx

â‡’
â‡’
â‡’
â‡’
â‡’

local.get ğ‘¥
local.set ğ‘¥
local.tee ğ‘¥
global.get ğ‘¥
global.set ğ‘¥

5.4.5 Table Instructions
Table instructions are represented either by a single byte or a one byte prefix followed by a variable-length unsigned
integer.
instr ::=
|
|
|
|
|
|
|
|

...
0x25 ğ‘¥:tableidx
0x26 ğ‘¥:tableidx
0xFC 12:u32 ğ‘¦:elemidx ğ‘¥:tableidx
0xFC 13:u32 ğ‘¥:elemidx
0xFC 14:u32 ğ‘¥:tableidx ğ‘¦:tableidx
0xFC 15:u32 ğ‘¥:tableidx
0xFC 16:u32 ğ‘¥:tableidx
0xFC 17:u32 ğ‘¥:tableidx

â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’

table.get ğ‘¥
table.set ğ‘¥
table.init ğ‘¥ ğ‘¦
elem.drop ğ‘¥
table.copy ğ‘¥ ğ‘¦
table.grow ğ‘¥
table.size ğ‘¥
table.fill ğ‘¥

5.4.6 Memory Instructions
Each variant of memory instruction is encoded with a different byte code. Loads and stores are followed by the
encoding of their memarg immediate, which includes the memory index if bit 6 of the flags field containing
alignment is set; the memory index defaults to 0 otherwise.

190

Chapter 5. Binary Format

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

memarg
instr

::=
|
::=
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|

ğ‘:u32 ğ‘œ:u64
ğ‘:u32 ğ‘¥:memidx ğ‘œ:u64
...
0x28 ğ‘š:memarg
0x29 ğ‘š:memarg
0x2A ğ‘š:memarg
0x2B ğ‘š:memarg
0x2C ğ‘š:memarg
0x2D ğ‘š:memarg
0x2E ğ‘š:memarg
0x2F ğ‘š:memarg
0x30 ğ‘š:memarg
0x31 ğ‘š:memarg
0x32 ğ‘š:memarg
0x33 ğ‘š:memarg
0x34 ğ‘š:memarg
0x35 ğ‘š:memarg
0x36 ğ‘š:memarg
0x37 ğ‘š:memarg
0x38 ğ‘š:memarg
0x39 ğ‘š:memarg
0x3A ğ‘š:memarg
0x3B ğ‘š:memarg
0x3C ğ‘š:memarg
0x3D ğ‘š:memarg
0x3E ğ‘š:memarg
0x3F ğ‘¥:memidx
0x40 ğ‘¥:memidx
0xFC 8:u32 ğ‘¦:dataidx ğ‘¥:memidx
0xFC 9:u32 ğ‘¥:dataidx
0xFC 10:u32 ğ‘¥:memidx ğ‘¦:memidx
0xFC 11:u32 ğ‘¥:memidx

â‡’ 0 {align ğ‘, offset ğ‘œ}
(if ğ‘ < 26 )
6
â‡’ ğ‘¥ {align (ğ‘ âˆ’ 2 ), offset ğ‘œ} (if 26 â‰¤ ğ‘ < 27 )
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’

i32.load ğ‘š
i64.load ğ‘š
f32.load ğ‘š
f64.load ğ‘š
i32.load8_s ğ‘š
i32.load8_u ğ‘š
i32.load16_s ğ‘š
i32.load16_u ğ‘š
i64.load8_s ğ‘š
i64.load8_u ğ‘š
i64.load16_s ğ‘š
i64.load16_u ğ‘š
i64.load32_s ğ‘š
i64.load32_u ğ‘š
i32.store ğ‘š
i64.store ğ‘š
f32.store ğ‘š
f64.store ğ‘š
i32.store8 ğ‘š
i32.store16 ğ‘š
i64.store8 ğ‘š
i64.store16 ğ‘š
i64.store32 ğ‘š
memory.size ğ‘¥
memory.grow ğ‘¥
memory.init ğ‘¥ ğ‘¦
data.drop ğ‘¥
memory.copy ğ‘¥ ğ‘¦
memory.fill ğ‘¥

5.4.7 Numeric Instructions
All variants of numeric instructions are represented by separate byte codes.
The const instructions are followed by the respective literal.

instr ::=
|
|
|
|

...
0x41 ğ‘›:i32
0x42 ğ‘›:i64
0x43 ğ‘§:f32
0x44 ğ‘§:f64

â‡’
â‡’
â‡’
â‡’

i32.const ğ‘›
i64.const ğ‘›
f32.const ğ‘§
f64.const ğ‘§

All other numeric instructions are plain opcodes without any immediates.

5.4. Instructions

191

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

192

instr ::=
|
|
|
|
|
|
|
|
|
|
|

...
0x45
0x46
0x47
0x48
0x49
0x4A
0x4B
0x4C
0x4D
0x4E
0x4F

â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’

i32.eqz
i32.eq
i32.ne
i32.lt_s
i32.lt_u
i32.gt_s
i32.gt_u
i32.le_s
i32.le_u
i32.ge_s
i32.ge_u

|
|
|
|
|
|
|
|
|
|
|

0x50
0x51
0x52
0x53
0x54
0x55
0x56
0x57
0x58
0x59
0x5A

â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’

i64.eqz
i64.eq
i64.ne
i64.lt_s
i64.lt_u
i64.gt_s
i64.gt_u
i64.le_s
i64.le_u
i64.ge_s
i64.ge_u

|
|
|
|
|
|

0x5B
0x5C
0x5D
0x5E
0x5F
0x60

â‡’
â‡’
â‡’
â‡’
â‡’
â‡’

f32.eq
f32.ne
f32.lt
f32.gt
f32.le
f32.ge

|
|
|
|
|
|

0x61
0x62
0x63
0x64
0x65
0x66

â‡’
â‡’
â‡’
â‡’
â‡’
â‡’

f64.eq
f64.ne
f64.lt
f64.gt
f64.le
f64.ge

|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|

0x67
0x68
0x69
0x6A
0x6B
0x6C
0x6D
0x6E
0x6F
0x70
0x71
0x72
0x73
0x74
0x75
0x76
0x77
0x78

â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’

i32.clz
i32.ctz
i32.popcnt
i32.add
i32.sub
i32.mul
i32.div_s
i32.div_u
i32.rem_s
i32.rem_u
i32.and
i32.or
i32.xor
i32.shl
i32.shr_s
i32.shr_u
i32.rotl
i32.rotr
Chapter 5. Binary Format

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

5.4. Instructions

|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|

0x79
0x7A
0x7B
0x7C
0x7D
0x7E
0x7F
0x80
0x81
0x82
0x83
0x84
0x85
0x86
0x87
0x88
0x89
0x8A

â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’

i64.clz
i64.ctz
i64.popcnt
i64.add
i64.sub
i64.mul
i64.div_s
i64.div_u
i64.rem_s
i64.rem_u
i64.and
i64.or
i64.xor
i64.shl
i64.shr_s
i64.shr_u
i64.rotl
i64.rotr

|
|
|
|
|
|
|
|
|
|
|
|
|
|

0x8B
0x8C
0x8D
0x8E
0x8F
0x90
0x91
0x92
0x93
0x94
0x95
0x96
0x97
0x98

â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’

f32.abs
f32.neg
f32.ceil
f32.floor
f32.trunc
f32.nearest
f32.sqrt
f32.add
f32.sub
f32.mul
f32.div
f32.min
f32.max
f32.copysign

|
|
|
|
|
|
|
|
|
|
|
|
|
|

0x99
0x9A
0x9B
0x9C
0x9D
0x9E
0x9F
0xA0
0xA1
0xA2
0xA3
0xA4
0xA5
0xA6

â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’

f64.abs
f64.neg
f64.ceil
f64.floor
f64.trunc
f64.nearest
f64.sqrt
f64.add
f64.sub
f64.mul
f64.div
f64.min
f64.max
f64.copysign

193

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|

0xA7
0xA8
0xA9
0xAA
0xAB
0xAC
0xAD
0xAE
0xAF
0xB0
0xB1
0xB2
0xB3
0xB4
0xB5
0xB6
0xB7
0xB8
0xB9
0xBA
0xBB
0xBC
0xBD
0xBE
0xBF

â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’

i32.wrap_i64
i32.trunc_f32_s
i32.trunc_f32_u
i32.trunc_f64_s
i32.trunc_f64_u
i64.extend_i32_s
i64.extend_i32_u
i64.trunc_f32_s
i64.trunc_f32_u
i64.trunc_f64_s
i64.trunc_f64_u
f32.convert_i32_s
f32.convert_i32_u
f32.convert_i64_s
f32.convert_i64_u
f32.demote_f64
f64.convert_i32_s
f64.convert_i32_u
f64.convert_i64_s
f64.convert_i64_u
f64.promote_f32
i32.reinterpret_f32
i64.reinterpret_f64
f32.reinterpret_i32
f64.reinterpret_i64

|
|
|
|
|

0xC0
0xC1
0xC2
0xC3
0xC4

â‡’
â‡’
â‡’
â‡’
â‡’

i32.extend8_s
i32.extend16_s
i64.extend8_s
i64.extend16_s
i64.extend32_s

The saturating truncation instructions all have a one byte prefix, whereas the actual opcode is encoded by a variablelength unsigned integer.
instr ::=
|
|
|
|
|
|
|
|

...
0xFC 0:u32
0xFC 1:u32
0xFC 2:u32
0xFC 3:u32
0xFC 4:u32
0xFC 5:u32
0xFC 6:u32
0xFC 7:u32

â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’

i32.trunc_sat_f32_s
i32.trunc_sat_f32_u
i32.trunc_sat_f64_s
i32.trunc_sat_f64_u
i64.trunc_sat_f32_s
i64.trunc_sat_f32_u
i64.trunc_sat_f64_s
i64.trunc_sat_f64_u

5.4.8 Vector Instructions
All variants of vector instructions are represented by separate byte codes. They all have a one byte prefix, whereas
the actual opcode is encoded by a variable-length unsigned integer.
Vector loads and stores are followed by the encoding of their memarg immediate.

194

Chapter 5. Binary Format

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

laneidx ::= ğ‘™:byte
instr
::= . . .
|
0xFD 0:u32 ğ‘š:memarg
|
0xFD 1:u32 ğ‘š:memarg
|
0xFD 2:u32 ğ‘š:memarg
|
0xFD 3:u32 ğ‘š:memarg
|
0xFD 4:u32 ğ‘š:memarg
|
0xFD 5:u32 ğ‘š:memarg
|
0xFD 6:u32 ğ‘š:memarg
|
0xFD 7:u32 ğ‘š:memarg
|
0xFD 8:u32 ğ‘š:memarg
|
0xFD 9:u32 ğ‘š:memarg
|
0xFD 10:u32 ğ‘š:memarg
|
0xFD 92:u32 ğ‘š:memarg
|
0xFD 93:u32 ğ‘š:memarg
|
0xFD 11:u32 ğ‘š:memarg
|
0xFD 84:u32 ğ‘š:memarg ğ‘™:laneidx
|
0xFD 85:u32 ğ‘š:memarg ğ‘™:laneidx
|
0xFD 86:u32 ğ‘š:memarg ğ‘™:laneidx
|
0xFD 87:u32 ğ‘š:memarg ğ‘™:laneidx
|
0xFD 88:u32 ğ‘š:memarg ğ‘™:laneidx
|
0xFD 89:u32 ğ‘š:memarg ğ‘™:laneidx
|
0xFD 90:u32 ğ‘š:memarg ğ‘™:laneidx
|
0xFD 91:u32 ğ‘š:memarg ğ‘™:laneidx

â‡’ ğ‘™
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’

v128.load ğ‘š
v128.load8x8_s ğ‘š
v128.load8x8_u ğ‘š
v128.load16x4_s ğ‘š
v128.load16x4_u ğ‘š
v128.load32x2_s ğ‘š
v128.load32x2_u ğ‘š
v128.load8_splat ğ‘š
v128.load16_splat ğ‘š
v128.load32_splat ğ‘š
v128.load64_splat ğ‘š
v128.load32_zero ğ‘š
v128.load64_zero ğ‘š
v128.store ğ‘š
v128.load8_lane ğ‘š ğ‘™
v128.load16_lane ğ‘š ğ‘™
v128.load32_lane ğ‘š ğ‘™
v128.load64_lane ğ‘š ğ‘™
v128.store8_lane ğ‘š ğ‘™
v128.store16_lane ğ‘š ğ‘™
v128.store32_lane ğ‘š ğ‘™
v128.store64_lane ğ‘š ğ‘™

The const instruction is followed by 16 immediate bytes, which are converted into a i128 in littleendian byte
order:
instr ::=
|

...
0xFD 12:u32 (ğ‘:byte)16

â‡’ v128.const bytesâˆ’1
i128 (ğ‘0 . . . ğ‘15 )

The shuffle instruction is also followed by the encoding of 16 laneidx immediates.
instr ::= . . .
|
0xFD 13:u32 (ğ‘™:laneidx)16

â‡’ i8x16.shuffle ğ‘™16

extract_lane and replace_lane instructions are followed by the encoding of a laneidx immediate.
instr

5.4. Instructions

::=
|
|
|
|
|
|
|
|
|
|
|
|
|
|

...
0xFD 21:u32 ğ‘™:laneidx
0xFD 22:u32 ğ‘™:laneidx
0xFD 23:u32 ğ‘™:laneidx
0xFD 24:u32 ğ‘™:laneidx
0xFD 25:u32 ğ‘™:laneidx
0xFD 26:u32 ğ‘™:laneidx
0xFD 27:u32 ğ‘™:laneidx
0xFD 28:u32 ğ‘™:laneidx
0xFD 29:u32 ğ‘™:laneidx
0xFD 30:u32 ğ‘™:laneidx
0xFD 31:u32 ğ‘™:laneidx
0xFD 32:u32 ğ‘™:laneidx
0xFD 33:u32 ğ‘™:laneidx
0xFD 34:u32 ğ‘™:laneidx

â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’

i8x16.extract_lane_s ğ‘™
i8x16.extract_lane_u ğ‘™
i8x16.replace_lane ğ‘™
i16x8.extract_lane_s ğ‘™
i16x8.extract_lane_u ğ‘™
i16x8.replace_lane ğ‘™
i32x4.extract_lane ğ‘™
i32x4.replace_lane ğ‘™
i64x2.extract_lane ğ‘™
i64x2.replace_lane ğ‘™
f32x4.extract_lane ğ‘™
f32x4.replace_lane ğ‘™
f64x2.extract_lane ğ‘™
f64x2.replace_lane ğ‘™

195

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

All other vector instructions are plain opcodes without any immediates.
instr

196

::=
|
|
|
|
|
|
|

...
0xFD 14:u32
0xFD 15:u32
0xFD 16:u32
0xFD 17:u32
0xFD 18:u32
0xFD 19:u32
0xFD 20:u32

|
|
|
|
|
|
|
|
|
|

0xFD 35:u32 â‡’
0xFD 36:u32 â‡’
0xFD 37:u32 â‡’
0xFD 38:u32 â‡’
0xFD 39:u32 â‡’
0xFD 40:u32 â‡’
0xFD 41:u32 â‡’
0xFD 42:u32 â‡’
0xFD 43:u32 â‡’
0xFD 44:u32 â‡’

i8x16.eq
i8x16.ne
i8x16.lt_s
i8x16.lt_u
i8x16.gt_s
i8x16.gt_u
i8x16.le_s
i8x16.le_u
i8x16.ge_s
i8x16.ge_u

|
|
|
|
|
|
|
|
|
|

0xFD 45:u32
0xFD 46:u32
0xFD 47:u32
0xFD 48:u32
0xFD 49:u32
0xFD 50:u32
0xFD 51:u32
0xFD 52:u32
0xFD 53:u32
0xFD 54:u32

â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’

i16x8.eq
i16x8.ne
i16x8.lt_s
i16x8.lt_u
i16x8.gt_s
i16x8.gt_u
i16x8.le_s
i16x8.le_u
i16x8.ge_s
i16x8.ge_u

|
|
|
|
|
|
|
|
|
|

0xFD 55:u32
0xFD 56:u32
0xFD 57:u32
0xFD 58:u32
0xFD 59:u32
0xFD 60:u32
0xFD 61:u32
0xFD 62:u32
0xFD 63:u32
0xFD 64:u32

â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’

i32x4.eq
i32x4.ne
i32x4.lt_s
i32x4.lt_u
i32x4.gt_s
i32x4.gt_u
i32x4.le_s
i32x4.le_u
i32x4.ge_s
i32x4.ge_u

|
|
|
|
|
|

0xFD 214:u32
0xFD 215:u32
0xFD 216:u32
0xFD 217:u32
0xFD 218:u32
0xFD 219:u32

â‡’
â‡’
â‡’
â‡’
â‡’
â‡’

i64x2.eq
i64x2.ne
i64x2.lt_s
i64x2.gt_s
i64x2.le_s
i64x2.ge_s

|
|
|
|
|
|

0xFD 65:u32
0xFD 66:u32
0xFD 67:u32
0xFD 68:u32
0xFD 69:u32
0xFD 70:u32

â‡’
â‡’
â‡’
â‡’
â‡’
â‡’

f32x4.eq
f32x4.ne
f32x4.lt
f32x4.gt
f32x4.le
f32x4.ge

â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’

i8x16.swizzle
i8x16.splat
i16x8.splat
i32x4.splat
i64x2.splat
f32x4.splat
f64x2.splat

Chapter 5. Binary Format

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

5.4. Instructions

|
|
|
|
|
|

0xFD 71:u32
0xFD 72:u32
0xFD 73:u32
0xFD 74:u32
0xFD 75:u32
0xFD 76:u32

â‡’
â‡’
â‡’
â‡’
â‡’
â‡’

f64x2.eq
f64x2.ne
f64x2.lt
f64x2.gt
f64x2.le
f64x2.ge

|
|
|
|
|
|
|

0xFD 77:u32
0xFD 78:u32
0xFD 79:u32
0xFD 80:u32
0xFD 81:u32
0xFD 82:u32
0xFD 83:u32

â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’

v128.not
v128.and
v128.andnot
v128.or
v128.xor
v128.bitselect
v128.any_true

|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|

0xFD 96:u32
0xFD 97:u32
0xFD 98:u32
0xFD 99:u32
0xFD 100:u32
0xFD 101:u32
0xFD 102:u32
0xFD 107:u32
0xFD 108:u32
0xFD 109:u32
0xFD 110:u32
0xFD 111:u32
0xFD 112:u32
0xFD 113:u32
0xFD 114:u32
0xFD 115:u32
0xFD 118:u32
0xFD 119:u32
0xFD 120:u32
0xFD 121:u32
0xFD 123:u32

â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’

i8x16.abs
i8x16.neg
i8x16.popcnt
i8x16.all_true
i8x16.bitmask
i8x16.narrow_i16x8_s
i8x16.narrow_i16x8_u
i8x16.shl
i8x16.shr_s
i8x16.shr_u
i8x16.add
i8x16.add_sat_s
i8x16.add_sat_u
i8x16.sub
i8x16.sub_sat_s
i8x16.sub_sat_u
i8x16.min_s
i8x16.min_u
i8x16.max_s
i8x16.max_u
i8x16.avgr_u

197

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

198

|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|

0xFD 124:u32
0xFD 125:u32
0xFD 128:u32
0xFD 129:u32
0xFD 130:u32
0xFD 131:u32
0xFD 132:u32
0xFD 133:u32
0xFD 134:u32
0xFD 135:u32
0xFD 136:u32
0xFD 137:u32
0xFD 138:u32
0xFD 139:u32
0xFD 140:u32
0xFD 141:u32
0xFD 142:u32
0xFD 143:u32
0xFD 144:u32
0xFD 145:u32
0xFD 146:u32
0xFD 147:u32
0xFD 149:u32
0xFD 150:u32
0xFD 151:u32
0xFD 152:u32
0xFD 153:u32
0xFD 155:u32
0xFD 156:u32
0xFD 157:u32
0xFD 158:u32
0xFD 159:u32

â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’

i16x8.extadd_pairwise_i8x16_s
i16x8.extadd_pairwise_i8x16_u
i16x8.abs
i16x8.neg
i16x8.q15mulr_sat_s
i16x8.all_true
i16x8.bitmask
i16x8.narrow_i32x4_s
i16x8.narrow_i32x4_u
i16x8.extend_low_i8x16_s
i16x8.extend_high_i8x16_s
i16x8.extend_low_i8x16_u
i16x8.extend_high_i8x16_u
i16x8.shl
i16x8.shr_s
i16x8.shr_u
i16x8.add
i16x8.add_sat_s
i16x8.add_sat_u
i16x8.sub
i16x8.sub_sat_s
i16x8.sub_sat_u
i16x8.mul
i16x8.min_s
i16x8.min_u
i16x8.max_s
i16x8.max_u
i16x8.avgr_u
i16x8.extmul_low_i8x16_s
i16x8.extmul_high_i8x16_s
i16x8.extmul_low_i8x16_u
i16x8.extmul_high_i8x16_u

|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|

0xFD 126:u32
0xFD 127:u32
0xFD 160:u32
0xFD 161:u32
0xFD 163:u32
0xFD 164:u32
0xFD 167:u32
0xFD 168:u32
0xFD 169:u32
0xFD 170:u32
0xFD 171:u32
0xFD 172:u32
0xFD 173:u32
0xFD 174:u32
0xFD 177:u32
0xFD 181:u32
0xFD 182:u32
0xFD 183:u32
0xFD 184:u32
0xFD 185:u32
0xFD 186:u32
0xFD 188:u32
0xFD 189:u32
0xFD 190:u32
0xFD 191:u32

â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’

i32x4.extadd_pairwise_i16x8_s
i32x4.extadd_pairwise_i16x8_u
i32x4.abs
i32x4.neg
i32x4.all_true
i32x4.bitmask
i32x4.extend_low_i16x8_s
i32x4.extend_high_i16x8_s
i32x4.extend_low_i16x8_u
i32x4.extend_high_i16x8_u
i32x4.shl
i32x4.shr_s
i32x4.shr_u
i32x4.add
i32x4.sub
i32x4.mul
i32x4.min_s
i32x4.min_u
i32x4.max_s
i32x4.max_u
i32x4.dot_i16x8_s
i32x4.extmul_low_i16x8_s
i32x4.extmul_high_i16x8_s
i32x4.extmul_low_i16x8_u
i32x4.extmul_high_i16x8_u

Chapter 5. Binary Format

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

5.4. Instructions

|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|

0xFD 192:u32
0xFD 193:u32
0xFD 195:u32
0xFD 196:u32
0xFD 199:u32
0xFD 200:u32
0xFD 201:u32
0xFD 202:u32
0xFD 203:u32
0xFD 204:u32
0xFD 205:u32
0xFD 206:u32
0xFD 209:u32
0xFD 213:u32
0xFD 220:u32
0xFD 221:u32
0xFD 222:u32
0xFD 223:u32

â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’

i64x2.abs
i64x2.neg
i64x2.all_true
i64x2.bitmask
i64x2.extend_low_i32x4_s
i64x2.extend_high_i32x4_s
i64x2.extend_low_i32x4_u
i64x2.extend_high_i32x4_u
i64x2.shl
i64x2.shr_s
i64x2.shr_u
i64x2.add
i64x2.sub
i64x2.mul
i64x2.extmul_low_i32x4_s
i64x2.extmul_high_i32x4_s
i64x2.extmul_low_i32x4_u
i64x2.extmul_high_i32x4_u

|
|
|
|
|
|
|
|
|
|
|
|
|
|
|

0xFD 103:u32
0xFD 104:u32
0xFD 105:u32
0xFD 106:u32
0xFD 224:u32
0xFD 225:u32
0xFD 227:u32
0xFD 228:u32
0xFD 229:u32
0xFD 230:u32
0xFD 231:u32
0xFD 232:u32
0xFD 233:u32
0xFD 234:u32
0xFD 235:u32

â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’

f32x4.ceil
f32x4.floor
f32x4.trunc
f32x4.nearest
f32x4.abs
f32x4.neg
f32x4.sqrt
f32x4.add
f32x4.sub
f32x4.mul
f32x4.div
f32x4.min
f32x4.max
f32x4.pmin
f32x4.pmax

|
|
|
|
|
|
|
|
|
|
|
|
|
|
|

0xFD 116:u32
0xFD 117:u32
0xFD 122:u32
0xFD 148:u32
0xFD 236:u32
0xFD 237:u32
0xFD 239:u32
0xFD 240:u32
0xFD 241:u32
0xFD 242:u32
0xFD 243:u32
0xFD 244:u32
0xFD 245:u32
0xFD 246:u32
0xFD 247:u32

â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’

f64x2.ceil
f64x2.floor
f64x2.trunc
f64x2.nearest
f64x2.abs
f64x2.neg
f64x2.sqrt
f64x2.add
f64x2.sub
f64x2.mul
f64x2.div
f64x2.min
f64x2.max
f64x2.pmin
f64x2.pmax

199

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|

0xFD 248:u32
0xFD 249:u32
0xFD 250:u32
0xFD 251:u32
0xFD 252:u32
0xFD 253:u32
0xFD 254:u32
0xFD 255:u32
0xFD 94:u32
0xFD 95:u32
0xFD 256:u32
0xFD 257:u32
0xFD 258:u32
0xFD 259:u32
0xFD 260:u32
0xFD 261:u32
0xFD 262:u32
0xFD 263:u32
0xFD 264:u32
0xFD 265:u32
0xFD 266:u32
0xFD 267:u32
0xFD 268:u32
0xFD 269:u32
0xFD 270:u32
0xFD 271:u32
0xFD 272:u32
0xFD 273:u32
0xFD 274:u32
0xFD 275:u32

â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’

i32x4.trunc_sat_f32x4_s
i32x4.trunc_sat_f32x4_u
f32x4.convert_i32x4_s
f32x4.convert_i32x4_u
i32x4.trunc_sat_f64x2_s_zero
i32x4.trunc_sat_f64x2_u_zero
f64x2.convert_low_i32x4_s
f64x2.convert_low_i32x4_u
f32x4.demote_f64x2_zero
f64x2.promote_low_f32x4
i16x8.relaxed_swizzle
i32x4.relaxed_trunc_f32x4_s
i32x4.relaxed_trunc_f32x4_u
i32x4.relaxed_trunc_f32x4_s_zero
i32x4.relaxed_trunc_f32x4_u_zero
f32x4.relaxed_madd
f32x4.relaxed_nmadd
f64x2.relaxed_madd
f64x2.relaxed_nmadd
i8x16.relaxed_laneselect
i16x8.relaxed_laneselect
i32x4.relaxed_laneselect
i64x2.relaxed_laneselect
f32x4.relaxed_min
f32x4.relaxed_max
f64x2.relaxed_min
f64x2.relaxed_max
i16x8.relaxed_q15mulr_s
i16x8.relaxed_dot_i8x16_i7x16_s
i16x8.relaxed_dot_i8x16_i7x16_add_s

5.4.9 Expressions
Expressions are encoded by their instruction sequence terminated with an explicit 0x0B opcode for end.
expr ::=

(in:instr)* 0x0B â‡’ in * end

5.5 Modules
The binary encoding of modules is organized into sections. Most sections correspond to one component of a
module record, except that function definitions are split into two sections, separating their type declarations in the
function section from their bodies in the code section.
Ã² Note
This separation enables parallel and streaming compilation of the functions in a module.

200

Chapter 5. Binary Format

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

5.5.1 Indices
All indices are encoded with their respective value.
typeidx
funcidx
tableidx
memidx
globalidx
tagidx
elemidx
dataidx
localidx
labelidx
fieldidx

::=
::=
::=
::=
::=
::=
::=
::=
::=
::=
::=

â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’

ğ‘¥:u32
ğ‘¥:u32
ğ‘¥:u32
ğ‘¥:u32
ğ‘¥:u32
ğ‘¥:u32
ğ‘¥:u32
ğ‘¥:u32
ğ‘¥:u32
ğ‘™:u32
ğ‘¥:u32

ğ‘¥
ğ‘¥
ğ‘¥
ğ‘¥
ğ‘¥
ğ‘¥
ğ‘¥
ğ‘¥
ğ‘¥
ğ‘™
ğ‘¥

5.5.2 Sections
Each section consists of
â€¢ a one-byte section id,
â€¢ the u32 size of the contents, in bytes,
â€¢ the actual contents, whose structure is dependent on the section id.
Every section is optional; an omitted section is equivalent to the section being present with empty contents.
The following parameterized grammar rule defines the generic structure of a section with id ğ‘ and contents described by the grammar B.
sectionğ‘ (B)

::= ğ‘ :byte size:u32 cont:B
|
ğœ–

â‡’
â‡’

cont
ğœ–

(if size = ||B||)

For most sections, the contents B encodes a vector. In these cases, the empty result ğœ– is interpreted as the empty
vector.
Ã² Note
Other than for unknown custom sections, the size is not required for decoding, but can be used to skip sections
when navigating through a binary. The module is malformed if the size does not match the length of the binary
contents B.
The following section ids are used:

5.5. Modules

Id

Section

0
1
2
3
4
5
6
7
8
9
10
11
12
13

custom section
type section
import section
function section
table section
memory section
global section
export section
start section
element section
code section
data section
data count section
tag section
201

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

Ã² Note
Section ids do not always correspond to the order of sections in the encoding of a module.

5.5.3 Custom Section
Custom sections have the id 0. They are intended to be used for debugging information or third-party extensions,
and are ignored by the WebAssembly semantics. Their contents consist of a name further identifying the custom
section, followed by an uninterpreted sequence of bytes for custom use.
customsec
custom

::= section0 (custom)
::= name byte*

Ã² Note
If an implementation interprets the data of a custom section, then errors in that data, or the placement of the
section, must not invalidate the module.

5.5.4 Type Section
The type section has the id 1. It decodes into a vector of recursive types that represent the types component of a
module.
typesec

::= rt * : section1 (vec(rectype))

â‡’ rt *

5.5.5 Import Section
The import section has the id 2. It decodes into a vector of imports that represent the imports component of a
module.
importsec
::=
import
::=
importdesc ::=
|
|
|
|

im * :section2 (vec(import))
mod :name nm:name ğ‘‘:importdesc
0x00 ğ‘¥:typeidx
0x01 tt:tabletype
0x02 mt:memtype
0x03 gt:globaltype
0x04 ğ‘¥:tagtype

â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’

im *
{module mod , name nm, desc ğ‘‘}
func ğ‘¥
table tt
mem mt
global gt
tag ğ‘¥

5.5.6 Function Section
The function section has the id 3. It decodes into a vector of type indices that represent the type fields of the
functions in the funcs component of a module. The locals and body fields of the respective functions are encoded
separately in the code section.
funcsec ::=

ğ‘¥* :section3 (vec(typeidx)) â‡’

ğ‘¥*

5.5.7 Table Section
The table section has the id 4. It decodes into a vector of tables that represent the tables component of a module.
tablesec ::= tab * :section4 (vec(table))
â‡’ tab *
table
::= tt:tabletype
â‡’ {type tt, init (ref.null ht)}
|
0x40 0x00 tt:tabletype ğ‘’:expr â‡’ {type tt, init ğ‘’}
202

if tt = limits (ref null? ht)

Chapter 5. Binary Format

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

Ã² Note
The encoding of a table type cannot start with byte 0x40, hence decoding is unambiguous. The zero byte
following it is reserved for future extensions.

5.5.8 Memory Section
The memory section has the id 5. It decodes into a vector of memories that represent the mems component of a
module.
memsec ::= mem * :section5 (vec(mem)) â‡’
mem
::= mt:memtype
â‡’

mem *
{type mt}

5.5.9 Global Section
The global section has the id 6. It decodes into a vector of globals that represent the globals component of a module.
globalsec
global

::= glob * :section6 (vec(global))
::= gt:globaltype ğ‘’:expr

â‡’ glob *
â‡’ {type gt, init ğ‘’}

5.5.10 Export Section
The export section has the id 7. It decodes into a vector of exports that represent the exports component of a
module.
exportsec
::= ex * :section7 (vec(export))
export
::= nm:name ğ‘‘:exportdesc
exportdesc ::= 0x00 ğ‘¥:funcidx
|
0x01 ğ‘¥:tableidx
|
0x02 ğ‘¥:memidx
|
0x03 ğ‘¥:globalidx
|
0x04 ğ‘¥:tagidx

â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’

ex *
{name nm, desc ğ‘‘}
func ğ‘¥
table ğ‘¥
mem ğ‘¥
global ğ‘¥
tag ğ‘¥

5.5.11 Start Section
The start section has the id 8. It decodes into an optional start function that represents the start component of a
module.
startsec ::= st ? :section8 (start) â‡’ st ?
start
::= ğ‘¥:funcidx
â‡’ {func ğ‘¥}

5.5. Modules

203

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

5.5.12 Element Section
The element section has the id 9. It decodes into a vector of element segments that represent the elems component
of a module.
seg * :section9 (vec(elem))
0:u32 ğ‘’:expr ğ‘¦ * :vec(funcidx)
{type (ref func), init ((ref.func ğ‘¦) end)* , mode active {table 0, offset ğ‘’}}
|
1:u32 et : elemkind ğ‘¦ * :vec(funcidx)
{type et, init ((ref.func ğ‘¦) end)* , mode passive}
|
2:u32 ğ‘¥:tableidx ğ‘’:expr et : elemkind ğ‘¦ * :vec(funcidx)
{type et, init ((ref.func ğ‘¦) end)* , mode active {table ğ‘¥, offset ğ‘’}}
|
3:u32 et : elemkind ğ‘¦ * :vec(funcidx)
{type et, init ((ref.func ğ‘¦) end)* , mode declarative}
|
4:u32 ğ‘’:expr el * :vec(expr)
{type (ref null func), init el * , mode active {table 0, offset ğ‘’}}
|
5:u32 et : reftype el * :vec(expr)
{type ğ‘’ğ‘¡, init el * , mode passive}
|
6:u32 ğ‘¥:tableidx ğ‘’:expr et : reftype el * :vec(expr)
{type ğ‘’ğ‘¡, init el * , mode active {table ğ‘¥, offset ğ‘’}}
|
7:u32 et : reftype el * :vec(expr)
{type ğ‘’ğ‘¡, init el * , mode declarative}
elemkind ::= 0x00
elemsec
elem

::=
::=

â‡’ seg *
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’ (ref func)

Ã² Note
The initial integer can be interpreted as a bitfield. Bit 0 distinguishes a passive or declarative segment from
an active segment, bit 1 indicates the presence of an explicit table index for an active segment and otherwise
distinguishes passive from declarative segments, bit 2 indicates the use of element type and element expressions
instead of element kind and element indices.
Additional element kinds may be added in future versions of WebAssembly.

5.5.13 Code Section
The code section has the id 10. It decodes into a vector of code entries that are pairs of value type vectors and
expressions. They represent the locals and body field of the functions in the funcs component of a module. The
type fields of the respective functions are encoded separately in the function section.
The encoding of each code entry consists of
â€¢ the u32 size of the function code in bytes,
â€¢ the actual function code, which in turn consists of
â€“ the declaration of locals,
â€“ the function body as an expression.
Local declarations are compressed into a vector whose entries consist of
â€¢ a u32 count,
â€¢ a value type,
denoting count locals of the same value type.
codesec
code
func
locals

204

::=
::=
::=
::=

code * :section10 (vec(code))
size:u32 code:func
(local * )* :vec(locals) ğ‘’:expr
ğ‘›:u32 ğ‘¡:valtype

â‡’ code *
â‡’ code
â‡’ concat((local * )* ), ğ‘’
â‡’ {type ğ‘¡}ğ‘›

(if size = ||func||)
(if |concat((local * )* )| < 232 )

Chapter 5. Binary Format

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

Here, code ranges over pairs (valtype * , expr ). The meta function concat((local * )* ) concatenates all sequences
local *ğ‘– in (local * )* . Any code for which the length of the resulting sequence is out of bounds of the maximum size
of a vector is malformed.
Ã² Note
Like with sections, the code size is not needed for decoding, but can be used to skip functions when navigating
through a binary. The module is malformed if a size does not match the length of the respective function code.

5.5.14 Data Section
The data section has the id 11. It decodes into a vector of data segments that represent the datas component of a
module.
datasec ::= seg * :section11 (vec(data))
data
::= 0:u32 ğ‘’:expr ğ‘* :vec(byte)
|
1:u32 ğ‘* :vec(byte)
|
2:u32 ğ‘¥:memidx ğ‘’:expr ğ‘* :vec(byte)

â‡’
â‡’
â‡’
â‡’

seg *
{init ğ‘* , mode active {memory 0, offset ğ‘’}}
{init ğ‘* , mode passive}
{init ğ‘* , mode active {memory ğ‘¥, offset ğ‘’}}

Ã² Note
The initial integer can be interpreted as a bitfield. Bit 0 indicates a passive segment, bit 1 indicates the presence
of an explicit memory index for an active segment.
In the current version of WebAssembly, at most one memory may be defined or imported in a single module,
so all valid active data segments have a memory value of 0.

5.5.15 Data Count Section
The data count section has the id 12. It decodes into an optional u32 that represents the number of data segments
in the data section. If this count does not match the length of the data segment vector, the module is malformed.
datacountsec

::= n ? :section12 (u32) â‡’

n?

Ã² Note
The data count section is used to simplify single-pass validation. Since the data section occurs after the code
section, the memory.init and data.drop instructions would not be able to check whether the data segment index
is valid until the data section is read. The data count section occurs before the code section, so a single-pass
validator can use this count instead of deferring validation.

5.5.16 Tag Section
The tag section has the id 13. It decodes into a vector of tags that represent the tags component of a module.
tagsec
tag

::= tag * :section13 (vec(tag))
::= 0x00 x :typeidx

â‡’ tag *
â‡’ {type x }

5.5.17 Modules
The encoding of a module starts with a preamble containing a 4-byte magic number (the string â€˜âˆ–0asmâ€™) and a
version field. The current version of the WebAssembly binary format is 1.

5.5. Modules

205

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

The preamble is followed by a sequence of sections. Custom sections may be inserted at any place in this sequence,
while other sections must occur at most once and in the prescribed order. All sections can be empty.
The lengths of vectors produced by the (possibly empty) function and code section must match up.
Similarly, the optional data count must match the length of the data segment vector. Furthermore, it must be present
if any data index occurs in the code section.
magic
::=
version ::=
module
::=

0x00 0x61 0x73 0x6D
0x01 0x00 0x00 0x00
magic
version
customsec*
rectype * : typesec
customsec*
import * : importsec
customsec*
typeidx ğ‘› : funcsec
customsec*
table * : tablesec
customsec*
mem * : memsec
customsec*
tag * : tagsec
customsec*
global * : globalsec
customsec*
export * : exportsec
customsec*
start ? : startsec
customsec*
elem * : elemsec
customsec*
ğ‘š? : datacountsec
customsec*
code ğ‘› : codesec
customsec*
data ğ‘š : datasec
customsec* â‡’ { types rectype * ,
funcs func ğ‘› ,
tables table * ,
mems mem * ,
globals global * ,
tags tag * ,
elems elem * ,
datas data ğ‘š ,
start start ? ,
imports import * ,
exports export * }
?
(if ğ‘š Ì¸= ğœ– âˆ¨ dataidx(code ğ‘› ) = âˆ…)

where for each ğ‘¡*ğ‘– , ğ‘’ğ‘– in code ğ‘› ,
func ğ‘› [ğ‘–] = {type typeidx ğ‘› [ğ‘–], locals ğ‘¡*ğ‘– , body ğ‘’ğ‘– }

Ã² Note
The version of the WebAssembly binary format may increase in the future if backward-incompatible changes
have to be made to the format. However, such changes are expected to occur very infrequently, if ever. The

206

Chapter 5. Binary Format

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

binary format is intended to be extensible, such that future features can be added without incrementing its
version.

5.5. Modules

207

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

208

Chapter 5. Binary Format

CHAPTER

6

Text Format

6.1 Conventions
The textual format for WebAssembly modules is a rendering of their abstract syntax into S-expressions37 .
Like the binary format, the text format is defined by an attribute grammar. A text string is a well-formed description
of a module if and only if it is generated by the grammar. Each production of this grammar has at most one
synthesized attribute: the abstract syntax that the respective character sequence expresses. Thus, the attribute
grammar implicitly defines a parsing function. Some productions also take a context as an inherited attribute that
records bound identifiers.
Except for a few exceptions, the core of the text grammar closely mirrors the grammar of the abstract syntax.
However, it also defines a number of abbreviations that are â€œsyntactic sugarâ€ over the core syntax.
The recommended extension for files containing WebAssembly modules in text format is â€œ.watâ€. Files with this
extension are assumed to be encoded in UTF-8, as per Unicode38 (Section 2.5).

6.1.1 Grammar
The following conventions are adopted in defining grammar rules of the text format. They mirror the conventions
used for abstract syntax and for the binary format. In order to distinguish symbols of the textual syntax from
symbols of the abstract syntax, typewriter font is adopted for the former.
â€¢ Terminal symbols are either literal strings of characters enclosed in quotes or expressed as Unicode39 scalar
values: â€˜moduleâ€™, U+0A. (All characters written literally are unambiguously drawn from the 7-bit ASCII40
subset of Unicode.)
â€¢ Nonterminal symbols are written in typewriter font: valtype, instr.
â€¢ ğ‘‡ ğ‘› is a sequence of ğ‘› â‰¥ 0 iterations of ğ‘‡ .
â€¢ ğ‘‡ * is a possibly empty sequence of iterations of ğ‘‡ . (This is a shorthand for ğ‘‡ ğ‘› used where ğ‘› is not relevant.)
â€¢ ğ‘‡ + is a sequence of one or more iterations of ğ‘‡ . (This is a shorthand for ğ‘‡ ğ‘› where ğ‘› â‰¥ 1.)
â€¢ ğ‘‡ ? is an optional occurrence of ğ‘‡ . (This is a shorthand for ğ‘‡ ğ‘› where ğ‘› â‰¤ 1.)
37 https://en.wikipedia.org/wiki/S-expression
38 https://www.unicode.org/versions/latest/
39 https://www.unicode.org/versions/latest/

40 https://webstore.ansi.org/RecordDetail.aspx?sku=INCITS+4-1986%5bR2012%5d

209

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

â€¢ ğ‘¥:ğ‘‡ denotes the same language as the nonterminal ğ‘‡ , but also binds the variable ğ‘¥ to the attribute synthesized
for ğ‘‡ . A pattern may also be used instead of a variable, e.g., (ğ‘¥, ğ‘¦):ğ‘‡ .
â€¢ Productions are written sym ::= ğ‘‡1 â‡’ ğ´1 | . . . | ğ‘‡ğ‘› â‡’ ğ´ğ‘› , where each ğ´ğ‘– is the attribute that is synthesized
for sym in the given case, usually from attribute variables bound in ğ‘‡ğ‘– .
â€¢ Large productions may be split into multiple definitions, indicated by ending the first one with explicit ellipses, sym ::= ğ‘‡1 â‡’ ğ´1 | . . ., and starting continuations with ellipses, sym ::= . . . | ğ‘‡2 â‡’ ğ´2 .
â€¢ Some productions are augmented by side conditions in parentheses, which restrict the applicability of the
production. They provide a shorthand for a combinatorial expansion of the production into many separate
cases.
â€¢ If the same meta variable or non-terminal symbol appears multiple times in a production (in the syntax or in
an attribute), then all those occurrences must have the same instantiation.
â€¢ A distinction is made between lexical and syntactic productions. For the latter, arbitrary white space is
allowed in any place where the grammar contains spaces. The productions defining lexical syntax and the
syntax of values are considered lexical, all others are syntactic.
Ã² Note
For example, the textual grammar for number types is given as follows:
numtype ::=
|
|
|

â€˜i32â€™
â€˜i64â€™
â€˜f32â€™
â€˜f64â€™

â‡’
â‡’
â‡’
â‡’

i32
i64
f32
f64

The textual grammar for limits is defined as follows:
limits

::= ğ‘›:u32
|
ğ‘›:u32 ğ‘š:u32

â‡’ {min ğ‘›, max ğœ–}
â‡’ {min ğ‘›, max ğ‘š}

The variables ğ‘› and ğ‘š name the attributes of the respective u32 nonterminals, which in this case are the actual
unsigned integers those parse into. The attribute of the complete production then is the abstract syntax for the
limit, expressed in terms of the former values.

6.1.2 Abbreviations
In addition to the core grammar, which corresponds directly to the abstract syntax, the textual syntax also defines
a number of abbreviations that can be used for convenience and readability.
Abbreviations are defined by rewrite rules specifying their expansion into the core syntax:
abbreviation syntax

â‰¡

expanded syntax

These expansions are assumed to be applied, recursively and in order of appearance, before applying the core
grammar rules to construct the abstract syntax.

6.1.3 Contexts
The text format allows the use of symbolic identifiers in place of indices. To resolve these identifiers into concrete
indices, some grammar productions are indexed by an identifier context ğ¼ as a synthesized attribute that records
the declared identifiers in each index space. In addition, the context records the types defined in the module, so
that parameter indices can be computed for functions.

210

Chapter 6. Text Format

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

It is convenient to define identifier contexts as records ğ¼ with abstract syntax as follows:
ğ¼

::=

{ types
funcs
tables
mems
globals
tags
elem
data
locals
labels
fields
typedefs

(name ? )* ,
(name ? )* ,
(name ? )* ,
(name ? )* ,
(name ? )* ,
(name? )* ,
(name ? )* ,
(name ? )* ,
(name ? )* ,
(name ? )* ,
((name ? )* )* }
subtype * }

For each index space, such a context contains the list of names assigned to the defined indices, which were denoted
by the corresponding identifiers. Unnamed indices are associated with empty (ğœ–) entries in these lists. Fields have
dependent name spaces, and hence a separate list of field identifiers per type.
An identifier context is well-formed if no index space contains duplicate identifiers. For fields, names need only
be unique within a single type.
Conventions
To avoid unnecessary clutter, empty components are omitted when writing out identifier contexts. For example,
the record {} is shorthand for an identifier context whose components are all empty.

6.1.4 Vectors
Vectors are written as plain sequences, but with a restriction on the length of these sequence.
vec(A)

::=

(ğ‘¥:A)ğ‘›

â‡’ ğ‘¥ğ‘›

(if ğ‘› < 232 )

6.2 Lexical Format
6.2.1 Characters
The text format assigns meaning to source text, which consists of a sequence of characters. Characters are assumed
to be represented as valid Unicode41 (Section 2.4) scalar values.
source ::= char*
char
::= U+00 | . . . | U+D7FF | U+E000 | . . . | U+10FFFF

Ã² Note
While source text may contain any Unicode character in comments or string literals, the rest of the grammar is
formed exclusively from the characters supported by the 7-bit ASCII42 subset of Unicode.

6.2.2 Tokens
The character stream in the source text is divided, from left to right, into a sequence of tokens, as defined by the
following grammar.
token
::= keyword | uğ‘ | sğ‘ | fğ‘ | string | id | â€˜(â€™ | â€˜)â€™ | reserved
keyword
::= (â€˜aâ€™ | . . . | â€˜zâ€™) idchar*
(if occurring as a literal terminal in the grammar)
reserved ::= (idchar | string | â€˜,â€™ | â€˜;â€™ | â€˜[â€™ | â€˜]â€™ | â€˜{â€™ | â€˜}â€™)+
41 https://www.unicode.org/versions/latest/

42 https://webstore.ansi.org/RecordDetail.aspx?sku=INCITS+4-1986%5bR2012%5d

6.2. Lexical Format

211

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

Tokens are formed from the input character stream according to the longest match rule. That is, the next token
always consists of the longest possible sequence of characters that is recognized by the above lexical grammar.
Tokens can be separated by white space, but except for strings, they cannot themselves contain whitespace.
Keyword tokens are defined either implicitly by an occurrence of a terminal symbol in literal form, such as
â€˜keywordâ€™, in a syntactic production of this chapter, or explicitly where they arise in this chapter.
Any token that does not fall into any of the other categories is considered reserved, and cannot occur in source text.
Ã² Note
The effect of defining the set of reserved tokens is that all tokens must be separated by either parentheses, white
space, or comments. For example, â€˜0$xâ€™ is a single reserved token, as is â€˜â€aâ€â€bâ€â€™. Consequently, they are
not recognized as two separate tokens â€˜0â€™ and â€˜$xâ€™, or â€ğ‘â€ and â€ğ‘â€, respectively, but instead disallowed. This
property of tokenization is not affected by the fact that the definition of reserved tokens overlaps with other
token classes.

6.2.3 White Space
White space is any sequence of literal space characters, formatting characters, comments, or annotations. The
allowed formatting characters correspond to a subset of the ASCII43 format effectors, namely, horizontal tabulation
(U+09), line feed (U+0A), and carriage return (U+0D).
space
::= (â€˜ â€™ | format | comment)*
format
::= newline | U+09
newline ::= U+0A | U+0D | U+0D U+0A
The only relevance of white space is to separate tokens. It is otherwise ignored.

6.2.4 Comments
A comment can either be a line comment, started with a double semicolon â€˜;;â€™ and extending to the end of the line,
or a block comment, enclosed in delimiters â€˜(;â€™ . . . â€˜;)â€™. Block comments can be nested.
comment
linecomment
linechar
blockcomment
blockchar

::=
::=
::=
::=
::=
|
|
|

linecomment | blockcomment
â€˜;;â€™ linechar* (newline | eof)
ğ‘:char
â€˜(;â€™ blockchar* â€˜;)â€™
ğ‘:char
â€˜;â€™
â€˜(â€™
blockcomment

(if ğ‘ Ì¸= U+0A âˆ§ ğ‘ Ì¸= U+0D)
(if ğ‘ Ì¸= â€˜;â€™ âˆ§ ğ‘ Ì¸= â€˜(â€™)
(if the next character is not â€˜)â€™)
(if the next character is not â€˜;â€™)

Here, the pseudo token eof indicates the end of the input. The look-ahead restrictions on the productions for
blockchar disambiguate the grammar such that only well-bracketed uses of block comment delimiters are allowed.
Ã² Note
Any formatting and control characters are allowed inside comments.

6.2.5 Annotations
An annotation is a bracketed token sequence headed by an annotation id of the form â€˜@idâ€™ or â€˜@â€...â€â€™. No space is
allowed between the opening parenthesis and this id. Annotations are intended to be used for third-party extensions;
they can appear anywhere in a program but are ignored by the WebAssembly semantics itself, which treats them
as white space.
43 https://webstore.ansi.org/RecordDetail.aspx?sku=INCITS+4-1986%5bR2012%5d

212

Chapter 6. Text Format

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

Annotations can contain other parenthesized token sequences (including nested annotations), as long as they are
well-nested. String literals and comments occurring in an annotation must also be properly nested and closed.
annot
::= â€˜(@â€™ annotid (space | token)* â€˜)â€™
annotid ::= idchar+ | name

Ã² Note
The annotation id is meant to be an identifier categorising the extension, and plays a role similar to the name
of a custom section. By convention, annotations corresponding to a custom section should use the custom
sectionâ€™s name as an id.
Implementations are expected to ignore annotations with ids that they do not recognize. On the other hand,
they may impose restrictions on annotations that they do recognize, e.g., requiring a specific structure by superimposing a more concrete grammar. It is up to an implementation how it deals with errors in such annotations.

6.3 Values
The grammar productions in this section define lexical syntax, hence no white space is allowed.

6.3.1 Integers
All integers can be written in either decimal or hexadecimal notation. In both cases, digits can optionally be
separated by underscores.
sign
digit
hexdigit

::=
::=
::=
|
|

ğœ– â‡’ + | â€˜+â€™ â‡’ + | â€˜âˆ’â€™ â‡’ âˆ’
â€˜0â€™ â‡’ 0 | . . . | â€˜9â€™ â‡’ 9
ğ‘‘:digit â‡’ ğ‘‘
â€˜Aâ€™ â‡’ 10 | . . . | â€˜Fâ€™ â‡’ 15
â€˜aâ€™ â‡’ 10 | . . . | â€˜fâ€™ â‡’ 15

num

::=
|
::=
|

ğ‘‘:digit
ğ‘›:num â€˜_â€™? ğ‘‘:digit
â„:hexdigit
ğ‘›:hexnum â€˜_â€™? â„:hexdigit

hexnum

â‡’
â‡’
â‡’
â‡’

ğ‘‘
10 Â· ğ‘› + ğ‘‘
â„
16 Â· ğ‘› + â„

The allowed syntax for integer literals depends on size and signedness. Moreover, their value must lie within the
range of the respective type.
uğ‘
sğ‘

â‡’ ğ‘›
â‡’ ğ‘›
â‡’ Â±ğ‘›
â‡’ Â±ğ‘›

::= ğ‘›:num
|
â€˜0xâ€™ ğ‘›:hexnum
::= Â±:sign ğ‘›:num
|
Â±:sign â€˜0xâ€™ ğ‘›:hexnum

(if ğ‘› < 2ğ‘ )
(if ğ‘› < 2ğ‘ )
(if âˆ’2ğ‘ âˆ’1 â‰¤ Â±ğ‘› < 2ğ‘ âˆ’1 )
(if âˆ’2ğ‘ âˆ’1 â‰¤ Â±ğ‘› < 2ğ‘ âˆ’1 )

Uninterpreted integers can be written as either signed or unsigned, and are normalized to unsigned in the abstract
syntax.
iğ‘

6.3. Values

::= ğ‘›:uğ‘
|
ğ‘–:sğ‘

â‡’
â‡’

ğ‘›
ğ‘›

(if ğ‘– = signed(ğ‘›))

213

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

6.3.2 Floating-Point
Floating-point values can be represented in either decimal or hexadecimal notation.
::=
|
hexfrac
::=
|
float
::=
|
|
|
hexfloat ::=
|
|
|
frac

ğ‘‘:digit
ğ‘‘:digit â€˜_â€™? ğ‘:frac
â„:hexdigit
â„:hexdigit â€˜_â€™? ğ‘:hexfrac
ğ‘:num â€˜.â€™?
ğ‘:num â€˜.â€™ ğ‘:frac
ğ‘:num â€˜.â€™? (â€˜Eâ€™ | â€˜eâ€™) Â±:sign ğ‘’:num
ğ‘:num â€˜.â€™ ğ‘:frac (â€˜Eâ€™ | â€˜eâ€™) Â±:sign ğ‘’:num
â€˜0xâ€™ ğ‘:hexnum â€˜.â€™?
â€˜0xâ€™ ğ‘:hexnum â€˜.â€™ ğ‘:hexfrac
â€˜0xâ€™ ğ‘:hexnum â€˜.â€™? (â€˜Pâ€™ | â€˜pâ€™) Â±:sign ğ‘’:num
â€˜0xâ€™ ğ‘:hexnum â€˜.â€™ ğ‘:hexfrac (â€˜Pâ€™ | â€˜pâ€™) Â±:sign ğ‘’:num

â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’

ğ‘‘/10
(ğ‘‘ + ğ‘/10)/10
â„/16
(â„ + ğ‘/16)/16
ğ‘
ğ‘+ğ‘
ğ‘ Â· 10Â±ğ‘’
(ğ‘ + ğ‘) Â· 10Â±ğ‘’
ğ‘
ğ‘+ğ‘
ğ‘ Â· 2Â±ğ‘’
(ğ‘ + ğ‘) Â· 2Â±ğ‘’

The value of a literal must not lie outside the representable range of the corresponding IEEE 75444 type (that is, a
numeric value must not overflow to Â±infinity), but it may be rounded to the nearest representable value.
Ã² Note
Rounding can be prevented by using hexadecimal notation with no more significant bits than supported by the
required type.
Floating-point values may also be written as constants for infinity or canonical NaN (not a number). Furthermore,
arbitrary NaN values may be expressed by providing an explicit payload value.
fğ‘
fğ‘ mag

::=
::=
|
|
|
|

Â±:sign ğ‘§:fğ‘ mag
ğ‘§:float
ğ‘§:hexfloat
â€˜infâ€™
â€˜nanâ€™
â€˜nan:0xâ€™ ğ‘›:hexnum

â‡’
â‡’
â‡’
â‡’
â‡’
â‡’

Â±ğ‘§
floatğ‘ (ğ‘§)
floatğ‘ (ğ‘§)
âˆ
nan(canonğ‘ )
nan(ğ‘›)

(if floatğ‘ (ğ‘§) Ì¸= Â±âˆ)
(if floatğ‘ (ğ‘§) Ì¸= Â±âˆ)

(if 1 â‰¤ ğ‘› < 2signif(ğ‘ ) )

6.3.3 Strings
Strings denote sequences of bytes that can represent both textual and binary data. They are enclosed in quotation
marks and may contain any character other than ASCII45 control characters, quotation marks (â€˜â€â€™), or backslash
(â€˜âˆ–â€™), except when expressed with an escape sequence.
string
::= â€˜â€â€™ (ğ‘* :stringelem)* â€˜â€â€™
â‡’
stringelem ::= ğ‘:stringchar
â‡’
|
â€˜âˆ–â€™ ğ‘›:hexdigit ğ‘š:hexdigit â‡’

concat((ğ‘* )* )
utf8(ğ‘)
16 Â· ğ‘› + ğ‘š

(if |concat((ğ‘* )* )| < 232 )

Each character in a string literal represents the byte sequence corresponding to its UTF-8 Unicode46 (Section 2.5)
encoding, except for hexadecimal escape sequences â€˜âˆ–â„â„â€™, which represent raw bytes of the respective value.
stringchar ::=
|
|
|
|
|
|
|

ğ‘:char
â€˜âˆ–tâ€™
â€˜âˆ–nâ€™
â€˜âˆ–râ€™
â€˜âˆ–â€â€™
â€˜âˆ–â€² â€™
â€˜âˆ–âˆ–â€™
â€˜âˆ–u{â€™ ğ‘›:hexnum â€˜}â€™

â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’

ğ‘
U+09
U+0A
U+0D
U+22
U+27
U+5C
U+(n)

(if ğ‘ â‰¥ U+20 âˆ§ ğ‘ Ì¸= U+7F âˆ§ ğ‘ Ì¸= â€˜â€â€™ âˆ§ ğ‘ Ì¸= â€˜âˆ–â€™)

(if ğ‘› < 0xD800 âˆ¨ 0xE000 â‰¤ ğ‘› < 0x110000)

44 https://ieeexplore.ieee.org/document/8766229

45 https://webstore.ansi.org/RecordDetail.aspx?sku=INCITS+4-1986%5bR2012%5d
46 https://www.unicode.org/versions/latest/

214

Chapter 6. Text Format

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

6.3.4 Names
Names are strings denoting a literal character sequence. A name string must form a valid UTF-8 encoding as
defined by Unicode47 (Section 2.5) and is interpreted as a string of Unicode scalar values.
name ::= ğ‘* :string

â‡’ ğ‘*

(if ğ‘* = utf8(ğ‘* ))

Ã² Note
Presuming the source text is itself encoded correctly, strings that do not contain any uses of hexadecimal byte
escapes are always valid names.

6.3.5 Identifiers
Indices can be given in both numeric and symbolic form. Symbolic identifiers that stand in lieu of indices start with
â€˜$â€™, followed by eiter a sequence of printable ASCII48 characters that does not contain a space, quotation mark,
comma, semicolon, or bracket, or by a quoted name.
id
idchar

::=
|
::=
|
|
|
|

â€˜$â€™ ğ‘* :idchar+
â‡’ ğ‘*
*
â€˜$â€™ ğ‘ :name
â‡’ ğ‘*
â€˜0â€™ | . . . | â€˜9â€™
â€˜Aâ€™ | . . . | â€˜Zâ€™
â€˜aâ€™ | . . . | â€˜zâ€™
â€˜!â€™ | â€˜#â€™ | â€˜$â€™ | â€˜%â€™ | â€˜&â€™ | â€˜â€² â€™ | â€˜*â€™ | â€˜+â€™ | â€˜âˆ’â€™ | â€˜.â€™ | â€˜/â€™
â€˜:â€™ | â€˜<â€™ | â€˜=â€™ | â€˜>â€™ | â€˜?â€™ | â€˜@â€™ | â€˜âˆ–â€™ | â€˜^â€™ | â€˜_â€™ | â€˜`â€™ | â€˜|â€™ | â€˜~â€™

(if |ğ‘* | > 0)

Ã² Note
The value of an identifier character is the Unicode codepoint denoting it.
Conventions
The expansion rules of some abbreviations require insertion of a fresh identifier. That may be any syntactically
valid identifier that does not already occur in the given source text.

6.4 Types
6.4.1 Number Types
â€˜i32â€™
â€˜i64â€™
â€˜f32â€™
â€˜f64â€™

numtypeğ¼

::=
|
|
|

â‡’
â‡’
â‡’
â‡’

i32
i64
f32
f64

vectypeğ¼

::= â€˜v128â€™ â‡’

v128

6.4.2 Vector Types

47 https://www.unicode.org/versions/latest/

48 https://webstore.ansi.org/RecordDetail.aspx?sku=INCITS+4-1986%5bR2012%5d

6.4. Types

215

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

6.4.3 Heap Types
absheaptype ::=
|
|
|
|
|
|
|
|
|
|
|
heaptypeğ¼
::=
|

â€˜anyâ€™
â€˜eqâ€™
â€˜i31â€™
â€˜structâ€™
â€˜arrayâ€™
â€˜noneâ€™
â€˜funcâ€™
â€˜nofuncâ€™
â€˜externâ€™
â€˜noexnâ€™
â€˜exnâ€™
â€˜noexternâ€™
ğ‘¡:absheaptype
ğ‘¥:typeidxğ¼

â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’

any
eq
i31
struct
array
none
func
nofunc
extern
noexn
exn
noextern
ğ‘¦
ğ‘¥

6.4.4 Reference Types
reftypeğ¼

::= â€˜(â€™ â€˜refâ€™ ht:heaptype â€˜)â€™
â‡’
|
â€˜(â€™ â€˜refâ€™ â€˜nullâ€™ ht:heaptype â€˜)â€™ â‡’

ref ht
ref null ht

Abbreviations
There are shorthands for references to abstract heap types.
â€˜anyrefâ€™
â€˜eqrefâ€™
â‰¡
â€˜i31refâ€™
â‰¡
â€˜structrefâ€™
â‰¡
â€˜arrayrefâ€™
â‰¡
â€˜nullrefâ€™
â‰¡
â€˜funcrefâ€™
â‰¡
â€˜nullfuncrefâ€™
â‰¡
â€˜exnrefâ€™
â‰¡
â€˜nullexnrefâ€™
â‰¡
â€˜externrefâ€™
â‰¡
â€˜nullexternrefâ€™ â‰¡

â‰¡
â€˜(â€™ â€˜refâ€™ â€˜nullâ€™ â€˜anyâ€™ â€˜)â€™
â€˜(â€™ â€˜refâ€™ â€˜nullâ€™ â€˜eqâ€™ â€˜)â€™
â€˜(â€™ â€˜refâ€™ â€˜nullâ€™ â€˜i31â€™ â€˜)â€™
â€˜(â€™ â€˜refâ€™ â€˜nullâ€™ â€˜structâ€™ â€˜)â€™
â€˜(â€™ â€˜refâ€™ â€˜nullâ€™ â€˜arrayâ€™ â€˜)â€™
â€˜(â€™ â€˜refâ€™ â€˜nullâ€™ â€˜noneâ€™ â€˜)â€™
â€˜(â€™ â€˜refâ€™ â€˜nullâ€™ â€˜funcâ€™ â€˜)â€™
â€˜(â€™ â€˜refâ€™ â€˜nullâ€™ â€˜nofuncâ€™ â€˜)â€™
â€˜(â€™ â€˜refâ€™ â€˜nullâ€™ â€˜exnâ€™ â€˜)â€™
â€˜(â€™ â€˜refâ€™ â€˜nullâ€™ â€˜noexnâ€™ â€˜)â€™
â€˜(â€™ â€˜refâ€™ â€˜nullâ€™ â€˜externâ€™ â€˜)â€™
â€˜(â€™ â€˜refâ€™ â€˜nullâ€™ â€˜noexternâ€™ â€˜)â€™

6.4.5 Value Types
valtypeğ¼

::= ğ‘¡:numtypeğ¼
|
ğ‘¡:vectypeğ¼
|
ğ‘¡:reftypeğ¼

â‡’
â‡’
â‡’

ğ‘¡
ğ‘¡
ğ‘¡

6.4.6 Function Types
functypeğ¼
paramğ¼
resultğ¼

::= â€˜(â€™ â€˜funcâ€™ ğ‘¡*1 : vec(paramğ¼ ) ğ‘¡*2 : vec(resultğ¼ ) â€˜)â€™ â‡’ [ğ‘¡*1 ] â†’ [ğ‘¡*2 ]
::= â€˜(â€™ â€˜paramâ€™ id? ğ‘¡:valtypeğ¼ â€˜)â€™
â‡’ ğ‘¡
::= â€˜(â€™ â€˜resultâ€™ ğ‘¡:valtypeğ¼ â€˜)â€™
â‡’ ğ‘¡

Ã² Note
The optional identifier names for parameters in a function type only have documentation purpose. They cannot
be referenced from anywhere.

216

Chapter 6. Text Format

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

Abbreviations
Multiple anonymous parameters or results may be combined into a single declaration:
â€˜(â€™ â€˜paramâ€™ valtype* â€˜)â€™
â‰¡
â€˜(â€™ â€˜resultâ€™ valtype* â€˜)â€™ â‰¡

(â€˜(â€™ â€˜paramâ€™ valtype â€˜)â€™)*
(â€˜(â€™ â€˜resultâ€™ valtype â€˜)â€™)*

6.4.7 Aggregate Types
arraytypeğ¼
structtypeğ¼
fieldğ¼
fieldtypeğ¼
storagetypeğ¼
packedtype

â€˜(â€™ â€˜arrayâ€™ ft:fieldtypeğ¼ â€˜)â€™
â€˜(â€™ â€˜structâ€™ ft * : vec(fieldğ¼ ) â€˜)â€™
â€˜(â€™ â€˜fieldâ€™ id? ft:fieldtypeğ¼ â€˜)â€™
st:storagetype
â€˜(â€™ â€˜mutâ€™ st:storagetype â€˜)â€™
ğ‘¡:valtypeğ¼
ğ‘¡:packedtype
â€˜i8â€™
â€˜i16â€™

::=
::=
::=
::=
|
::=
|
::=
|

â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’

ft
ft *
ft
const st
var st
ğ‘¡
ğ‘¡
i8
i16

Abbreviations
Multiple anonymous structure fields may be combined into a single declaration:
â€˜(â€™ â€˜fieldâ€™ fieldtype* â€˜)â€™ â‰¡

(â€˜(â€™ â€˜fieldâ€™ fieldtype â€˜)â€™)*

6.4.8 Composite Types
comptypeğ¼

::= at:arraytypeğ¼
|
st:structtypeğ¼
|
ft:functypeğ¼

â‡’ array at
â‡’ struct at
â‡’ func ft

6.4.9 Recursive Types
rectypeğ¼
typedefğ¼
subtypeğ¼

::= â€˜(â€™ â€˜recâ€™ st * : vec(typedefğ¼ ) â€˜)â€™
â‡’ rec st *
?
::= â€˜(â€™ â€˜typeâ€™ id st:subtypeğ¼ â€˜)â€™
â‡’ st
::= â€˜(â€™ â€˜subâ€™ â€˜finalâ€™? ğ‘¥* : vec(typeidxğ¼ ) ct:comptypeğ¼ â€˜)â€™ â‡’ sub final? ğ‘¥* ct

Abbreviations
Singular recursive types can omit the â€˜recâ€™ keyword:
typedef â‰¡

â€˜(â€™ â€˜recâ€™ typedef â€˜)â€™

Similarly, final sub types with no super-types can omit the sub keyword and arguments:
comptype

â‰¡ â€˜(â€™ â€˜subâ€™ â€˜finalâ€™ ğœ– comptype â€˜)â€™

6.4.10 Address Types
addrtype ::=
|

6.4. Types

â€˜i32â€™ â‡’
â€˜i64â€™ â‡’

i32
i64

217

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

Abbreviations
The address type can be omitted, in which case it defaults i32:
â€˜â€™

â‰¡

â€˜i32â€™

6.4.11 Limits
limits

::= ğ‘›:u64
|
ğ‘›:u64 ğ‘š:u64

â‡’ {min ğ‘›, max ğœ–}
â‡’ {min ğ‘›, max ğ‘š}

6.4.12 Memory Types
memtypeğ¼

::= at:addrtype lim:limits â‡’

at lim

6.4.13 Table Types
tabletypeğ¼

::= at:addrtype lim:limits et:reftypeğ¼

â‡’ at lim et

6.4.14 Global Types
globaltypeğ¼

::= ğ‘¡:valtype
â‡’ const ğ‘¡
|
â€˜(â€™ â€˜mutâ€™ ğ‘¡:valtypeğ¼ â€˜)â€™ â‡’ var ğ‘¡

6.5 Instructions
Instructions are syntactically distinguished into plain and structured instructions.
instrğ¼

::= in:plaininstrğ¼
|
in:blockinstrğ¼

â‡’
â‡’

in
in

In addition, as a syntactic abbreviation, instructions can be written as S-expressions in folded form, to group them
visually.

6.5.1 Labels
Structured control instructions can be annotated with a symbolic label identifier. They are the only symbolic
identifiers that can be bound locally in an instruction sequence. The following grammar handles the corresponding
update to the identifier context by composing the context with an additional label entry.
labelğ¼

::= ğ‘£:id
|
ğ‘£:id
|
ğœ–

â‡’ ğ‘£, {labels ğ‘£} âŠ• ğ¼
(if ğ‘£ âˆˆ
/ ğ¼.labels)
â‡’ ğ‘£, {labels ğ‘£} âŠ• (ğ¼ with labels[ğ‘–] = ğœ–) (if ğ¼.labels[ğ‘–] = ğ‘£)
â‡’ ğœ–, {labels (ğœ–)} âŠ• ğ¼

Ã² Note
The new label entry is inserted at the beginning of the label list in the identifier context. This effectively shifts
all existing labels up by one, mirroring the fact that control instructions are indexed relatively not absolutely.
If a label with the same name already exists, then it is shadowed and the earlier label becomes inaccessible.

218

Chapter 6. Text Format

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

6.5.2 Control Instructions
Structured control instructions can bind an optional symbolic label identifier. The same label identifier may optionally be repeated after the corresponding end or else keywords, to indicate the matching delimiters.
Their block type is given as a type use, analogous to the type of functions. However, the special case of a type use
that is syntactically empty or consists of only a single result is not regarded as an abbreviation for an inline function
type, but is parsed directly into an optional value type.
blocktypeğ¼
blockinstrğ¼

catchğ¼

::= (ğ‘¡:resultğ¼ )?
â‡’ ğ‘¡?
â€²
|
ğ‘¥, ğ¼ :typeuseğ¼ â‡’ ğ‘¥ (if ğ¼ â€² = {locals (ğœ–)* })
?
::= â€˜blockâ€™ (ğ‘£ ? , ğ¼ â€² ):labelğ¼ bt:blocktypeğ¼ (in:instrğ¼ â€² )* â€˜endâ€™ ğ‘£ â€² :id?
?
?
â‡’ block bt in * end
(if ğ‘£ â€² = ğœ– âˆ¨ ğ‘£ â€² = ğ‘£ ? )
?
|
â€˜loopâ€™ (ğ‘£ ? , ğ¼ â€² ):labelğ¼ bt:blocktypeğ¼ (in:instrğ¼ â€² )* â€˜endâ€™ ğ‘£ â€² :id?
?
?
â‡’ loop bt in * end
(if ğ‘£ â€² = ğœ– âˆ¨ ğ‘£ â€² = ğ‘£ ? )
? â€²
|
â€˜ifâ€™ (ğ‘£ , ğ¼ ):labelğ¼ bt:blocktypeğ¼ (in 1 :instrğ¼ â€² )* â€˜elseâ€™ ğ‘£1? :id?1 (in 2 :instrğ¼ â€² )* â€˜endâ€™ ğ‘£2? :id?2
â‡’ if bt in *1 else in *2 end
(if ğ‘£1? = ğœ– âˆ¨ ğ‘£1? = ğ‘£ ? , ğ‘£2? = ğœ– âˆ¨ ğ‘£2? = ğ‘£ ? )
â€²
|
â€˜try_tableâ€™ ğ¼ :labelğ¼ bt:blocktype (ğ‘:catchğ¼ )* (in:instrğ¼ â€² )* â€˜endâ€™ id?
â‡’ try_table bt ğ‘* in * end
(if id? = ğœ– âˆ¨ id? = label)
::= â€˜(â€™ â€˜catchâ€™ ğ‘¥:tagidxğ¼ ğ‘™:labelidxğ¼ â€˜)â€™
â‡’ catch ğ‘¥ ğ‘™
|
â€˜(â€™ â€˜catch_refâ€™ ğ‘¥:tagidxğ¼ ğ‘™:labelidxğ¼ â€˜)â€™ â‡’ catch_ref ğ‘¥ ğ‘™
|
â€˜(â€™ â€˜catch_allâ€™ ğ‘™:labelidxğ¼ â€˜)â€™
â‡’ catch_all ğ‘™
|
â€˜(â€™ â€˜catch_all_refâ€™ ğ‘™:labelidxğ¼ â€˜)â€™
â‡’ catch_all_ref ğ‘™

Ã² Note
The side condition stating that the identifier context ğ¼ â€² must only contain unnamed entries in the rule for
typeuse block types enforces that no identifier can be bound in any param declaration for a block type.
All other control instruction are represented verbatim.
plaininstrğ¼

::=
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|

â€˜unreachableâ€™
â€˜nopâ€™
â€˜brâ€™ ğ‘™:labelidxğ¼
â€˜br_ifâ€™ ğ‘™:labelidxğ¼
â€˜br_tableâ€™ ğ‘™* :vec(labelidxğ¼ ) ğ‘™ğ‘ :labelidxğ¼
â€˜br_on_nullâ€™ ğ‘™:labelidxğ¼
â€˜br_on_non_nullâ€™ ğ‘™:labelidxğ¼
â€˜br_on_castâ€™ ğ‘™:labelidxğ¼ ğ‘¡1 :reftype ğ‘¡2 :reftype
â€˜br_on_cast_failâ€™ ğ‘™:labelidxğ¼ ğ‘¡1 :reftype ğ‘¡2 :reftype
â€˜returnâ€™
â€˜callâ€™ ğ‘¥:funcidxğ¼
â€˜call_refâ€™ ğ‘¥:typeidx
â€˜call_indirectâ€™ ğ‘¥:tableidx ğ‘¦, ğ¼ â€² :typeuseğ¼
â€˜return_callâ€™ ğ‘¥:funcidxğ¼
â€˜return_call_refâ€™ ğ‘¥:typeidx
â€˜return_call_indirectâ€™ ğ‘¥:tableidx ğ‘¦, ğ¼ â€² :typeuseğ¼
â€˜throwâ€™ ğ‘¥:tagidxğ¼
â€˜throw_refâ€™
...

â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’

unreachable
nop
br ğ‘™
br_if ğ‘™
br_table ğ‘™* ğ‘™ğ‘
br_on_null ğ‘™
br_on_non_null ğ‘™
br_on_cast ğ‘™ ğ‘¡1 ğ‘¡2
br_on_cast_fail ğ‘™ ğ‘¡1 ğ‘¡2
return
call ğ‘¥
call_ref ğ‘¥
call_indirect ğ‘¥ ğ‘¦
return_call ğ‘¥
return_call_ref ğ‘¥
return_call_indirect ğ‘¥ ğ‘¦
throw ğ‘¥
throw_ref

Ã² Note
The side condition stating that the identifier context ğ¼ â€² must only contain unnamed entries in the rule for
call_indirect enforces that no identifier can be bound in any param declaration appearing in the type annotation.

6.5. Instructions

219

(if ğ¼ â€² = {

(if ğ¼ â€² = {

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

Abbreviations
The â€˜elseâ€™ keyword of an â€˜ifâ€™ instruction can be omitted if the following instruction sequence is empty.
â€˜ifâ€™ label blocktypeğ¼ instr* â€˜endâ€™ â‰¡ â€˜ifâ€™ label blocktypeğ¼ instr* â€˜elseâ€™ â€˜endâ€™
Also, for backwards compatibility, the table index to â€˜call_indirectâ€™ and â€˜return_call_indirectâ€™ can be
omitted, defaulting to 0.
â€˜call_indirectâ€™ typeuse
â‰¡
â€˜return_call_indirectâ€™ typeuse â‰¡

â€˜call_indirectâ€™ 0 typeuse
â€˜return_call_indirectâ€™ 0 typeuse

6.5.3 Reference Instructions
plaininstrğ¼

::=
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|

...
â€˜ref.nullâ€™ ğ‘¡:heaptype
â€˜ref.funcâ€™ ğ‘¥:funcidx
â€˜ref.is_nullâ€™
â€˜ref.as_non_nullâ€™
â€˜ref.eqâ€™
â€˜ref.testâ€™ ğ‘¡:reftype
â€˜ref.castâ€™ ğ‘¡:reftype
â€˜struct.newâ€™ ğ‘¥:typeidxğ¼
â€˜struct.new_defaultâ€™ ğ‘¥:typeidxğ¼
â€˜struct.getâ€™ ğ‘¥:typeidxğ¼ ğ‘¦:fieldidxğ¼,ğ‘¥
â€˜struct.get_uâ€™ ğ‘¥:typeidxğ¼ ğ‘¦:fieldidxğ¼,ğ‘¥
â€˜struct.get_sâ€™ ğ‘¥:typeidxğ¼ ğ‘¦:fieldidxğ¼,ğ‘¥
â€˜struct.setâ€™ ğ‘¥:typeidxğ¼ ğ‘¦:fieldidxğ¼,ğ‘¥
â€˜array.newâ€™ ğ‘¥:typeidxğ¼
â€˜array.new_defaultâ€™ ğ‘¥:typeidxğ¼
â€˜array.new_fixedâ€™ ğ‘¥:typeidxğ¼ ğ‘›:u32
â€˜array.new_dataâ€™ ğ‘¥:typeidxğ¼ ğ‘¦:dataidxğ¼
â€˜array.new_elemâ€™ ğ‘¥:typeidxğ¼ ğ‘¦:elemidxğ¼
â€˜array.getâ€™ ğ‘¥:typeidxğ¼
â€˜array.get_uâ€™ ğ‘¥:typeidxğ¼
â€˜array.get_sâ€™ ğ‘¥:typeidxğ¼
â€˜array.setâ€™ ğ‘¥:typeidxğ¼
â€˜array.lenâ€™
â€˜array.fillâ€™ ğ‘¥:typeidxğ¼
â€˜array.copyâ€™ ğ‘¥:typeidxğ¼ ğ‘¦:typeidxğ¼
â€˜array.init_dataâ€™ ğ‘¥:typeidxğ¼ ğ‘¦:dataidxğ¼
â€˜array.init_elemâ€™ ğ‘¥:typeidxğ¼ ğ‘¦:elemidxğ¼
â€˜ref.i31â€™
â€˜i31.get_uâ€™
â€˜i31.get_sâ€™
â€˜any.convert_externâ€™
â€˜extern.convert_anyâ€™

â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’

ref.null ğ‘¡
ref.func ğ‘¥
ref.is_null
ref.as_non_null
ref.eq
ref.test ğ‘¡
ref.cast ğ‘¡
struct.new ğ‘¥
struct.new_default ğ‘¥
struct.get ğ‘¥ ğ‘¦
struct.get_u ğ‘¥ ğ‘¦
struct.get_s ğ‘¥ ğ‘¦
struct.set ğ‘¥ ğ‘¦
array.new ğ‘¥
array.new_default ğ‘¥
array.new_fixed ğ‘¥ ğ‘›
array.new_data ğ‘¥ ğ‘¦
array.new_elem ğ‘¥ ğ‘¦
array.get ğ‘¥
array.get_u ğ‘¥
array.get_s ğ‘¥
array.set ğ‘¥
array.len
array.fill ğ‘¥
array.copy ğ‘¥ ğ‘¦
array.init_data ğ‘¥ ğ‘¦
array.init_elem ğ‘¥ ğ‘¦
ref.i31
i31.get_u
i31.get_s
any.convert_extern
extern.convert_any

6.5.4 Parametric Instructions
plaininstrğ¼

220

::=
|
|

...
â€˜dropâ€™
â€˜selectâ€™ ((ğ‘¡:resultğ¼ )* )?

â‡’ drop
â‡’ select (ğ‘¡* )?

Chapter 6. Text Format

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

6.5.5 Variable Instructions
::=
|
|
|
|
|

plaininstrğ¼

...
â€˜local.getâ€™ ğ‘¥:localidxğ¼
â€˜local.setâ€™ ğ‘¥:localidxğ¼
â€˜local.teeâ€™ ğ‘¥:localidxğ¼
â€˜global.getâ€™ ğ‘¥:globalidxğ¼
â€˜global.setâ€™ ğ‘¥:globalidxğ¼

â‡’
â‡’
â‡’
â‡’
â‡’

local.get ğ‘¥
local.set ğ‘¥
local.tee ğ‘¥
global.get ğ‘¥
global.set ğ‘¥

6.5.6 Table Instructions
plaininstrğ¼

::=
|
|
|
|
|
|
|
|

...
â€˜table.getâ€™ ğ‘¥:tableidxğ¼
â€˜table.setâ€™ ğ‘¥:tableidxğ¼
â€˜table.sizeâ€™ ğ‘¥:tableidxğ¼
â€˜table.growâ€™ ğ‘¥:tableidxğ¼
â€˜table.fillâ€™ ğ‘¥:tableidxğ¼
â€˜table.copyâ€™ ğ‘¥:tableidxğ¼ ğ‘¦:tableidxğ¼
â€˜table.initâ€™ ğ‘¥:tableidxğ¼ ğ‘¦:elemidxğ¼
â€˜elem.dropâ€™ ğ‘¥:elemidxğ¼

â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’

table.get ğ‘¥
table.set ğ‘¥
table.size ğ‘¥
table.grow ğ‘¥
table.fill ğ‘¥
table.copy ğ‘¥ ğ‘¦
table.init ğ‘¥ ğ‘¦
elem.drop ğ‘¥

Abbreviations
For backwards compatibility, all table indices may be omitted from table instructions, defaulting to 0.
â€˜table.getâ€™
â€˜table.setâ€™
â€˜table.sizeâ€™
â€˜table.growâ€™
â€˜table.fillâ€™
â€˜table.copyâ€™
â€˜table.initâ€™ ğ‘¥:elemidxğ¼

â‰¡
â‰¡
â‰¡
â‰¡
â‰¡
â‰¡
â‰¡

â€˜table.getâ€™ â€˜0â€™
â€˜table.setâ€™ â€˜0â€™
â€˜table.sizeâ€™ â€˜0â€™
â€˜table.growâ€™ â€˜0â€™
â€˜table.fillâ€™ â€˜0â€™
â€˜table.copyâ€™ â€˜0â€™ â€˜0â€™
â€˜table.initâ€™ â€˜0â€™ ğ‘¥:elemidxğ¼

6.5.7 Memory Instructions
The offset and alignment immediates to memory instructions are optional. The offset defaults to 0, the alignment
to the storage size of the respective memory access, which is its natural alignment. Lexically, an offset or align

6.5. Instructions

221

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

phrase is considered a single keyword token, so no white space is allowed around the â€˜=â€™.
memargğ‘
offset
alignğ‘
plaininstrğ¼

222

::=
::=
|
::=
|
::=
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|

ğ‘œ:offset ğ‘:alignğ‘
â€˜offset=â€™ğ‘œ:u64
ğœ–
â€˜align=â€™ğ‘:u64
ğœ–
...
â€˜i32.loadâ€™ ğ‘¥:memidx ğ‘š:memarg4
â€˜i64.loadâ€™ ğ‘¥:memidx ğ‘š:memarg8
â€˜f32.loadâ€™ ğ‘¥:memidx ğ‘š:memarg4
â€˜f64.loadâ€™ ğ‘¥:memidx ğ‘š:memarg8
â€˜v128.loadâ€™ ğ‘¥:memidx ğ‘š:memarg16
â€˜i32.load8_sâ€™ ğ‘¥:memidx ğ‘š:memarg1
â€˜i32.load8_uâ€™ ğ‘¥:memidx ğ‘š:memarg1
â€˜i32.load16_sâ€™ ğ‘¥:memidx ğ‘š:memarg2
â€˜i32.load16_uâ€™ ğ‘¥:memidx ğ‘š:memarg2
â€˜i64.load8_sâ€™ ğ‘¥:memidx ğ‘š:memarg1
â€˜i64.load8_uâ€™ ğ‘¥:memidx ğ‘š:memarg1
â€˜i64.load16_sâ€™ ğ‘¥:memidx ğ‘š:memarg2
â€˜i64.load16_uâ€™ ğ‘¥:memidx ğ‘š:memarg2
â€˜i64.load32_sâ€™ ğ‘¥:memidx ğ‘š:memarg4
â€˜i64.load32_uâ€™ ğ‘¥:memidx ğ‘š:memarg4
â€˜v128.load8x8_sâ€™ ğ‘¥:memidx ğ‘š:memarg8
â€˜v128.load8x8_uâ€™ ğ‘¥:memidx ğ‘š:memarg8
â€˜v128.load16x4_sâ€™ ğ‘¥:memidx ğ‘š:memarg8
â€˜v128.load16x4_uâ€™ ğ‘¥:memidx ğ‘š:memarg8
â€˜v128.load32x2_sâ€™ ğ‘¥:memidx ğ‘š:memarg8
â€˜v128.load32x2_uâ€™ ğ‘¥:memidx ğ‘š:memarg8
â€˜v128.load8_splatâ€™ ğ‘¥:memidx ğ‘š:memarg1
â€˜v128.load16_splatâ€™ ğ‘¥:memidx ğ‘š:memarg2
â€˜v128.load32_splatâ€™ ğ‘¥:memidx ğ‘š:memarg4
â€˜v128.load64_splatâ€™ ğ‘¥:memidx ğ‘š:memarg8
â€˜v128.load32_zeroâ€™ ğ‘¥:memidx ğ‘š:memarg4
â€˜v128.load64_zeroâ€™ ğ‘¥:memidx ğ‘š:memarg8
â€˜v128.load8_laneâ€™ ğ‘¥:memidx ğ‘š:memarg1 ğ‘¦:u8
â€˜v128.load16_laneâ€™ ğ‘¥:memidx ğ‘š:memarg2 ğ‘¦:u8
â€˜v128.load32_laneâ€™ ğ‘¥:memidx ğ‘š:memarg4 ğ‘¦:u8
â€˜v128.load64_laneâ€™ ğ‘¥:memidx ğ‘š:memarg8 ğ‘¦:u8
â€˜i32.storeâ€™ ğ‘¥:memidx ğ‘š:memarg4
â€˜i64.storeâ€™ ğ‘¥:memidx ğ‘š:memarg8
â€˜f32.storeâ€™ ğ‘¥:memidx ğ‘š:memarg4
â€˜f64.storeâ€™ ğ‘¥:memidx ğ‘š:memarg8
â€˜v128.storeâ€™ ğ‘¥:memidx ğ‘š:memarg16
â€˜i32.store8â€™ ğ‘¥:memidx ğ‘š:memarg1
â€˜i32.store16â€™ ğ‘¥:memidx ğ‘š:memarg2
â€˜i64.store8â€™ ğ‘¥:memidx ğ‘š:memarg1
â€˜i64.store16â€™ ğ‘¥:memidx ğ‘š:memarg2
â€˜i64.store32â€™ ğ‘¥:memidx ğ‘š:memarg4
â€˜v128.store8_laneâ€™ ğ‘¥:memidx ğ‘š:memarg1 ğ‘¦:u8
â€˜v128.store16_laneâ€™ ğ‘¥:memidx ğ‘š:memarg2 ğ‘¦:u8
â€˜v128.store32_laneâ€™ ğ‘¥:memidx ğ‘š:memarg4 ğ‘¦:u8
â€˜v128.store64_laneâ€™ ğ‘¥:memidx ğ‘š:memarg8 ğ‘¦:u8
â€˜memory.sizeâ€™ ğ‘¥:memidx
â€˜memory.growâ€™ ğ‘¥:memidx
â€˜memory.fillâ€™ ğ‘¥:memidx
â€˜memory.copyâ€™ ğ‘¥:memidx ğ‘¦:memidx
â€˜memory.initâ€™ ğ‘¥:memidx ğ‘¦:dataidxğ¼
â€˜data.dropâ€™ ğ‘¥:dataidxğ¼

â‡’ {align ğ‘›, offset ğ‘œ}
â‡’ ğ‘œ
â‡’ 0
â‡’ ğ‘
â‡’ ğ‘
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’

i32.load ğ‘¥ ğ‘š
i64.load ğ‘¥ ğ‘š
f32.load ğ‘¥ ğ‘š
f64.load ğ‘¥ ğ‘š
v128.load ğ‘¥ ğ‘š
i32.load8_s ğ‘¥ ğ‘š
i32.load8_u ğ‘¥ ğ‘š
i32.load16_s ğ‘¥ ğ‘š
i32.load16_u ğ‘¥ ğ‘š
i64.load8_s ğ‘¥ ğ‘š
i64.load8_u ğ‘¥ ğ‘š
i64.load16_s ğ‘¥ ğ‘š
i64.load16_u ğ‘¥ ğ‘š
i64.load32_s ğ‘¥ ğ‘š
i64.load32_u ğ‘¥ ğ‘š
v128.load8x8_s ğ‘¥ ğ‘š
v128.load8x8_u ğ‘¥ ğ‘š
v128.load16x4_s ğ‘¥ ğ‘š
v128.load16x4_u ğ‘¥ ğ‘š
v128.load32x2_s ğ‘¥ ğ‘š
v128.load32x2_u ğ‘¥ ğ‘š
v128.load8_splat ğ‘¥ ğ‘š
v128.load16_splat ğ‘¥ ğ‘š
v128.load32_splat ğ‘¥ ğ‘š
v128.load64_splat ğ‘¥ ğ‘š
v128.load32_zero ğ‘¥ ğ‘š
v128.load64_zero ğ‘¥ ğ‘š
v128.load8_lane ğ‘¥ ğ‘š ğ‘¦
v128.load16_lane ğ‘¥ ğ‘š ğ‘¦
v128.load32_lane ğ‘¥ ğ‘š ğ‘¦
v128.load64_lane ğ‘¥ ğ‘š ğ‘¦
i32.store ğ‘¥ ğ‘š
i64.store ğ‘¥ ğ‘š
f32.store ğ‘¥ ğ‘š
f64.store ğ‘¥ ğ‘š
v128.store ğ‘¥ ğ‘š
i32.store8 ğ‘¥ ğ‘š
i32.store16 ğ‘¥ ğ‘š
i64.store8 ğ‘¥ ğ‘š
i64.store16 ğ‘¥ ğ‘š
i64.store32 ğ‘¥ ğ‘š
v128.store8_lane ğ‘¥ ğ‘š ğ‘¦
v128.store16_lane ğ‘¥ ğ‘š ğ‘¦
v128.store32_lane ğ‘¥ ğ‘š ğ‘¦
v128.store64_lane ğ‘¥ ğ‘š ğ‘¦
memory.size ğ‘¥
memory.grow ğ‘¥
memory.fill ğ‘¥
memory.copy ğ‘¥ ğ‘¦
memory.init ğ‘¥ ğ‘¦
data.drop ğ‘¥
Chapter 6. Text Format

(if

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

Abbreviations
As an abbreviation, the memory index can be omitted in all memory instructions, defaulting to 0.
numtypeâ€˜.loadâ€™ memarg
vectypeâ€˜.loadâ€™ memarg
numtypeâ€˜.loadâ€™ğ‘ â€˜_â€™sx memarg
vectypeâ€˜.loadâ€™ğ‘ xğ‘€ â€˜_â€™sx memarg
vectypeâ€˜.loadâ€™ğ‘ â€˜_splatâ€™ memarg
vectypeâ€˜.loadâ€™ğ‘ â€˜_zeroâ€™ memarg
vectypeâ€˜.loadâ€™ğ‘ â€˜_laneâ€™ memarg u8
numtypeâ€˜.storeâ€™ memarg
vectypeâ€˜.storeâ€™ memarg
numtypeâ€˜.storeâ€™ğ‘ memarg
vectypeâ€˜.storeâ€™ğ‘ â€˜_laneâ€™ memarg u8
â€˜memory.sizeâ€™
â€˜memory.growâ€™
â€˜memory.fillâ€™
â€˜memory.copyâ€™
â€˜memory.initâ€™ ğ‘¥:elemidxğ¼

â‰¡
â‰¡
â‰¡
â‰¡
â‰¡
â‰¡
â‰¡
â‰¡
â‰¡
â‰¡
â‰¡
â‰¡
â‰¡
â‰¡
â‰¡
â‰¡

numtypeâ€˜.loadâ€™ â€˜0â€™ memarg
vectypeâ€˜.loadâ€™ â€˜0â€™ memarg
numtypeâ€˜.loadâ€™ğ‘ â€˜_â€™sx â€˜0â€™ memarg
vectypeâ€˜.loadâ€™ğ‘ xğ‘€ â€˜_â€™sx â€˜0â€™ memarg
vectypeâ€˜.loadâ€™ğ‘ â€˜_splatâ€™ â€˜0â€™ memarg
vectypeâ€˜.loadâ€™ğ‘ â€˜_zeroâ€™ â€˜0â€™ memarg
vectypeâ€˜.loadâ€™ğ‘ â€˜_laneâ€™ â€˜0â€™ memarg u8
numtypeâ€˜.storeâ€™ â€˜0â€™ memarg
vectypeâ€˜.storeâ€™ â€˜0â€™ memarg
numtypeâ€˜.storeâ€™ğ‘ â€˜0â€™ memarg
vectypeâ€˜.storeâ€™ğ‘ â€˜_laneâ€™ â€˜0â€™ memarg u8
â€˜memory.sizeâ€™ â€˜0â€™
â€˜memory.growâ€™ â€˜0â€™
â€˜memory.fillâ€™ â€˜0â€™
â€˜memory.copyâ€™ â€˜0â€™ â€˜0â€™
â€˜memory.initâ€™ â€˜0â€™ ğ‘¥:elemidxğ¼

6.5.8 Numeric Instructions
::=
|
|
|
|

plaininstrğ¼

|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|

6.5. Instructions

...
â€˜i32.constâ€™ ğ‘›:i32
â€˜i64.constâ€™ ğ‘›:i64
â€˜f32.constâ€™ ğ‘§:f32
â€˜f64.constâ€™ ğ‘§:f64
â€˜i32.clzâ€™
â€˜i32.ctzâ€™
â€˜i32.popcntâ€™
â€˜i32.addâ€™
â€˜i32.subâ€™
â€˜i32.mulâ€™
â€˜i32.div_sâ€™
â€˜i32.div_uâ€™
â€˜i32.rem_sâ€™
â€˜i32.rem_uâ€™
â€˜i32.andâ€™
â€˜i32.orâ€™
â€˜i32.xorâ€™
â€˜i32.shlâ€™
â€˜i32.shr_sâ€™
â€˜i32.shr_uâ€™
â€˜i32.rotlâ€™
â€˜i32.rotrâ€™

â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’

â‡’
â‡’
â‡’
â‡’

i32.const ğ‘›
i64.const ğ‘›
f32.const ğ‘§
f64.const ğ‘§

i32.clz
i32.ctz
i32.popcnt
i32.add
i32.sub
i32.mul
i32.div_s
i32.div_u
i32.rem_s
i32.rem_u
i32.and
i32.or
i32.xor
i32.shl
i32.shr_s
i32.shr_u
i32.rotl
i32.rotr

223

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

â€˜i64.clzâ€™
â€˜i64.ctzâ€™
â€˜i64.popcntâ€™
â€˜i64.addâ€™
â€˜i64.subâ€™
â€˜i64.mulâ€™
â€˜i64.div_sâ€™
â€˜i64.div_uâ€™
â€˜i64.rem_sâ€™
â€˜i64.rem_uâ€™
â€˜i64.andâ€™
â€˜i64.orâ€™
â€˜i64.xorâ€™
â€˜i64.shlâ€™
â€˜i64.shr_sâ€™
â€˜i64.shr_uâ€™
â€˜i64.rotlâ€™
â€˜i64.rotrâ€™

â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’

i64.clz
i64.ctz
i64.popcnt
i64.add
i64.sub
i64.mul
i64.div_s
i64.div_u
i64.rem_s
i64.rem_u
i64.and
i64.or
i64.xor
i64.shl
i64.shr_s
i64.shr_u
i64.rotl
i64.rotr

|
|
|
|
|
|
|
|
|
|
|
|
|
|

â€˜f32.absâ€™
â€˜f32.negâ€™
â€˜f32.ceilâ€™
â€˜f32.floorâ€™
â€˜f32.truncâ€™
â€˜f32.nearestâ€™
â€˜f32.sqrtâ€™
â€˜f32.addâ€™
â€˜f32.subâ€™
â€˜f32.mulâ€™
â€˜f32.divâ€™
â€˜f32.minâ€™
â€˜f32.maxâ€™
â€˜f32.copysignâ€™

â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’

f32.abs
f32.neg
f32.ceil
f32.floor
f32.trunc
f32.nearest
f32.sqrt
f32.add
f32.sub
f32.mul
f32.div
f32.min
f32.max
f32.copysign

|
|
|
|
|
|
|
|
|
|
|
|
|
|

â€˜f64.absâ€™
â€˜f64.negâ€™
â€˜f64.ceilâ€™
â€˜f64.floorâ€™
â€˜f64.truncâ€™
â€˜f64.nearestâ€™
â€˜f64.sqrtâ€™
â€˜f64.addâ€™
â€˜f64.subâ€™
â€˜f64.mulâ€™
â€˜f64.divâ€™
â€˜f64.minâ€™
â€˜f64.maxâ€™
â€˜f64.copysignâ€™

â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’

f64.abs
f64.neg
f64.ceil
f64.floor
f64.trunc
f64.nearest
f64.sqrt
f64.add
f64.sub
f64.mul
f64.div
f64.min
f64.max
f64.copysign

|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|

224

Chapter 6. Text Format

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

6.5. Instructions

|
|
|
|
|
|
|
|
|
|
|

â€˜i32.eqzâ€™
â€˜i32.eqâ€™
â€˜i32.neâ€™
â€˜i32.lt_sâ€™
â€˜i32.lt_uâ€™
â€˜i32.gt_sâ€™
â€˜i32.gt_uâ€™
â€˜i32.le_sâ€™
â€˜i32.le_uâ€™
â€˜i32.ge_sâ€™
â€˜i32.ge_uâ€™

â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’

i32.eqz
i32.eq
i32.ne
i32.lt_s
i32.lt_u
i32.gt_s
i32.gt_u
i32.le_s
i32.le_u
i32.ge_s
i32.ge_u

|
|
|
|
|
|
|
|
|
|
|

â€˜i64.eqzâ€™
â€˜i64.eqâ€™
â€˜i64.neâ€™
â€˜i64.lt_sâ€™
â€˜i64.lt_uâ€™
â€˜i64.gt_sâ€™
â€˜i64.gt_uâ€™
â€˜i64.le_sâ€™
â€˜i64.le_uâ€™
â€˜i64.ge_sâ€™
â€˜i64.ge_uâ€™

â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’

i64.eqz
i64.eq
i64.ne
i64.lt_s
i64.lt_u
i64.gt_s
i64.gt_u
i64.le_s
i64.le_u
i64.ge_s
i64.ge_u

|
|
|
|
|
|

â€˜f32.eqâ€™
â€˜f32.neâ€™
â€˜f32.ltâ€™
â€˜f32.gtâ€™
â€˜f32.leâ€™
â€˜f32.geâ€™

â‡’
â‡’
â‡’
â‡’
â‡’
â‡’

f32.eq
f32.ne
f32.lt
f32.gt
f32.le
f32.ge

|
|
|
|
|
|

â€˜f64.eqâ€™
â€˜f64.neâ€™
â€˜f64.ltâ€™
â€˜f64.gtâ€™
â€˜f64.leâ€™
â€˜f64.geâ€™

â‡’
â‡’
â‡’
â‡’
â‡’
â‡’

f64.eq
f64.ne
f64.lt
f64.gt
f64.le
f64.ge

225

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

â€˜i32.wrap_i64â€™
â€˜i32.trunc_f32_sâ€™
â€˜i32.trunc_f32_uâ€™
â€˜i32.trunc_f64_sâ€™
â€˜i32.trunc_f64_uâ€™
â€˜i32.trunc_sat_f32_sâ€™
â€˜i32.trunc_sat_f32_uâ€™
â€˜i32.trunc_sat_f64_sâ€™
â€˜i32.trunc_sat_f64_uâ€™
â€˜i64.extend_i32_sâ€™
â€˜i64.extend_i32_uâ€™
â€˜i64.trunc_f32_sâ€™
â€˜i64.trunc_f32_uâ€™
â€˜i64.trunc_f64_sâ€™
â€˜i64.trunc_f64_uâ€™
â€˜i64.trunc_sat_f32_sâ€™
â€˜i64.trunc_sat_f32_uâ€™
â€˜i64.trunc_sat_f64_sâ€™
â€˜i64.trunc_sat_f64_uâ€™
â€˜f32.convert_i32_sâ€™
â€˜f32.convert_i32_uâ€™
â€˜f32.convert_i64_sâ€™
â€˜f32.convert_i64_uâ€™
â€˜f32.demote_f64â€™
â€˜f64.convert_i32_sâ€™
â€˜f64.convert_i32_uâ€™
â€˜f64.convert_i64_sâ€™
â€˜f64.convert_i64_uâ€™
â€˜f64.promote_f32â€™
â€˜i32.reinterpret_f32â€™
â€˜i64.reinterpret_f64â€™
â€˜f32.reinterpret_i32â€™
â€˜f64.reinterpret_i64â€™

|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|

â€˜i32.extend8_sâ€™
â€˜i32.extend16_sâ€™
â€˜i64.extend8_sâ€™
â€˜i64.extend16_sâ€™
â€˜i64.extend32_sâ€™

â‡’
â‡’
â‡’
â‡’
â‡’

â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’

i32.wrap_i64
i32.trunc_f32_s
i32.trunc_f32_u
i32.trunc_f64_s
i32.trunc_f64_u
i32.trunc_sat_f32_s
i32.trunc_sat_f32_u
i32.trunc_sat_f64_s
i32.trunc_sat_f64_u
i64.extend_i32_s
i64.extend_i32_u
i64.trunc_f32_s
i64.trunc_f32_u
i64.trunc_f64_s
i64.trunc_f64_u
i64.trunc_sat_f32_s
i64.trunc_sat_f32_u
i64.trunc_sat_f64_s
i64.trunc_sat_f64_u
f32.convert_i32_s
f32.convert_i32_u
f32.convert_i64_s
f32.convert_i64_u
f32.demote_f64
f64.convert_i32_s
f64.convert_i32_u
f64.convert_i64_s
f64.convert_i64_u
f64.promote_f32
i32.reinterpret_f32
i64.reinterpret_f64
f32.reinterpret_i32
f64.reinterpret_i64

i32.extend8_s
i32.extend16_s
i64.extend8_s
i64.extend16_s
i64.extend32_s

6.5.9 Vector Instructions
Vector constant instructions have a mandatory shape descriptor, which determines how the following values are
parsed.

226

|
|
|
|
|
|

â€˜v128.constâ€™ â€˜i8x16â€™ (ğ‘›:i8)16
â€˜v128.constâ€™ â€˜i16x8â€™ (ğ‘›:i16)8
â€˜v128.constâ€™ â€˜i32x4â€™ (ğ‘›:i32)4
â€˜v128.constâ€™ â€˜i64x2â€™ (ğ‘›:i64)2
â€˜v128.constâ€™ â€˜f32x4â€™ (ğ‘§:f32)4
â€˜v128.constâ€™ â€˜f64x2â€™ (ğ‘§:f64)2

â‡’
â‡’
â‡’
â‡’
â‡’
â‡’

16
v128.const bytesâˆ’1
ğ‘–128 (bytesğ‘–8 (ğ‘›) )
âˆ’1
v128.const bytesğ‘–128 (bytesğ‘–16 (ğ‘›)8 )
4
v128.const bytesâˆ’1
ğ‘–128 (bytesğ‘–32 (ğ‘›) )
âˆ’1
v128.const bytesğ‘–128 (bytesğ‘–64 (ğ‘›)2 )
4
v128.const bytesâˆ’1
ğ‘–128 (bytesğ‘“ 32 (ğ‘§) )
âˆ’1
v128.const bytesğ‘–128 (bytesğ‘“ 64 (ğ‘§)2 )

|
|

â€˜i8x16.shuffleâ€™ (ğ‘™ğ‘ğ‘›ğ‘’ğ‘–ğ‘‘ğ‘¥:u8)16
â€˜i8x16.swizzleâ€™

â‡’
â‡’

i8x16.shuffle ğ‘™ğ‘ğ‘›ğ‘’ğ‘–ğ‘‘ğ‘¥16
i8x16.swizzle

Chapter 6. Text Format

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

6.5. Instructions

|
|
|
|
|
|

â€˜i8x16.splatâ€™
â€˜i16x8.splatâ€™
â€˜i32x4.splatâ€™
â€˜i64x2.splatâ€™
â€˜f32x4.splatâ€™
â€˜f64x2.splatâ€™

â‡’
â‡’
â‡’
â‡’
â‡’
â‡’

i8x16.splat
i16x8.splat
i32x4.splat
i64x2.splat
f32x4.splat
f64x2.splat

|
|
|
|
|
|
|
|
|
|
|
|
|
|

â€˜i8x16.extract_lane_sâ€™ ğ‘™ğ‘ğ‘›ğ‘’ğ‘–ğ‘‘ğ‘¥:u8
â€˜i8x16.extract_lane_uâ€™ ğ‘™ğ‘ğ‘›ğ‘’ğ‘–ğ‘‘ğ‘¥:u8
â€˜i8x16.replace_laneâ€™ ğ‘™ğ‘ğ‘›ğ‘’ğ‘–ğ‘‘ğ‘¥:u8
â€˜i16x8.extract_lane_sâ€™ ğ‘™ğ‘ğ‘›ğ‘’ğ‘–ğ‘‘ğ‘¥:u8
â€˜i16x8.extract_lane_uâ€™ ğ‘™ğ‘ğ‘›ğ‘’ğ‘–ğ‘‘ğ‘¥:u8
â€˜i16x8.replace_laneâ€™ ğ‘™ğ‘ğ‘›ğ‘’ğ‘–ğ‘‘ğ‘¥:u8
â€˜i32x4.extract_laneâ€™ ğ‘™ğ‘ğ‘›ğ‘’ğ‘–ğ‘‘ğ‘¥:u8
â€˜i32x4.replace_laneâ€™ ğ‘™ğ‘ğ‘›ğ‘’ğ‘–ğ‘‘ğ‘¥:u8
â€˜i64x2.extract_laneâ€™ ğ‘™ğ‘ğ‘›ğ‘’ğ‘–ğ‘‘ğ‘¥:u8
â€˜i64x2.replace_laneâ€™ ğ‘™ğ‘ğ‘›ğ‘’ğ‘–ğ‘‘ğ‘¥:u8
â€˜f32x4.extract_laneâ€™ ğ‘™ğ‘ğ‘›ğ‘’ğ‘–ğ‘‘ğ‘¥:u8
â€˜f32x4.replace_laneâ€™ ğ‘™ğ‘ğ‘›ğ‘’ğ‘–ğ‘‘ğ‘¥:u8
â€˜f64x2.extract_laneâ€™ ğ‘™ğ‘ğ‘›ğ‘’ğ‘–ğ‘‘ğ‘¥:u8
â€˜f64x2.replace_laneâ€™ ğ‘™ğ‘ğ‘›ğ‘’ğ‘–ğ‘‘ğ‘¥:u8

â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’

i8x16.extract_lane_s ğ‘™ğ‘ğ‘›ğ‘’ğ‘–ğ‘‘ğ‘¥
i8x16.extract_lane_u ğ‘™ğ‘ğ‘›ğ‘’ğ‘–ğ‘‘ğ‘¥
i8x16.replace_lane ğ‘™ğ‘ğ‘›ğ‘’ğ‘–ğ‘‘ğ‘¥
i16x8.extract_lane_s ğ‘™ğ‘ğ‘›ğ‘’ğ‘–ğ‘‘ğ‘¥
i16x8.extract_lane_u ğ‘™ğ‘ğ‘›ğ‘’ğ‘–ğ‘‘ğ‘¥
i16x8.replace_lane ğ‘™ğ‘ğ‘›ğ‘’ğ‘–ğ‘‘ğ‘¥
i32x4.extract_lane ğ‘™ğ‘ğ‘›ğ‘’ğ‘–ğ‘‘ğ‘¥
i32x4.replace_lane ğ‘™ğ‘ğ‘›ğ‘’ğ‘–ğ‘‘ğ‘¥
i64x2.extract_lane ğ‘™ğ‘ğ‘›ğ‘’ğ‘–ğ‘‘ğ‘¥
i64x2.replace_lane ğ‘™ğ‘ğ‘›ğ‘’ğ‘–ğ‘‘ğ‘¥
f32x4.extract_lane ğ‘™ğ‘ğ‘›ğ‘’ğ‘–ğ‘‘ğ‘¥
f32x4.replace_lane ğ‘™ğ‘ğ‘›ğ‘’ğ‘–ğ‘‘ğ‘¥
f64x2.extract_lane ğ‘™ğ‘ğ‘›ğ‘’ğ‘–ğ‘‘ğ‘¥
f64x2.replace_lane ğ‘™ğ‘ğ‘›ğ‘’ğ‘–ğ‘‘ğ‘¥

|
|
|
|
|
|
|
|
|
|

â€˜i8x16.eqâ€™
â€˜i8x16.neâ€™
â€˜i8x16.lt_sâ€™
â€˜i8x16.lt_uâ€™
â€˜i8x16.gt_sâ€™
â€˜i8x16.gt_uâ€™
â€˜i8x16.le_sâ€™
â€˜i8x16.le_uâ€™
â€˜i8x16.ge_sâ€™
â€˜i8x16.ge_uâ€™

â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’

i8x16.eq
i8x16.ne
i8x16.lt_s
i8x16.lt_u
i8x16.gt_s
i8x16.gt_u
i8x16.le_s
i8x16.le_u
i8x16.ge_s
i8x16.ge_u

|
|
|
|
|
|
|
|
|
|

â€˜i16x8.eqâ€™
â€˜i16x8.neâ€™
â€˜i16x8.lt_sâ€™
â€˜i16x8.lt_uâ€™
â€˜i16x8.gt_sâ€™
â€˜i16x8.gt_uâ€™
â€˜i16x8.le_sâ€™
â€˜i16x8.le_uâ€™
â€˜i16x8.ge_sâ€™
â€˜i16x8.ge_uâ€™

â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’

i16x8.eq
i16x8.ne
i16x8.lt_s
i16x8.lt_u
i16x8.gt_s
i16x8.gt_u
i16x8.le_s
i16x8.le_u
i16x8.ge_s
i16x8.ge_u

|
|
|
|
|
|
|
|
|
|

â€˜i32x4.eqâ€™
â€˜i32x4.neâ€™
â€˜i32x4.lt_sâ€™
â€˜i32x4.lt_uâ€™
â€˜i32x4.gt_sâ€™
â€˜i32x4.gt_uâ€™
â€˜i32x4.le_sâ€™
â€˜i32x4.le_uâ€™
â€˜i32x4.ge_sâ€™
â€˜i32x4.ge_uâ€™

â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’

i32x4.eq
i32x4.ne
i32x4.lt_s
i32x4.lt_u
i32x4.gt_s
i32x4.gt_u
i32x4.le_s
i32x4.le_u
i32x4.ge_s
i32x4.ge_u

227

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

228

|
|
|
|
|
|
|

â€˜i64x2.eqâ€™
â€˜i64x2.neâ€™
â€˜i64x2.lt_sâ€™
â€˜i64x2.gt_sâ€™
â€˜i64x2.le_sâ€™
â€˜i64x2.ge_sâ€™

â‡’
â‡’
â‡’
â‡’
â‡’
â‡’

i64x2.eq
i64x2.ne
i64x2.lt_s
i64x2.gt_s
i64x2.le_s
i64x2.ge_s

|
|
|
|
|
|

â€˜f32x4.eqâ€™
â€˜f32x4.neâ€™
â€˜f32x4.ltâ€™
â€˜f32x4.gtâ€™
â€˜f32x4.leâ€™
â€˜f32x4.geâ€™

â‡’
â‡’
â‡’
â‡’
â‡’
â‡’

f32x4.eq
f32x4.ne
f32x4.lt
f32x4.gt
f32x4.le
f32x4.ge

|
|
|
|
|
|

â€˜f64x2.eqâ€™
â€˜f64x2.neâ€™
â€˜f64x2.ltâ€™
â€˜f64x2.gtâ€™
â€˜f64x2.leâ€™
â€˜f64x2.geâ€™

â‡’
â‡’
â‡’
â‡’
â‡’
â‡’

f64x2.eq
f64x2.ne
f64x2.lt
f64x2.gt
f64x2.le
f64x2.ge

|
|
|
|
|
|
|

â€˜v128.notâ€™
â€˜v128.andâ€™
â€˜v128.andnotâ€™
â€˜v128.orâ€™
â€˜v128.xorâ€™
â€˜v128.bitselectâ€™
â€˜v128.any_trueâ€™

â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’

v128.not
v128.and
v128.andnot
v128.or
v128.xor
v128.bitselect
v128.any_true

|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|

â€˜i8x16.absâ€™
â€˜i8x16.negâ€™
â€˜i8x16.all_trueâ€™
â€˜i8x16.bitmaskâ€™
â€˜i8x16.narrow_i16x8_sâ€™
â€˜i8x16.narrow_i16x8_uâ€™
â€˜i8x16.shlâ€™
â€˜i8x16.shr_sâ€™
â€˜i8x16.shr_uâ€™
â€˜i8x16.addâ€™
â€˜i8x16.add_sat_sâ€™
â€˜i8x16.add_sat_uâ€™
â€˜i8x16.subâ€™
â€˜i8x16.sub_sat_sâ€™
â€˜i8x16.sub_sat_uâ€™
â€˜i8x16.min_sâ€™
â€˜i8x16.min_uâ€™
â€˜i8x16.max_sâ€™
â€˜i8x16.max_uâ€™
â€˜i8x16.avgr_uâ€™
â€˜i8x16.popcntâ€™

â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’

i8x16.abs
i8x16.neg
i8x16.all_true
i8x16.bitmask
i8x16.narrow_i16x8_s
i8x16.narrow_i16x8_u
i8x16.shl
i8x16.shr_s
i8x16.shr_u
i8x16.add
i8x16.add_sat_s
i8x16.add_sat_u
i8x16.sub
i8x16.sub_sat_s
i8x16.sub_sat_u
i8x16.min_s
i8x16.min_u
i8x16.max_s
i8x16.max_u
i8x16.avgr_u
i8x16.popcnt

Chapter 6. Text Format

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

6.5. Instructions

|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|

â€˜i16x8.absâ€™
â€˜i16x8.negâ€™
â€˜i16x8.all_trueâ€™
â€˜i16x8.bitmaskâ€™
â€˜i16x8.narrow_i32x4_sâ€™
â€˜i16x8.narrow_i32x4_uâ€™
â€˜i16x8.extend_low_i8x16_sâ€™
â€˜i16x8.extend_high_i8x16_sâ€™
â€˜i16x8.extend_low_i8x16_uâ€™
â€˜i16x8.extend_high_i8x16_uâ€™
â€˜i16x8.shlâ€™
â€˜i16x8.shr_sâ€™
â€˜i16x8.shr_uâ€™
â€˜i16x8.addâ€™
â€˜i16x8.add_sat_sâ€™
â€˜i16x8.add_sat_uâ€™
â€˜i16x8.subâ€™
â€˜i16x8.sub_sat_sâ€™
â€˜i16x8.sub_sat_uâ€™
â€˜i16x8.mulâ€™
â€˜i16x8.min_sâ€™
â€˜i16x8.min_uâ€™
â€˜i16x8.max_sâ€™
â€˜i16x8.max_uâ€™
â€˜i16x8.avgr_uâ€™
â€˜i16x8.q15mulr_sat_sâ€™
â€˜i16x8.extmul_low_i8x16_sâ€™
â€˜i16x8.extmul_high_i8x16_sâ€™
â€˜i16x8.extmul_low_i8x16_uâ€™
â€˜i16x8.extmul_high_i8x16_uâ€™
â€˜i16x8.extadd_pairwise_i8x16_sâ€™
â€˜i16x8.extadd_pairwise_i8x16_uâ€™

â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’

i16x8.abs
i16x8.neg
i16x8.all_true
i16x8.bitmask
i16x8.narrow_i32x4_s
i16x8.narrow_i32x4_u
i16x8.extend_low_i8x16_s
i16x8.extend_high_i8x16_s
i16x8.extend_low_i8x16_u
i16x8.extend_high_i8x16_u
i16x8.shl
i16x8.shr_s
i16x8.shr_u
i16x8.add
i16x8.add_sat_s
i16x8.add_sat_u
i16x8.sub
i16x8.sub_sat_s
i16x8.sub_sat_u
i16x8.mul
i16x8.min_s
i16x8.min_u
i16x8.max_s
i16x8.max_u
i16x8.avgr_u
i16x8.q15mulr_sat_s
i16x8.extmul_low_i8x16_s
i16x8.extmul_high_i8x16_s
i16x8.extmul_low_i8x16_u
i16x8.extmul_high_i8x16_u
i16x8.extadd_pairwise_i8x16_s
i16x8.extadd_pairwise_i8x16_u

|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|

â€˜i32x4.absâ€™
â€˜i32x4.negâ€™
â€˜i32x4.all_trueâ€™
â€˜i32x4.bitmaskâ€™
â€˜i32x4.extadd_pairwise_i16x8_sâ€™
â€˜i32x4.extadd_pairwise_i16x8_uâ€™
â€˜i32x4.extend_low_i16x8_sâ€™
â€˜i32x4.extend_high_i16x8_sâ€™
â€˜i32x4.extend_low_i16x8_uâ€™
â€˜i32x4.extend_high_i16x8_uâ€™
â€˜i32x4.shlâ€™
â€˜i32x4.shr_sâ€™
â€˜i32x4.shr_uâ€™
â€˜i32x4.addâ€™
â€˜i32x4.subâ€™
â€˜i32x4.mulâ€™
â€˜i32x4.min_sâ€™
â€˜i32x4.min_uâ€™
â€˜i32x4.max_sâ€™
â€˜i32x4.max_uâ€™
â€˜i32x4.dot_i16x8_sâ€™
â€˜i32x4.extmul_low_i16x8_sâ€™
â€˜i32x4.extmul_high_i16x8_sâ€™
â€˜i32x4.extmul_low_i16x8_uâ€™
â€˜i32x4.extmul_high_i16x8_uâ€™

â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’

i32x4.abs
i32x4.neg
i32x4.all_true
i32x4.bitmask
i32x4.extadd_pairwise_i16x8_s
i32x4.extadd_pairwise_i16x8_u
i32x4.extend_low_i16x8_s
i32x4.extend_high_i16x8_s
i32x4.extend_low_i16x8_u
i32x4.extend_high_i16x8_u
i32x4.shl
i32x4.shr_s
i32x4.shr_u
i32x4.add
i32x4.sub
i32x4.mul
i32x4.min_s
i32x4.min_u
i32x4.max_s
i32x4.max_u
i32x4.dot_i16x8_s
i32x4.extmul_low_i16x8_s
i32x4.extmul_high_i16x8_s
i32x4.extmul_low_i16x8_u
i32x4.extmul_high_i16x8_u

229

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

230

|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|

â€˜i64x2.absâ€™
â€˜i64x2.negâ€™
â€˜i64x2.all_trueâ€™
â€˜i64x2.bitmaskâ€™
â€˜i64x2.extend_low_i32x4_sâ€™
â€˜i64x2.extend_high_i32x4_sâ€™
â€˜i64x2.extend_low_i32x4_uâ€™
â€˜i64x2.extend_high_i32x4_uâ€™
â€˜i64x2.shlâ€™
â€˜i64x2.shr_sâ€™
â€˜i64x2.shr_uâ€™
â€˜i64x2.addâ€™
â€˜i64x2.subâ€™
â€˜i64x2.mulâ€™
â€˜i64x2.extmul_low_i32x4_sâ€™
â€˜i64x2.extmul_high_i32x4_sâ€™
â€˜i64x2.extmul_low_i32x4_uâ€™
â€˜i64x2.extmul_high_i32x4_uâ€™

â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’

i64x2.abs
i64x2.neg
i64x2.all_true
i64x2.bitmask
i64x2.extend_low_i32x4_s
i64x2.extend_high_i32x4_s
i64x2.extend_low_i32x4_u
i64x2.extend_high_i32x4_u
i64x2.shl
i64x2.shr_s
i64x2.shr_u
i64x2.add
i64x2.sub
i64x2.mul
i64x2.extmul_low_i32x4_s
i64x2.extmul_high_i32x4_s
i64x2.extmul_low_i32x4_u
i64x2.extmul_high_i32x4_u

|
|
|
|
|
|
|
|
|
|
|
|
|
|
|

â€˜f32x4.absâ€™
â€˜f32x4.negâ€™
â€˜f32x4.sqrtâ€™
â€˜f32x4.ceilâ€™
â€˜f32x4.floorâ€™
â€˜f32x4.truncâ€™
â€˜f32x4.nearestâ€™
â€˜f32x4.addâ€™
â€˜f32x4.subâ€™
â€˜f32x4.mulâ€™
â€˜f32x4.divâ€™
â€˜f32x4.minâ€™
â€˜f32x4.maxâ€™
â€˜f32x4.pminâ€™
â€˜f32x4.pmaxâ€™

â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’

f32x4.abs
f32x4.neg
f32x4.sqrt
f32x4.ceil
f32x4.floor
f32x4.trunc
f32x4.nearest
f32x4.add
f32x4.sub
f32x4.mul
f32x4.div
f32x4.min
f32x4.max
f32x4.pmin
f32x4.pmax

|
|
|
|
|
|
|
|
|
|
|
|
|
|
|

â€˜f64x2.absâ€™
â€˜f64x2.negâ€™
â€˜f64x2.sqrtâ€™
â€˜f64x2.ceilâ€™
â€˜f64x2.floorâ€™
â€˜f64x2.truncâ€™
â€˜f64x2.nearestâ€™
â€˜f64x2.addâ€™
â€˜f64x2.subâ€™
â€˜f64x2.mulâ€™
â€˜f64x2.divâ€™
â€˜f64x2.minâ€™
â€˜f64x2.maxâ€™
â€˜f64x2.pminâ€™
â€˜f64x2.pmaxâ€™

â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’

f64x2.abs
f64x2.neg
f64x2.sqrt
f64x2.ceil
f64x2.floor
f64x2.trunc
f64x2.nearest
f64x2.add
f64x2.sub
f64x2.mul
f64x2.div
f64x2.min
f64x2.max
f64x2.pmin
f64x2.pmax

Chapter 6. Text Format

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

|
|
|
|
|
|
|
|
|
|

â€˜i32x4.trunc_sat_f32x4_sâ€™
â€˜i32x4.trunc_sat_f32x4_uâ€™
â€˜i32x4.trunc_sat_f64x2_s_zeroâ€™
â€˜i32x4.trunc_sat_f64x2_u_zeroâ€™
â€˜f32x4.convert_i32x4_sâ€™
â€˜f32x4.convert_i32x4_uâ€™
â€˜f64x2.convert_low_i32x4_sâ€™
â€˜f64x2.convert_low_i32x4_uâ€™
â€˜f32x4.demote_f64x2_zeroâ€™
â€˜f64x2.promote_low_f32x4â€™

|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|
|

â€˜i16x8.relaxed_swizzleâ€™
â€˜i32x4.relaxed_trunc_f32x4_sâ€™
â€˜i32x4.relaxed_trunc_f32x4_uâ€™
â€˜i32x4.relaxed_trunc_f32x4_s_zeroâ€™
â€˜i32x4.relaxed_trunc_f32x4_u_zeroâ€™
â€˜f32x4.relaxed_maddâ€™
â€˜f32x4.relaxed_nmaddâ€™
â€˜f64x2.relaxed_maddâ€™
â€˜f64x2.relaxed_nmaddâ€™
â€˜i8x16.relaxed_laneselectâ€™
â€˜i16x8.relaxed_laneselectâ€™
â€˜i32x4.relaxed_laneselectâ€™
â€˜i64x2.relaxed_laneselectâ€™
â€˜f32x4.relaxed_minâ€™
â€˜f32x4.relaxed_maxâ€™
â€˜f64x2.relaxed_minâ€™
â€˜f64x2.relaxed_maxâ€™
â€˜i16x8.relaxed_q15mulr_sâ€™
â€˜i16x8.relaxed_dot_i8x16_i7x16_sâ€™
â€˜i16x8.relaxed_dot_i8x16_i7x16_add_sâ€™

â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’

i32x4.trunc_sat_f32x4_s
i32x4.trunc_sat_f32x4_u
i32x4.trunc_sat_f64x2_s_zero
i32x4.trunc_sat_f64x2_u_zero
f32x4.convert_i32x4_s
f32x4.convert_i32x4_u
f64x2.convert_low_i32x4_s
f64x2.convert_low_i32x4_u
f32x4.demote_f64x2_zero
f64x2.promote_low_f32x4
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’

i16x8.relaxed_swizzle
i32x4.relaxed_trunc_f32x4_s
i32x4.relaxed_trunc_f32x4_u
i32x4.relaxed_trunc_f32x4_s_zero
i32x4.relaxed_trunc_f32x4_u_zero
f32x4.relaxed_madd
f32x4.relaxed_nmadd
f64x2.relaxed_madd
f64x2.relaxed_nmadd
i8x16.relaxed_laneselect
i16x8.relaxed_laneselect
i32x4.relaxed_laneselect
i64x2.relaxed_laneselect
f32x4.relaxed_min
f32x4.relaxed_max
f64x2.relaxed_min
f64x2.relaxed_max
i16x8.relaxed_q15mulr_s
i16x8.relaxed_dot_i8x16_i7x16_s
i16x8.relaxed_dot_i8x16_i7x16_add_s

6.5.10 Folded Instructions
Instructions can be written as S-expressions by grouping them into folded form. In that notation, an instruction is
wrapped in parentheses and optionally includes nested folded instructions to indicate its operands.
In the case of block instructions, the folded form omits the â€˜endâ€™ delimiter. For if instructions, both branches have
to be wrapped into nested S-expressions, headed by the keywords â€˜thenâ€™ and â€˜elseâ€™.
The set of all phrases defined by the following abbreviations recursively forms the auxiliary syntactic class
foldedinstr. Such a folded instruction can appear anywhere a regular instruction can.
â€˜(â€™ plaininstr foldedinstr* â€˜)â€™
â€˜(â€™ â€˜blockâ€™ label blocktype instr* â€˜)â€™
â€˜(â€™ â€˜loopâ€™ label blocktype instr* â€˜)â€™
â€˜(â€™ â€˜ifâ€™ label blocktype foldedinstr*
â€˜(â€™ â€˜thenâ€™ instr*1 â€˜)â€™ (â€˜(â€™ â€˜elseâ€™ instr*2 â€˜)â€™)? â€˜)â€™

â‰¡
â‰¡
â‰¡

foldedinstr* plaininstr
â€˜blockâ€™ label blocktype instr* â€˜endâ€™
â€˜loopâ€™ label blocktype instr* â€˜endâ€™

â‰¡

foldedinstr* â€˜ifâ€™ label blocktype instr*1
â€˜elseâ€™ (instr*2 )? â€˜endâ€™
â€˜try_tableâ€™ label blocktype
catch* instr* â€˜endâ€™

â€˜(â€™ â€˜try_tableâ€™ label blocktype catch* instr* â€˜)â€™ â‰¡

Ã² Note
For example, the instruction sequence
(local.get $x) (i32.const 2) i32.add (i32.const 3) i32.mul

6.5. Instructions

231

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

can be folded into
(i32.mul (i32.add (local.get $x) (i32.const 2)) (i32.const 3))
Folded instructions are solely syntactic sugar, no additional syntactic or type-based checking is implied.

6.5.11 Expressions
Expressions are written as instruction sequences. No explicit â€˜endâ€™ keyword is included, since they only occur in
bracketed positions.
exprğ¼

::=

(in:instrğ¼ )*

â‡’

in * end

6.6 Modules
6.6.1 Indices
Indices can be given either in raw numeric form or as symbolic identifiers when bound by a respective construct.
Such identifiers are looked up in the suitable space of the identifier context ğ¼.
typeidxğ¼
funcidxğ¼
tableidxğ¼
memidxğ¼
globalidxğ¼
tagidxğ¼
elemidxğ¼
dataidxğ¼
localidxğ¼
labelidxğ¼
fieldidxğ¼,ğ‘¥

::=
|
::=
|
::=
|
::=
|
::=
|
::=
|
::=
|
::=
|
::=
|
::=
|
::=
|

ğ‘¥:u32
ğ‘£:id
ğ‘¥:u32
ğ‘£:id
ğ‘¥:u32
ğ‘£:id
ğ‘¥:u32
ğ‘£:id
ğ‘¥:u32
ğ‘£:id
ğ‘¥:u32
ğ‘£:id
ğ‘¥:u32
ğ‘£:id
ğ‘¥:u32
ğ‘£:id
ğ‘¥:u32
ğ‘£:id
ğ‘™:u32
ğ‘£:id
ğ‘–:u32
ğ‘£:id

â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’
â‡’

ğ‘¥
ğ‘¥
ğ‘¥
ğ‘¥
ğ‘¥
ğ‘¥
ğ‘¥
ğ‘¥
ğ‘¥
ğ‘¥
ğ‘¥
ğ‘¥
ğ‘¥
ğ‘¥
ğ‘¥
ğ‘¥
ğ‘¥
ğ‘¥
ğ‘™
ğ‘™
ğ‘–
ğ‘–

(if ğ¼.types[ğ‘¥] = ğ‘£)
(if ğ¼.funcs[ğ‘¥] = ğ‘£)
(if ğ¼.tables[ğ‘¥] = ğ‘£)
(if ğ¼.mems[ğ‘¥] = ğ‘£)
(if ğ¼.globals[ğ‘¥] = ğ‘£)
(if ğ¼.tags[ğ‘¥] = ğ‘£)
(if ğ¼.elem[ğ‘¥] = ğ‘£)
(if ğ¼.data[ğ‘¥] = ğ‘£)
(if ğ¼.locals[ğ‘¥] = ğ‘£)
(if ğ¼.labels[ğ‘™] = ğ‘£)
(if ğ¼.fields[ğ‘¥][ğ‘–] = ğ‘£)

6.6.2 Type Uses
A type use is a reference to a function type definition. It may optionally be augmented by explicit inlined parameter
and result declarations. That allows binding symbolic identifiers to name the local indices of parameters. If inline
declarations are given, then their types must match the referenced function type.
typeuseğ¼

232

::=

â€˜(â€™ â€˜typeâ€™ ğ‘¥:typeidxğ¼ â€˜)â€™ â‡’ ğ‘¥, ğ¼ â€²
(if ğ¼.typedefs[ğ‘¥] = sub final (func [ğ‘¡ğ‘›1 ] â†’ [ğ‘¡*2 ]) âˆ§ ğ¼ â€² = {locals (ğœ–)ğ‘› })

|

â€˜(â€™ â€˜typeâ€™ ğ‘¥:typeidxğ¼ â€˜)â€™ (ğ‘¡1 :param)* (ğ‘¡2 :result)* â‡’ ğ‘¥, ğ¼ â€²
(if ğ¼.typedefs[ğ‘¥] = sub final (func [ğ‘¡*1 ] â†’ [ğ‘¡*2 ]) âˆ§ ğ¼ â€² = {locals id(param)* } well-formed)

Chapter 6. Text Format

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

Ã² Note
If inline declarations are given, their types must be syntactically equal to the types from the indexed definition;
possible type substitutions from other definitions that might make them equal are not taken into account. This
is to simplify syntactic pre-processing.
The synthesized attribute of a typeuse is a pair consisting of both the used type index and the local identifier
context containing possible parameter identifiers. The following auxiliary function extracts optional identifiers
from parameters:
id(â€˜(â€™ â€˜paramâ€™ id? . . . â€˜)â€™)

=

id?

Ã² Note
Both productions overlap for the case that the function type is [] â†’ []. However, in that case, they also produce
the same results, so that the choice is immaterial.
The well-formedness condition on ğ¼ â€² ensures that the parameters do not contain duplicate identifiers.
Abbreviations
A typeuse may also be replaced entirely by inline parameter and result declarations. In that case, a type index is
automatically inserted:
(ğ‘¡1 :param)* (ğ‘¡2 :result)*

â‰¡

â€˜(â€™ â€˜typeâ€™ ğ‘¥ â€˜)â€™ param* result*

where ğ‘¥ is the smallest existing type index whose recursive type definition in the current module is of the form
â€˜(â€™ â€˜recâ€™ â€˜(â€™ â€˜typeâ€™ â€˜(â€™ â€˜subâ€™ â€˜finalâ€™ â€˜(â€™ â€˜funcâ€™ param* result* â€˜)â€™ â€˜)â€™ â€˜)â€™ â€˜)â€™
If no such index exists, then a new recursive type of the same form is inserted at the end of the module.
Abbreviations are expanded in the order they appear, such that previously inserted type definitions are reused by
consecutive expansions.

6.6.3 Imports
The descriptors in imports can bind a symbolic function, table, memory, tag, or global identifier.
importğ¼

::= â€˜(â€™ â€˜importâ€™ mod :name nm:name ğ‘‘:importdescğ¼ â€˜)â€™
â‡’ {module mod , name nm, desc ğ‘‘}

importdescğ¼

::=
|
|
|
|

â€˜(â€™ â€˜funcâ€™ id? ğ‘¥, ğ¼ â€² :typeuseğ¼ â€˜)â€™
â€˜(â€™ â€˜tableâ€™ id? tt:tabletypeğ¼ â€˜)â€™
â€˜(â€™ â€˜memoryâ€™ id? mt:memtypeğ¼ â€˜)â€™
â€˜(â€™ â€˜globalâ€™ id? gt:globaltypeğ¼ â€˜)â€™
â€˜(â€™ â€˜tagâ€™ id? tt:tag â€˜)â€™

â‡’ func ğ‘¥
â‡’ table tt
â‡’ mem mt
â‡’ global gt
â‡’ tag tt

Abbreviations
As an abbreviation, imports may also be specified inline with function, table, memory, global, or tag definitions;
see the respective sections.

6.6.4 Functions
Function definitions can bind a symbolic function identifier, and local identifiers for its parameters and locals.
â€˜(â€™ â€˜funcâ€™ id? ğ‘¥, ğ¼ â€² :typeuseğ¼ (loc:localğ¼ )* (in:instrğ¼ â€²â€² )* â€˜)â€™
â‡’ {type ğ‘¥, locals loc * , body in * end}
(if ğ¼ â€²â€² = ğ¼ âŠ• ğ¼ â€² âŠ• {locals id(local)* } well-formed)

funcğ¼

::=

localğ¼

::= â€˜(â€™ â€˜localâ€™ id? ğ‘¡:valtypeğ¼ â€˜)â€™

6.6. Modules

â‡’

{type ğ‘¡}
233

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

The definition of the local identifier context ğ¼ â€²â€² uses the following auxiliary function to extract optional identifiers
from locals:
id(â€˜(â€™ â€˜localâ€™ id? . . . â€˜)â€™)

=

id?

Ã² Note
The well-formedness condition on ğ¼ â€²â€² ensures that parameters and locals do not contain duplicate identifiers.

Abbreviations
Multiple anonymous locals may be combined into a single declaration:
â€˜(â€™ â€˜localâ€™ valtype* â€˜)â€™ â‰¡

(â€˜(â€™ â€˜localâ€™ valtype â€˜)â€™)*

Functions can be defined as imports or exports inline:
â€˜(â€™ â€˜funcâ€™ id? â€˜(â€™ â€˜importâ€™ name1 name2 â€˜)â€™ typeuse â€˜)â€™ â‰¡
â€˜(â€™ â€˜importâ€™ name1 name2 â€˜(â€™ â€˜funcâ€™ id? typeuse â€˜)â€™ â€˜)â€™
â€˜(â€™ â€˜funcâ€™ id? â€˜(â€™ â€˜exportâ€™ name â€˜)â€™ . . . â€˜)â€™ â‰¡
â€˜(â€™ â€˜exportâ€™ name â€˜(â€™ â€˜funcâ€™ idâ€² â€˜)â€™ â€˜)â€™ â€˜(â€™ â€˜funcâ€™ idâ€² . . . â€˜)â€™
(if id? Ì¸= ğœ– âˆ§ idâ€² = id? âˆ¨ id? = ğœ– âˆ§ idâ€² fresh)

Ã² Note
The latter abbreviation can be applied repeatedly, if â€œ. . .â€ contains additional export clauses. Consequently, a
function declaration can contain any number of exports, possibly followed by an import.

6.6.5 Tables
Table definitions can bind a symbolic table identifier.
tableğ¼

::= â€˜(â€™ â€˜tableâ€™ id? tt:tabletypeğ¼ ğ‘’:exprğ¼ â€˜)â€™ â‡’

{type tt, init ğ‘’}

Abbreviations
A tableâ€™s initialization expression can be omitted, in which case it defaults to ref.null:
â€˜(â€™ â€˜tableâ€™ id? tabletype â€˜)â€™ â‰¡

â€˜(â€™ â€˜tableâ€™ id? tabletype â€˜(â€™ ref.null ht â€˜)â€™ â€˜)â€™
(if tabletype = limits â€˜(â€™ â€˜refâ€™ â€˜nullâ€™? ht â€˜)â€™)

An element segment can be given inline with a table definition, in which case its offset is 0 and the limits of the
table type are inferred from the length of the given segment:
â€˜(â€™ â€˜tableâ€™ id? addrtype? reftype â€˜(â€™ â€˜elemâ€™ expr ğ‘› :vec(elemexpr) â€˜)â€™ â€˜)â€™ â‰¡
â€˜(â€™ â€˜tableâ€™ idâ€² addrtype? ğ‘› ğ‘› reftype â€˜)â€™
â€˜(â€™ â€˜elemâ€™ â€˜(â€™ â€˜tableâ€™ idâ€² â€˜)â€™ â€˜(â€™ addrtypeâ€² â€˜.constâ€™ â€˜0â€™ â€˜)â€™ reftype vec(elemexpr) â€˜)â€™
(if id? Ì¸= ğœ– âˆ§ idâ€² = id? âˆ¨ id? = ğœ– âˆ§ idâ€² fresh,
if addrtype? Ì¸= ğœ– âˆ§ addrtypeâ€² = addrtype? âˆ¨ addrtype? = ğœ– âˆ§ addrtypeâ€² = â€˜i32â€™)
â€˜(â€™ â€˜tableâ€™ id? addrtype? reftype â€˜(â€™ â€˜elemâ€™ ğ‘¥ğ‘› :vec(funcidx) â€˜)â€™ â€˜)â€™ â‰¡
â€˜(â€™ â€˜tableâ€™ idâ€² addrtype? ğ‘› ğ‘› reftype â€˜)â€™
â€˜(â€™ â€˜elemâ€™ â€˜(â€™ â€˜tableâ€™ idâ€² â€˜)â€™ â€˜(â€™ addrtypeâ€² â€˜.constâ€™ â€˜0â€™ â€˜)â€™ reftype vec(â€˜(â€™ â€˜ref.funcâ€™ funcidx â€˜)â€™) â€˜)â€™
(if id? Ì¸= ğœ– âˆ§ idâ€² = id? âˆ¨ id? = ğœ– âˆ§ idâ€² fresh,
if addrtype? Ì¸= ğœ– âˆ§ addrtypeâ€² = addrtype? âˆ¨ addrtype? = ğœ– âˆ§ addrtypeâ€² = â€˜i32â€™)
234

Chapter 6. Text Format

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

Tables can be defined as imports or exports inline:
â€˜(â€™ â€˜tableâ€™ id? â€˜(â€™ â€˜importâ€™ name1 name2 â€˜)â€™ tabletype â€˜)â€™ â‰¡
â€˜(â€™ â€˜importâ€™ name1 name2 â€˜(â€™ â€˜tableâ€™ id? tabletype â€˜)â€™ â€˜)â€™
â€˜(â€™ â€˜tableâ€™ id? â€˜(â€™ â€˜exportâ€™ name â€˜)â€™ . . . â€˜)â€™ â‰¡
â€˜(â€™ â€˜exportâ€™ name â€˜(â€™ â€˜tableâ€™ idâ€² â€˜)â€™ â€˜)â€™ â€˜(â€™ â€˜tableâ€™ idâ€² . . . â€˜)â€™
(if id? Ì¸= ğœ– âˆ§ idâ€² = id? âˆ¨ id? = ğœ– âˆ§ idâ€² fresh)

Ã² Note
The latter abbreviation can be applied repeatedly, if â€œ. . .â€ contains additional export clauses. Consequently, a
table declaration can contain any number of exports, possibly followed by an import.

6.6.6 Memories
Memory definitions can bind a symbolic memory identifier.
memğ¼

::= â€˜(â€™ â€˜memoryâ€™ id? mt:memtypeğ¼ â€˜)â€™

â‡’

{type mt}

Abbreviations
A data segment can be given inline with a memory definition, in which case its offset is 0 and the limits of the
memory type are inferred from the length of the data, rounded up to page size:
â€˜(â€™ â€˜memoryâ€™ id? addrtype? â€˜(â€™ â€˜dataâ€™ ğ‘ğ‘› :datastring â€˜)â€™ â€˜)â€™ â‰¡
â€˜(â€™ â€˜memoryâ€™ idâ€² addrtype? ğ‘š ğ‘š â€˜)â€™
â€˜(â€™ â€˜dataâ€™ â€˜(â€™ â€˜memoryâ€™ idâ€² â€˜)â€™ â€˜(â€™ addrtypeâ€² â€˜.constâ€™ â€˜0â€™ â€˜)â€™ datastring â€˜)â€™
(if id? Ì¸= ğœ– âˆ§ idâ€² = id? âˆ¨ id? = ğœ– âˆ§ idâ€² fresh,
if addrtype? Ì¸= ğœ– âˆ§ addrtypeâ€² = addrtype? âˆ¨ addrtype? = ğœ– âˆ§ addrtypeâ€² = â€˜i32â€™,
ğ‘š = ceil(ğ‘›/64 Ki))
Memories can be defined as imports or exports inline:
â€˜(â€™ â€˜memoryâ€™ id? â€˜(â€™ â€˜importâ€™ name1 name2 â€˜)â€™ memtype â€˜)â€™ â‰¡
â€˜(â€™ â€˜importâ€™ name1 name2 â€˜(â€™ â€˜memoryâ€™ id? memtype â€˜)â€™ â€˜)â€™
â€˜(â€™ â€˜memoryâ€™ id? â€˜(â€™ â€˜exportâ€™ name â€˜)â€™ . . . â€˜)â€™ â‰¡
â€˜(â€™ â€˜exportâ€™ name â€˜(â€™ â€˜memoryâ€™ idâ€² â€˜)â€™ â€˜)â€™ â€˜(â€™ â€˜memoryâ€™ idâ€² . . . â€˜)â€™
(if id? Ì¸= ğœ– âˆ§ idâ€² = id? âˆ¨ id? = ğœ– âˆ§ idâ€² fresh)

Ã² Note
The latter abbreviation can be applied repeatedly, if â€œ. . .â€ contains additional export clauses. Consequently, a
memory declaration can contain any number of exports, possibly followed by an import.

6.6.7 Globals
Global definitions can bind a symbolic global identifier.
globalğ¼

6.6. Modules

::=

â€˜(â€™ â€˜globalâ€™ id? gt:globaltypeğ¼ ğ‘’:exprğ¼ â€˜)â€™ â‡’

{type gt, init ğ‘’}

235

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

Abbreviations
Globals can be defined as imports or exports inline:
â€˜(â€™ â€˜globalâ€™ id? â€˜(â€™ â€˜importâ€™ name1 name2 â€˜)â€™ globaltype â€˜)â€™ â‰¡
â€˜(â€™ â€˜importâ€™ name1 name2 â€˜(â€™ â€˜globalâ€™ id? globaltype â€˜)â€™ â€˜)â€™
â€˜(â€™ â€˜globalâ€™ id? â€˜(â€™ â€˜exportâ€™ name â€˜)â€™ . . . â€˜)â€™ â‰¡
â€˜(â€™ â€˜exportâ€™ name â€˜(â€™ â€˜globalâ€™ idâ€² â€˜)â€™ â€˜)â€™ â€˜(â€™ â€˜globalâ€™ idâ€² . . . â€˜)â€™
(if id? Ì¸= ğœ– âˆ§ idâ€² = id? âˆ¨ id? = ğœ– âˆ§ idâ€² fresh)

Ã² Note
The latter abbreviation can be applied repeatedly, if â€œ. . .â€ contains additional export clauses. Consequently, a
global declaration can contain any number of exports, possibly followed by an import.

6.6.8 Tags
An tag definition can bind a symbolic tag identifier.
tagğ¼

::= â€˜(â€™ â€˜tagâ€™ id? ğ‘¥, ğ¼ â€² :typeuseğ¼ â€˜)â€™
â‡’ {type ğ‘¥}

Abbreviations
Tags can be defined as imports or exports inline:
â€˜(â€™ â€˜tagâ€™ id? â€˜(â€™ â€˜importâ€™ name1 name2 â€˜)â€™ typeuse â€˜)â€™ â‰¡
â€˜(â€™ â€˜importâ€™ name1 name2 â€˜(â€™ â€˜tagâ€™ id? typeuse â€˜)â€™ â€˜)â€™
â€˜(â€™ â€˜tagâ€™ id? â€˜(â€™ â€˜exportâ€™ name â€˜)â€™ . . . â€˜)â€™ â‰¡
â€˜(â€™ â€˜exportâ€™ name â€˜(â€™ â€˜tagâ€™ idâ€² â€˜)â€™ â€˜)â€™ â€˜(â€™ â€˜tagâ€™ idâ€² . . . â€˜)â€™
(if id? Ì¸= ğœ– âˆ§ idâ€² = id? âˆ¨ id? = ğœ– âˆ§ idâ€² fresh)

Ã² Note
The latter abbreviation can be applied repeatedly, if â€œ. . .â€ contains additional export clauses. Consequently, a
memory declaration can contain any number of exports, possibly followed by an import.

6.6.9 Exports
The syntax for exports mirrors their abstract syntax directly.
exportğ¼
exportdescğ¼

::=
::=
|
|
|
|

â€˜(â€™ â€˜exportâ€™ nm:name ğ‘‘:exportdescğ¼ â€˜)â€™
â€˜(â€™ â€˜funcâ€™ ğ‘¥:funcidxğ¼ â€˜)â€™
â€˜(â€™ â€˜tableâ€™ ğ‘¥:tableidxğ¼ â€˜)â€™
â€˜(â€™ â€˜memoryâ€™ ğ‘¥:memidxğ¼ â€˜)â€™
â€˜(â€™ â€˜globalâ€™ ğ‘¥:globalidxğ¼ â€˜)â€™
â€˜(â€™ â€˜tagâ€™ ğ‘¥:tagidxğ¼ â€˜)â€™

â‡’
â‡’
â‡’
â‡’
â‡’
â‡’

{name nm, desc ğ‘‘}
func ğ‘¥
table ğ‘¥
mem ğ‘¥
global ğ‘¥
tag ğ‘¥

Abbreviations
As an abbreviation, exports may also be specified inline with function, table, memory, global, or tag definitions;
see the respective sections.

236

Chapter 6. Text Format

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

6.6.10 Start Function
A start function is defined in terms of its index.
::= â€˜(â€™ â€˜startâ€™ ğ‘¥:funcidxğ¼ â€˜)â€™ â‡’

startğ¼

{func ğ‘¥}

Ã² Note
At most one start function may occur in a module, which is ensured by a suitable side condition on the module
grammar.

6.6.11 Element Segments
Element segments allow for an optional table index to identify the table to initialize.
elemğ¼

elemlistğ¼
elemexprğ¼
tableuseğ¼

::= â€˜(â€™ â€˜elemâ€™ id? (ğ‘’ğ‘¡, ğ‘¦ * ):elemlistğ¼ â€˜)â€™
â‡’ {type ğ‘’ğ‘¡, init ğ‘¦ * , mode passive}
|
â€˜(â€™ â€˜elemâ€™ id? ğ‘¥:tableuseğ¼ â€˜(â€™ â€˜offsetâ€™ ğ‘’:exprğ¼ â€˜)â€™ (ğ‘’ğ‘¡, ğ‘¦ * ):elemlistğ¼ â€˜)â€™
â‡’ {type ğ‘’ğ‘¡, init ğ‘¦ * , mode active {table ğ‘¥, offset ğ‘’}}
â€˜(â€™ â€˜elemâ€™ id? â€˜declareâ€™ (ğ‘’ğ‘¡, ğ‘¦ * ):elemlistğ¼ â€˜)â€™
â‡’ {type ğ‘’ğ‘¡, init ğ‘¦ * , mode declarative}
::= ğ‘¡:reftypeğ¼ ğ‘¦ * :vec(elemexprğ¼ )
â‡’ (type ğ‘¡, init ğ‘¦ * )
::= â€˜(â€™ â€˜itemâ€™ ğ‘’:exprğ¼ â€˜)â€™ â‡’ ğ‘’
::= â€˜(â€™ â€˜tableâ€™ ğ‘¥:tableidxğ¼ â€˜)â€™ â‡’ ğ‘¥

Abbreviations
As an abbreviation, a single instruction may occur in place of the offset of an active element segment or as an
element expression:
â€˜(â€™ instr â€˜)â€™
â€˜(â€™ instr â€˜)â€™

â‰¡ â€˜(â€™ â€˜offsetâ€™ instr â€˜)â€™
â‰¡ â€˜(â€™ â€˜itemâ€™ instr â€˜)â€™

Also, the element list may be written as just a sequence of function indices:
â€˜funcâ€™ vec(funcidxğ¼ ) â‰¡ â€˜(refâ€™ â€˜func)â€™ vec(â€˜(â€™ â€˜ref.funcâ€™ funcidxğ¼ â€˜)â€™)
A table use can be omitted, defaulting to 0. Furthermore, for backwards compatibility with earlier versions of
WebAssembly, if the table use is omitted, the â€˜funcâ€™ keyword can be omitted as well.
ğœ–
â€˜(â€™ â€˜elemâ€™ id? â€˜(â€™ â€˜offsetâ€™ exprğ¼ â€˜)â€™
vec(funcidxğ¼ ) â€˜)â€™

â‰¡ â€˜(â€™ â€˜tableâ€™ â€˜0â€™ â€˜)â€™
â‰¡ â€˜(â€™ â€˜elemâ€™ id? â€˜(â€™ â€˜tableâ€™ â€˜0â€™ â€˜)â€™ â€˜(â€™ â€˜offsetâ€™ exprğ¼ â€˜)â€™
â€˜funcâ€™ vec(funcidxğ¼ ) â€˜)â€™

As another abbreviation, element segments may also be specified inline with table definitions; see the respective
section.

6.6.12 Data Segments
Data segments allow for an optional memory index to identify the memory to initialize. The data is written as a
string, which may be split up into a possibly empty sequence of individual string literals.
::= â€˜(â€™ â€˜dataâ€™ id? ğ‘* :datastring â€˜)â€™
â‡’ {init ğ‘* , mode passive}
|
â€˜(â€™ â€˜dataâ€™ id? ğ‘¥:memuseğ¼ â€˜(â€™ â€˜offsetâ€™ ğ‘’:exprğ¼ â€˜)â€™ ğ‘* :datastring â€˜)â€™
â‡’ {init ğ‘* , mode active {memory ğ‘¥, offset ğ‘’}}
*
datastring ::= (ğ‘ :string)* â‡’ concat((ğ‘* )* )
memuseğ¼
::= â€˜(â€™ â€˜memoryâ€™ ğ‘¥:memidxğ¼ â€˜)â€™ â‡’ ğ‘¥

datağ¼

6.6. Modules

237

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

Ã² Note
In the current version of WebAssembly, the only valid memory index is 0 or a symbolic memory identifier
resolving to the same value.
Abbreviations
As an abbreviation, a single instruction may occur in place of the offset of an active data segment:
â€˜(â€™ instr â€˜)â€™ â‰¡

â€˜(â€™ â€˜offsetâ€™ instr â€˜)â€™

Also, a memory use can be omitted, defaulting to 0.
ğœ–

â‰¡ â€˜(â€™ â€˜memoryâ€™ â€˜0â€™ â€˜)â€™

As another abbreviation, data segments may also be specified inline with memory definitions; see the respective
section.

6.6.13 Modules
A module consists of a sequence of fields that can occur in any order. All definitions and their respective bound
identifiers scope over the entire module, including the text preceding them.
A module may optionally bind an identifier that names the module. The name serves a documentary role only.
Ã² Note
Tools may include the module name in the name section of the binary format.

module
modulefieldğ¼

::= â€˜(â€™ â€˜moduleâ€™â¨ï¸€
id? (ğ‘š:modulefieldğ¼ )* â€˜)â€™ â‡’
(if ğ¼ =
idc(modulefield)* well-formed)
*
::= ty :rectypeğ¼ â‡’ {types ty * }
|
im:importğ¼
â‡’ {imports im}
|
fn:funcğ¼
â‡’ {funcs fn}
|
ta:tableğ¼
â‡’ {tables ta}
|
me:memğ¼
â‡’ {mems me}
|
gl :globalğ¼
â‡’ {globals gl }
|
tg:tagğ¼
â‡’ {tags tg}
|
el :elemğ¼
â‡’ {elems el }
|
da:datağ¼
â‡’ {datas da}
|
st:startğ¼
â‡’ {start st}
|
ex :exportğ¼
â‡’ {exports ex }

â¨ï¸€

ğ‘š*

The following restrictions are imposed on the composition of modules: ğ‘š1 âŠ• ğ‘š2 is defined if and only if
â€¢ ğ‘š1 .start = ğœ– âˆ¨ ğ‘š2 .start = ğœ–
â€¢ ğ‘š1 .funcs = ğ‘š1 .tables = ğ‘š1 .mems = ğ‘š1 .globals = ğ‘š1 .tags = ğœ– âˆ¨ ğ‘š2 .imports = ğœ–
Ã² Note
The first condition ensures that there is at most one start function. The second condition enforces that all imports
must occur before any regular definition of a function, table, memory, global, or tag, thereby maintaining the
ordering of the respective index spaces.
The well-formedness condition on ğ¼ in the grammar for module ensures that no namespace contains duplicate
identifiers.

238

Chapter 6. Text Format

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

The definition of the initial identifier context ğ¼ uses the following auxiliary definition which maps each relevant
definition to a singular context with one (possibly empty) identifier:
â¨ï¸€
idc(â€˜(â€™ â€˜recâ€™ typedef* â€˜)â€™)
=
idc(typedef)*
?
?
idc(â€˜(â€™ â€˜typeâ€™ ğ‘£ :id subtype â€˜)â€™)
= {types (ğ‘£ ? ), fields idf(subtype), typedefs st}
?
?
idc(â€˜(â€™ â€˜funcâ€™ ğ‘£ :id . . . â€˜)â€™)
= {funcs (ğ‘£ ? )}
?
?
idc(â€˜(â€™ â€˜tableâ€™ ğ‘£ :id . . . â€˜)â€™)
= {tables (ğ‘£ ? )}
?
?
idc(â€˜(â€™ â€˜memoryâ€™ ğ‘£ :id . . . â€˜)â€™)
= {mems (ğ‘£ ? )}
idc(â€˜(â€™ â€˜globalâ€™ ğ‘£ ? :id? . . . â€˜)â€™)
= {globals (ğ‘£ ? )}
idc(â€˜(â€™ â€˜tagâ€™ ğ‘£ ? :id? . . . â€˜)â€™)
= {tags (ğ‘£ ? )}
idc(â€˜(â€™ â€˜elemâ€™ ğ‘£ ? :id? . . . â€˜)â€™)
= {elem (ğ‘£ ? )}
idc(â€˜(â€™ â€˜dataâ€™ ğ‘£ ? :id? . . . â€˜)â€™)
= {data (ğ‘£ ? )}
idc(â€˜(â€™ â€˜importâ€™ . . . â€˜(â€™ â€˜funcâ€™ ğ‘£ ? :id? . . . â€˜)â€™ â€˜)â€™)
= {funcs (ğ‘£ ? )}
idc(â€˜(â€™ â€˜importâ€™ . . . â€˜(â€™ â€˜tableâ€™ ğ‘£ ? :id? . . . â€˜)â€™ â€˜)â€™)
= {tables (ğ‘£ ? )}
idc(â€˜(â€™ â€˜importâ€™ . . . â€˜(â€™ â€˜memoryâ€™ ğ‘£ ? :id? . . . â€˜)â€™ â€˜)â€™) = {mems (ğ‘£ ? )}
idc(â€˜(â€™ â€˜importâ€™ . . . â€˜(â€™ â€˜globalâ€™ ğ‘£ ? :id? . . . â€˜)â€™ â€˜)â€™) = {globals (ğ‘£ ? )}
idc(â€˜(â€™ . . . â€˜)â€™)
= {}
idf(â€˜(â€™ â€˜subâ€™ . . . comptype â€˜)â€™)
idf(â€˜(â€™ â€˜structâ€™ Tfield * â€˜)â€™)
idf(â€˜(â€™ â€˜arrayâ€™ . . . â€˜)â€™)
idf(â€˜(â€™ â€˜funcâ€™ . . . â€˜)â€™)
idf(â€˜(â€™ â€˜fieldâ€™ ğ‘£ ? :id? . . . â€˜)â€™)

=
=
=
=
=

idf(comptype)
â¨ï¸€
idf(field)*
ğœ–
ğœ–
ğ‘£?

Abbreviations
In a source file, the toplevel (module . . . ) surrounding the module body may be omitted.
modulefield*

6.6. Modules

â‰¡

â€˜(â€™ â€˜moduleâ€™ modulefield* â€˜)â€™

239

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

240

Chapter 6. Text Format

CHAPTER

7

Appendix

7.1 Embedding
A WebAssembly implementation will typically be embedded into a host environment. An embedder implements
the connection between such a host environment and the WebAssembly semantics as defined in the main body of
this specification. An embedder is expected to interact with the semantics in well-defined ways.
This section defines a suitable interface to the WebAssembly semantics in the form of entry points through which
an embedder can access it. The interface is intended to be complete, in the sense that an embedder does not need
to reference other functional parts of the WebAssembly specification directly.
Ã² Note
On the other hand, an embedder does not need to provide the host environment with access to all functionality
defined in this interface. For example, an implementation may not support parsing of the text format.

7.1.1 Types
In the description of the embedder interface, syntactic classes from the abstract syntax and the runtimeâ€™s abstract
machine are used as names for variables that range over the possible objects from that class. Hence, these syntactic
classes can also be interpreted as types.
For numeric parameters, notation like ğ‘– : u64 is used to specify a symbolic name in addition to the respective value
range.

7.1.2 Booleans
Interface operation that are predicates return Boolean values:
bool

::= false | true

7.1.3 Exceptions and Errors
Invoking an exported function may throw or propagate exceptions, expressed by an auxiliary syntactic class:
exception

::=

THROW exnaddr

The exception address ğ‘’ğ‘¥ğ‘›ğ‘ğ‘‘ğ‘‘ğ‘Ÿ identifies the exception thrown.
241

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

Failure of an interface operation is also indicated by an auxiliary syntactic class:
error

::=

error

In addition to the error conditions specified explicitly in this section, such as invalid arguments or exceptions and
traps resulting from execution, implementations may also return errors when specific implementation limitations
are reached.
Ã² Note
Errors are abstract and unspecific with this definition. Implementations can refine it to carry suitable classifications and diagnostic messages.

7.1.4 Pre- and Post-Conditions
Some operations state pre-conditions about their arguments or post-conditions about their results. It is the embedderâ€™s responsibility to meet the pre-conditions. If it does, the post conditions are guaranteed by the semantics.
In addition to pre- and post-conditions explicitly stated with each operation, the specification adopts the following
conventions for runtime objects (store, moduleinst, externval , addresses):
â€¢ Every runtime object passed as a parameter must be valid per an implicit pre-condition.
â€¢ Every runtime object returned as a result is valid per an implicit post-condition.
Ã² Note
As long as an embedder treats runtime objects as abstract and only creates and manipulates them through the
interface defined here, all implicit pre-conditions are automatically met.

7.1.5 Store
store_init() : store
1. Return the empty store.
store_init()

= {}

7.1.6 Modules
module_decode(byte * ) : module | error
1. If there exists a derivation for the byte sequence byte * as a module according to the binary grammar for
modules, yielding a module ğ‘š, then return ğ‘š.
2. Else, return error.
module_decode(ğ‘* ) = ğ‘š
module_decode(ğ‘* ) = error

*

(if module =â‡’ ğ‘š:ğ‘* )
(otherwise)

module_parse(char * ) : module | error
1. If there exists a derivation for the source char * as a module according to the text grammar for modules,
yielding a module ğ‘š, then return ğ‘š.
2. Else, return error.
module_parse(ğ‘* )
module_parse(ğ‘* )

242

= ğ‘š
= error

*

(if module =â‡’ ğ‘š:ğ‘* )
(otherwise)

Chapter 7. Appendix

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

module_validate(module) : error ?
1. If module is valid, then return nothing.
2. Else, return error.
module_validate(ğ‘š) = ğœ–
module_validate(ğ‘š) = error

*

(if âŠ¢ ğ‘š : externtype * â†’ externtype â€² )
(otherwise)

module_instantiate(store, module, externval * ) : (store, moduleinst | exception | error )
1. Try instantiating module in store with external values externval * as imports:
a. If it succeeds with a module instance moduleinst, then let result be moduleinst.
b. Else, let result be error.
2. Return the new store paired with result.
module_instantiate(ğ‘†, ğ‘š, ev * )
module_instantiate(ğ‘†, ğ‘š, ev * )

=
=

(ğ‘† â€² , ğ¹.module)
(ğ‘† â€² , error)

(if instantiate(ğ‘†, ğ‘š, ev * ) Ë“â†’ * ğ‘† â€² ; ğ¹ ; ğœ–)
(otherwise, if instantiate(ğ‘†, ğ‘š, ev * ) Ë“â†’ * ğ‘† â€² ; ğ¹ ; result)

Ã² Note
The store may be modified even in case of an error.

module_imports(module) : (name, name, externtype)*
1. Pre-condition: module is valid with the external import types externtype * and external export types
*
externtype â€² .
2. Let import * be the imports module.imports.
3. Assert: the length of import * equals the length of externtype * .
4. For each import ğ‘– in import * and corresponding externtype ğ‘– in externtype * , do:
a. Let result ğ‘– be the triple (import ğ‘– .module, import ğ‘– .name, externtype ğ‘– ).
5. Return the concatenation of all result ğ‘– , in index order.
6. Post-condition: each externtype ğ‘– is valid under the empty context.
module_imports(ğ‘š)

=

(im.module, im.name, externtype)*
*
(if im * = ğ‘š.imports âˆ§ âŠ¢ ğ‘š : externtype * â†’ externtype â€² )

module_exports(module) : (name, externtype)*
1. Pre-condition: module is valid with the external import types externtype * and external export types
*
externtype â€² .
2. Let export * be the exports module.exports.
*

3. Assert: the length of export * equals the length of externtype â€² .
*

4. For each export ğ‘– in export * and corresponding externtype â€²ğ‘– in externtype â€² , do:
a. Let result ğ‘– be the pair (export ğ‘– .name, externtype â€²ğ‘– ).
5. Return the concatenation of all result ğ‘– , in index order.
6. Post-condition: each externtype â€²ğ‘– is valid under the empty context.

7.1. Embedding

243

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

module_exports(ğ‘š)

(ex .name, externtype â€² )*
*
(if ex * = ğ‘š.exports âˆ§ âŠ¢ ğ‘š : externtype * â†’ externtype â€² )

=

7.1.7 Module Instances
instance_export(moduleinst, name) : externval | error
1. Assert: due to validity of the module instance moduleinst, all its export names are different.
2. If there exists an exportinst ğ‘– in moduleinst.exports such that name exportinst ğ‘– .name equals name, then:
a. Return the external value exportinst ğ‘– .value.
3. Else, return error.
instance_export(ğ‘š, name) = ğ‘š.exports[ğ‘–].value
instance_export(ğ‘š, name) = error

(if ğ‘š.exports[ğ‘–].name = name)
(otherwise)

7.1.8 Functions
func_alloc(store, functype, hostfunc) : (store, funcaddr )
1. Pre-condition: the functype is valid under the empty context.
2. Let funcaddr be the result of allocating a host function in store with function type functype and host function
code hostfunc.
3. Return the new store paired with funcaddr .
func_alloc(ğ‘†, ta, code)

=

(ğ‘† â€² , a)

(if allochostfunc(ğ‘†, ta, code) = ğ‘† â€² , a)

Ã² Note
This operation assumes that hostfunc satisfies the pre- and post-conditions required for a function instance
with type functype.
Regular (non-host) function instances can only be created indirectly through module instantiation.
func_type(store, funcaddr ) : functype
1. Let functype be the function type ğ‘†.funcs[ğ‘].type.
2. Return functype.
3. Post-condition: the returned function type is valid.
func_type(ğ‘†, ğ‘)

= ğ‘†.funcs[ğ‘].type

func_invoke(store, funcaddr , val * ) : (store, val * | exception | error )
1. Try invoking the function funcaddr in store with values val * as arguments:
*

*

a. If it succeeds with values val â€² as results, then let result be val â€² .
b. Else if the outcome is an exception with a thrown exception ref.exn exnaddr as the result, then let result be
THROW exnaddr
c. Else it has trapped, hence let result be error.
2. Return the new store paired with result.
244

Chapter 7. Appendix

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

*

*

func_invoke(ğ‘†, ğ‘, ğ‘£ * ) = (ğ‘† â€² , ğ‘£ â€² )
func_invoke(ğ‘†, ğ‘, ğ‘£ * ) = (ğ‘† â€² , THROW ğ‘â€² )
func_invoke(ğ‘†, ğ‘, ğ‘£ * ) = (ğ‘† â€² , error)

(if invoke(ğ‘†, ğ‘, ğ‘£ * ) Ë“â†’ * ğ‘† â€² ; ğ¹ ; ğ‘£ â€² )
(if invoke(ğ‘†, ğ‘, ğ‘£ * ) Ë“â†’ * ğ‘† â€² ; ğ¹ ; ğ‘‡ [(ref.exn ğ‘â€² ) throw_ref]
(if invoke(ğ‘†, ğ‘, ğ‘£ * ) Ë“â†’ * ğ‘† â€² ; ğ¹ ; trap)

Ã² Note
The store may be modified even in case of an error.

7.1.9 Tables
table_alloc(store, tabletype, ref ) : (store, tableaddr )
1. Pre-condition: the tabletype is valid under the empty context.
2. Let tableaddr be the result of allocating a table in store with table type tabletype and initialization value
ref .
3. Return the new store paired with tableaddr .
table_alloc(ğ‘†, tt, ğ‘Ÿ)

(ğ‘† â€² , a)

=

(if alloctable(ğ‘†, tt, ğ‘Ÿ) = ğ‘† â€² , a)

table_type(store, tableaddr ) : tabletype
1. Return ğ‘†.tables[ğ‘].type.
2. Post-condition: the returned table type is valid under the empty context.
table_type(ğ‘†, ğ‘)

= ğ‘†.tables[ğ‘].type

table_read(store, tableaddr , ğ‘– : u64 ) : ref | error
1. Let ti be the table instance store.tables[tableaddr ].
2. If ğ‘– is larger than or equal to the length of ti .elem, then return error.
3. Else, return the reference value ti .elem[ğ‘–].
table_read(ğ‘†, ğ‘, ğ‘–)
table_read(ğ‘†, ğ‘, ğ‘–)

= ğ‘Ÿ
= error

(if ğ‘†.tables[ğ‘].elem[ğ‘–] = ğ‘Ÿ)
(otherwise)

table_write(store, tableaddr , ğ‘– : u64 , ref ) : store | error
1. Let ti be the table instance store.tables[tableaddr ].
2. If ğ‘– is larger than or equal to the length of ti .elem, then return error.
3. Replace ti .elem[ğ‘–] with the reference value ref .
4. Return the updated store.
table_write(ğ‘†, ğ‘, ğ‘–, ğ‘Ÿ)
table_write(ğ‘†, ğ‘, ğ‘–, ğ‘Ÿ)

= ğ‘†â€²
= error

(if ğ‘† â€² = ğ‘† with tables[ğ‘].elem[ğ‘–] = ğ‘Ÿ)
(otherwise)

table_size(store, tableaddr ) : u64
1. Return the length of store.tables[tableaddr ].elem.
table_size(ğ‘†, ğ‘)

7.1. Embedding

=

ğ‘›

(if |ğ‘†.tables[ğ‘].elem| = ğ‘›)

245

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

table_grow(store, tableaddr , ğ‘› : u64 , ref ) : store | error
1. Try growing the table instance store.tables[tableaddr ] by ğ‘› elements with initialization value ref :
a. If it succeeds, return the updated store.
b. Else, return error.
table_grow(ğ‘†, ğ‘, ğ‘›, ğ‘Ÿ) =
table_grow(ğ‘†, ğ‘, ğ‘›, ğ‘Ÿ) =

(if ğ‘† â€² = ğ‘† with tables[ğ‘] = growtable(ğ‘†.tables[ğ‘], ğ‘›, ğ‘Ÿ))
(otherwise)

ğ‘†â€²
error

7.1.10 Memories
mem_alloc(store, memtype) : (store, memaddr )
1. Pre-condition: the memtype is valid under the empty context.
2. Let memaddr be the result of allocating a memory in store with memory type memtype.
3. Return the new store paired with memaddr .
mem_alloc(ğ‘†, mt)

=

(ğ‘† â€² , a)

(if allocmem(ğ‘†, mt) = ğ‘† â€² , a)

mem_type(store, memaddr ) : memtype
1. Return ğ‘†.mems[ğ‘].type.
2. Post-condition: the returned memory type is valid under the empty context.
mem_type(ğ‘†, ğ‘)

= ğ‘†.mems[ğ‘].type

mem_read(store, memaddr , ğ‘– : u64 ) : byte | error
1. Let mi be the memory instance store.mems[memaddr ].
2. If ğ‘– is larger than or equal to the length of mi .data, then return error.
3. Else, return the byte mi .data[ğ‘–].
mem_read(ğ‘†, ğ‘, ğ‘–) = ğ‘
mem_read(ğ‘†, ğ‘, ğ‘–) = error

(if ğ‘†.mems[ğ‘].data[ğ‘–] = ğ‘)
(otherwise)

mem_write(store, memaddr , ğ‘– : u64 , byte) : store | error
1. Let mi be the memory instance store.mems[memaddr ].
2. If ğ‘– is larger than or equal to the length of mi .data, then return error.
3. Replace mi .data[ğ‘–] with byte.
4. Return the updated store.
mem_write(ğ‘†, ğ‘, ğ‘–, ğ‘)
mem_write(ğ‘†, ğ‘, ğ‘–, ğ‘)

= ğ‘†â€²
= error

(if ğ‘† â€² = ğ‘† with mems[ğ‘].data[ğ‘–] = ğ‘)
(otherwise)

mem_size(store, memaddr ) : u64
1. Return the length of store.mems[memaddr ].data divided by the page size.
mem_size(ğ‘†, ğ‘)

246

=

ğ‘›

(if |ğ‘†.mems[ğ‘].data| = ğ‘› Â· 64 Ki)

Chapter 7. Appendix

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

mem_grow(store, memaddr , ğ‘› : u64 ) : store | error
1. Try growing the memory instance store.mems[memaddr ] by ğ‘› pages:
a. If it succeeds, return the updated store.
b. Else, return error.
mem_grow(ğ‘†, ğ‘, ğ‘›) =
mem_grow(ğ‘†, ğ‘, ğ‘›) =

(if ğ‘† â€² = ğ‘† with mems[ğ‘] = growmem(ğ‘†.mems[ğ‘], ğ‘›))
(otherwise)

ğ‘†â€²
error

7.1.11 Tags
tag_alloc(store, tagtype) : (store, tagaddr )
1. Pre-condition: ğ‘¡ğ‘ğ‘”ğ‘¡ğ‘¦ğ‘ğ‘’ is valid.
2. Let tagaddr be the result of allocating a tag in store with tag type tagtype.
3. Return the new store paired with tagaddr .
tag_alloc(ğ‘†, tt)

=

(ğ‘† â€² , a)

(if alloctag(ğ‘†, tt) = ğ‘† â€² , a)

tag_type(store, tagaddr ) : tagtype
1. Return ğ‘†.tags[ğ‘].type.
2. Post-condition: the returned tag type is valid.
tag_type(ğ‘†, ğ‘)

= ğ‘†.tags[ğ‘].type

7.1.12 Exceptions
exn_alloc(store, tagaddr , val * ) : (store, exnaddr )
1. Pre-condition: tagaddr is an allocated tag address.
2. Let exnaddr be the result of allocating an exception instance in store with tag address tagaddr and initialization values val * .
3. Return the new store paired with exnaddr .
exn_alloc(ğ‘†, tagaddr , val * )

=

(ğ‘† âŠ• {exns exninst}, |ğ‘†.exns|)

(if exninst = {tag tagaddr , fields val * }

exn_tag(store, exnaddr ) : tagaddr
1. Let exninst be the exception instance store.exns[exnaddr ].
2. Return the tag address exninst.tag.
exn_tag(ğ‘†, ğ‘)

= exninst.tag

(if exninst = ğ‘†.exns[ğ‘])

exn_read(store, exnaddr ) : val *
1. Let exninst be the exception instance store.exns[exnaddr ].
2. Return the values exninst.fields.
exn_read(ğ‘†, ğ‘)

7.1. Embedding

=

exninst.fields

(if exninst = ğ‘†.exns[ğ‘])

247

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

7.1.13 Globals
global_alloc(store, globaltype, val ) : (store, globaladdr )
1. Pre-condition: the globaltype is valid under the empty context.
2. Let globaladdr be the result of allocating a global in store with global type globaltype and initialization
value val .
3. Return the new store paired with globaladdr .
global_alloc(ğ‘†, gt, ğ‘£)

=

(ğ‘† â€² , a)

(if allocglobal(ğ‘†, gt, ğ‘£) = ğ‘† â€² , a)

global_type(store, globaladdr ) : globaltype
1. Return ğ‘†.globals[ğ‘].type.
2. Post-condition: the returned global type is valid under the empty context.
global_type(ğ‘†, ğ‘)

=

ğ‘†.globals[ğ‘].type

global_read(store, globaladdr ) : val
1. Let gi be the global instance store.globals[globaladdr ].
2. Return the value gi .value.
global_read(ğ‘†, ğ‘)

=

ğ‘£

(if ğ‘†.globals[ğ‘].value = ğ‘£)

global_write(store, globaladdr , val ) : store | error
1. Let gi be the global instance store.globals[globaladdr ].
2. Let mut ğ‘¡ be the structure of the global type gi .type.
3. If mut is not var, then return error.
4. Replace gi .value with the value val .
5. Return the updated store.
global_write(ğ‘†, ğ‘, ğ‘£) = ğ‘† â€²
global_write(ğ‘†, ğ‘, ğ‘£) = error

(if ğ‘†.globals[ğ‘].type = var ğ‘¡ âˆ§ ğ‘† â€² = ğ‘† with globals[ğ‘].value = ğ‘£)
(otherwise)

7.1.14 Values
ref_type(store, ref ) : reftype
1. Pre-condition: the reference ref is valid under store ğ‘†.
2. Return the reference type ğ‘¡ with which ref is valid.
3. Post-condition: the returned reference type is valid under the empty context.
ref_type(ğ‘†, ğ‘Ÿ)

= ğ‘¡

(if ğ‘† âŠ¢ ğ‘Ÿ : ğ‘¡)

Ã² Note
In future versions of WebAssembly, not all references may carry precise type information at run time. In such
cases, this function may return a less precise supertype.

248

Chapter 7. Appendix

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

val_default(valtype) : val
1. If defaultğ‘£ğ‘ğ‘™ğ‘¡ğ‘¦ğ‘ğ‘’ is not defined, then return error.
1. Else, return the value defaultğ‘£ğ‘ğ‘™ğ‘¡ğ‘¦ğ‘ğ‘’ .
val_default(ğ‘¡)
val_default(ğ‘¡)

= ğ‘£
= error

(if defaultğ‘¡ = ğ‘£)
(if defaultğ‘¡ = ğœ–)

7.1.15 Matching
match_valtype(valtype 1 , valtype 2 ) : bool
1. Pre-condition: the value types valtype 1 and valtype 2 are valid under the empty context.
2. If valtype 1 matches valtype 2 , then return true.
3. Else, return false.
match_reftype(ğ‘¡1 , ğ‘¡2 )
match_reftype(ğ‘¡1 , ğ‘¡2 )

=
=

true
false

(if âŠ¢ ğ‘¡1 â‰¤ ğ‘¡2 )
(otherwise)

match_externtype(externtype 1 , externtype 2 ) : bool
1. Pre-condition: the extern types externtype 1 and externtype 2 are valid under the empty context.
2. If externtype 1 matches externtype 2 , then return true.
3. Else, return false.
match_externtype(et 1 , et 2 ) =
match_externtype(et 1 , et 2 ) =

true
false

(if âŠ¢ et 1 â‰¤ et 2 )
(otherwise)

7.2 Profiles
To enable the use of WebAssembly in as many environments as possible, profiles specify coherent language subsets
that fit constraints imposed by common classes of host environments. A host platform can thereby decide to support
the language only under a restricted profile, or even the intersection of multiple profiles.

7.2.1 Conventions
A profile modification is specified by decorating selected rules in the main body of this specification with a profile
annotation that defines them as conditional on the choice of profile.
For that purpose, every profile defines a profile marker, an alphanumeric short-hand like ABC. A profile annotation
of the form [!ABC XYZ] on a rule indicates that this rule is excluded for either of the profiles whose marker is ABC
or XYZ.
There are two ways of subsetting the language in a profile:
â€¢ Syntactic, by omitting a feature, in which case certain constructs are removed from the syntax altogether.
â€¢ Semantic, by restricting a feature, in which case certain constructs are still present but some behaviours are
ruled out.
Syntax Annotations
To omit a construct from a profile syntactically, respective productions in the grammar of the abstract syntax are
annotated with an associated profile marker. This is defined to have the following implications:
1. Any production in the binary or textual syntax that produces abstract syntax with a marked construct is
omitted by extension.
2. Any validation or execution rule that handles a marked construct is omitted by extension.

7.2. Profiles

249

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

The overall effect is that the respective construct is no longer part of the language under a respective profile.
Ã² Note
For example, a â€œbusyâ€ profile marked BUSY could rule out the nop instruction by marking the production for
it in the abstract syntax as follows:
instr
[!BUSY]

::= . . .
|
nop
|
unreachable

A rule may be annotated by multiple markers, which could be the case if a construct is in the intersection of
multiple features.
Semantics Annotations
To restrict certain behaviours in a profile, individual validation or reduction rules or auxiliary definitions are annotated with an associated marker.
This has the consequence that the respective rule is no longer applicable under the given profile.
Ã² Note
For example, an â€œinfiniteâ€ profile marked INF could define that growing memory never fails:

[!INF]

ğ‘†; ğ¹ ; (i32.const ğ‘›) memory.grow ğ‘¥

Ë“â†’ ğ‘† â€² ; ğ¹ ; (i32.const sz )
(if ğ¹.module.memaddrs[ğ‘¥] = ğ‘
âˆ§ sz = |ğ‘†.mems[ğ‘].data|/64 Ki
âˆ§ ğ‘† â€² = ğ‘† with mems[ğ‘] = growmem(ğ‘†.mems[ğ‘], ğ‘›))

ğ‘†; ğ¹ ; (i32.const ğ‘›) memory.grow ğ‘¥

Ë“â†’ ğ‘†; ğ¹ ; (i32.const signedâˆ’1
32 (âˆ’1))

Properties
All profiles are defined such that the following properties are preserved:
â€¢ All profiles represent syntactic and semantic subsets of the full profile, i.e., they do not add syntax or alter
behaviour.
â€¢ All profiles are mutually compatible, i.e., no two profiles subset semantic behaviour in inconsistent or ambiguous ways, and any intersection of profiles preserves the properties described here.
â€¢ Profiles do not violate soundness, i.e., all configurations valid under that profile still have well-defined execution behaviour.
Ã² Note
Tools are generally expected to handle and produce code for the full profile by default. In particular, producers
should not generate code that depends on specific profiles. Instead, all code should preserve correctness when
executed under the full profile.
Moreover, profiles should be considered static and fixed for a given platform or ecosystem. Runtime conditioning on the â€œcurrentâ€ profile is not intended and should be avoided.

250

Chapter 7. Appendix

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

7.2.2 Defined Profiles
Ã² Note
The number of defined profiles is expected to remain small in the future. Profiles are intended for broad and
permanent use cases only. In particular, profiles are not intended for language versioning.
Full Profile (FUL)
The full profile contains the complete language and all possible behaviours. It imposes no restrictions, i.e., all rules
and definitions are active. All other profiles define sub-languages of this profile.
Deterministic Profile (DET)
The deterministic profile excludes all rules marked [!DET] . It defines a sub-language that does not exhibit any
incidental non-deterministic behaviour:
â€¢ All NaN values generated by floating-point instructions are canonical and positive.
â€¢ All relaxed vector instructions have a fixed behaviour that does not depend on the implementation.
Even under this profile, the memory.grow and table.grow instructions technically remain non-deterministic, in
order to be able to indicate resource exhaustion.
Ã² Note
In future versions of WebAssembly, new non-deterministic behaviour may be added to the language, such that
the deterministic profile will induce additional restrictions.

7.3 Implementation Limitations
Implementations typically impose additional restrictions on a number of aspects of a WebAssembly module or
execution. These may stem from:
â€¢ physical resource limits,
â€¢ constraints imposed by the embedder or its environment,
â€¢ limitations of selected implementation strategies.
This section lists allowed limitations. Where restrictions take the form of numeric limits, no minimum requirements
are given, nor are the limits assumed to be concrete, fixed numbers. However, it is expected that all implementations
have â€œreasonablyâ€ large limits to enable common applications.
Ã² Note
A conforming implementation is not allowed to leave out individual features. However, designated subsets of
WebAssembly may be specified in the future.

7.3.1 Syntactic Limits
Structure
An implementation may impose restrictions on the following dimensions of a module:
â€¢ the number of types in a module
â€¢ the number of functions in a module, including imports
â€¢ the number of tables in a module, including imports
7.3. Implementation Limitations

251

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

â€¢ the number of memories in a module, including imports
â€¢ the number of globals in a module, including imports
â€¢ the number of tags in a module, including imports
â€¢ the number of element segments in a module
â€¢ the number of data segments in a module
â€¢ the number of imports to a module
â€¢ the number of exports from a module
â€¢ the number of sub types in a recursive type
â€¢ the subtyping depth of a sub type
â€¢ the number of fields in a structure type
â€¢ the number of parameters in a function type
â€¢ the number of results in a function type
â€¢ the number of parameters in a block type
â€¢ the number of results in a block type
â€¢ the number of locals in a function
â€¢ the number of instructions in a function body
â€¢ the number of instructions in a structured control instruction
â€¢ the number of structured control instructions in a function
â€¢ the nesting depth of structured control instructions
â€¢ the number of label indices in a br_table instruction
â€¢ the number of instructions in a constant expression
â€¢ the length of the array in a array.new_fixed instruction
â€¢ the length of an element segment
â€¢ the length of a data segment
â€¢ the length of a name
â€¢ the range of characters in a name
If the limits of an implementation are exceeded for a given module, then the implementation may reject the validation, compilation, or instantiation of that module with an embedder-specific error.
Ã² Note
The last item allows embedders that operate in limited environments without support for Unicode49 to limit the
names of imports and exports to common subsets like ASCII50 .

Binary Format
For a module given in binary format, additional limitations may be imposed on the following dimensions:
â€¢ the size of a module
â€¢ the size of any section
â€¢ the size of an individual functionâ€™s code
49 https://www.unicode.org/versions/latest/

50 https://webstore.ansi.org/RecordDetail.aspx?sku=INCITS+4-1986%5bR2012%5d

252

Chapter 7. Appendix

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

â€¢ the size of a structured control instruction
â€¢ the size of an individual constant expressionâ€™s instruction sequence
â€¢ the number of sections
Text Format
For a module given in text format, additional limitations may be imposed on the following dimensions:
â€¢ the size of the source text
â€¢ the size of any syntactic element
â€¢ the size of an individual token
â€¢ the nesting depth of folded instructions
â€¢ the length of symbolic identifiers
â€¢ the range of literal characters allowed in the source text

7.3.2 Validation
An implementation may defer validation of individual functions until they are first invoked.
If a function turns out to be invalid, then the invocation, and every consecutive call to the same function, results in
a trap.
Ã² Note
This is to allow implementations to use interpretation or just-in-time compilation for functions. The function
must still be fully validated before execution of its body begins.

7.3.3 Execution
Restrictions on the following dimensions may be imposed during execution of a WebAssembly program:
â€¢ the number of allocated module instances
â€¢ the number of allocated function instances
â€¢ the number of allocated table instances
â€¢ the number of allocated memory instances
â€¢ the number of allocated global instances
â€¢ the number of allocated tag instances
â€¢ the number of allocated structure instances
â€¢ the number of allocated array instances
â€¢ the number of allocated exception instances
â€¢ the size of a table instance
â€¢ the size of a memory instance
â€¢ the size of an array instance
â€¢ the number of frames on the stack
â€¢ the number of labels on the stack
â€¢ the number of values on the stack

7.3. Implementation Limitations

253

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

If the runtime limits of an implementation are exceeded during execution of a computation, then it may terminate
that computation and report an embedder-specific error to the invoking code.
Some of the above limits may already be verified during instantiation, in which case an implementation may report
exceedance in the same manner as for syntactic limits.
Ã² Note
Concrete limits are usually not fixed but may be dependent on specifics, interdependent, vary over time, or
depend on other implementation- or embedder-specific situations or events.

7.4 Type Soundness
The type system of WebAssembly is sound, implying both type safety and memory safety with respect to the WebAssembly semantics. For example:
â€¢ All types declared and derived during validation are respected at run time; e.g., every local or global variable
will only contain type-correct values, every instruction will only be applied to operands of the expected type,
and every function invocation always evaluates to a result of the right type (if it does not diverge, throw an
exception, or trap).
â€¢ No memory location will be read or written except those explicitly defined by the program, i.e., as a local, a
global, an element in a table, or a location within a linear memory.
â€¢ There is no undefined behavior, i.e., the execution rules cover all possible cases that can occur in a valid
program, and the rules are mutually consistent.
Soundness also is instrumental in ensuring additional properties, most notably, encapsulation of function and
module scopes: no locals can be accessed outside their own function and no module components can be accessed
outside their own module unless they are explicitly exported or imported.
The typing rules defining WebAssembly validation only cover the static components of a WebAssembly program.
In order to state and prove soundness precisely, the typing rules must be extended to the dynamic components of
the abstract runtime, that is, the store, configurations, and administrative instructions.51

7.4.1 Contexts
In order to check rolled up recursive types, the context is locally extended with an additional component that records
the sub type corresponding to each recursive type index within the current recursive type:
ğ¶

::= { . . . , recs subtype * }

7.4.2 Types
Well-formedness for extended type forms is defined as follows.
Heap Type bot
â€¢ The heap type is valid.
ğ¶ âŠ¢ bot ok
51 The formalization and theorems are derived from the following article: Andreas Haas, Andreas Rossberg, Derek Schuff, Ben Titzer, Dan

Gohman, Luke Wagner, Alon Zakai, JF Bastien, Michael Holman. Bringing the Web up to Speed with WebAssembly52 . Proceedings of the
38th ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI 2017). ACM 2017.
52 https://dl.acm.org/citation.cfm?doid=3062341.3062363

254

Chapter 7. Appendix

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

Heap Type rec ğ‘–
â€¢ The recursive type index ğ‘– must exist in ğ¶.recs.
â€¢ Then the heap type is valid.
ğ¶.recs[ğ‘–] = subtype
ğ¶ âŠ¢ rec ğ‘– ok
Value Type bot
â€¢ The value type is valid.
ğ¶ âŠ¢ bot ok
Recursive Types rec subtype *
â€¢ Let ğ¶ â€² be the current context ğ¶, but where recs is subtype * .
â€¢ There must be a type index ğ‘¥, such that for each sub type subtype ğ‘– in subtype * :
â€“ Under the context ğ¶ â€² , the sub type subtype ğ‘– must be valid for type index ğ‘¥ + ğ‘– and recursive type index
ğ‘–.
â€¢ Then the recursive type is valid for the type index ğ‘¥.
ğ¶, recs subtype * âŠ¢ rec subtype * ok(ğ‘¥, 0)
ğ¶ âŠ¢ rec subtype * ok(ğ‘¥)
*

ğ¶ âŠ¢ rec ğœ– ok(ğ‘¥, ğ‘–)

ğ¶ âŠ¢ subtype ok(ğ‘¥, ğ‘–)
ğ¶ âŠ¢ rec subtype â€² ok(ğ‘¥ + 1, ğ‘– + 1)
ğ¶ âŠ¢ rec subtype subtype â€² * ok(ğ‘¥, ğ‘–)

Ã² Note
These rules are a generalisation of the ones previously given.
Sub types sub final? ht * comptype
â€¢ The composite type comptype must be valid.
â€¢ The sequence ht * may be no longer than 1.
â€¢ For every heap type ht ğ‘˜ in ht * :
â€“ The heap type ht ğ‘˜ must be ordered before a type index ğ‘¥ and recursive type index a ğ‘–, meaning:
âˆ— Either ht ğ‘˜ is a defined type.
âˆ— Or ht ğ‘˜ is a type index ğ‘¦ğ‘˜ that is smaller than ğ‘¥.
âˆ— Or ht ğ‘˜ is a recursive type index rec ğ‘—ğ‘˜ where ğ‘—ğ‘˜ is smaller than ğ‘–.
â€“ Let sub type subtype ğ‘˜ be the unrolling of the heap type ht ğ‘˜ , meaning:
âˆ— Either ht ğ‘˜ is a defined type deftype ğ‘˜ , then subtype ğ‘˜ must be the unrolling of deftype ğ‘˜ .
âˆ— Or ht ğ‘˜ is a type index ğ‘¦ğ‘˜ , then subtype ğ‘˜ must be the unrolling of the defined type ğ¶.types[ğ‘¦ğ‘˜ ].
âˆ— Or ht ğ‘˜ is a recursive type index rec ğ‘—ğ‘˜ , then subtype ğ‘˜ must be ğ¶.recs[ğ‘—ğ‘˜ ].
â€“ The sub type subtype ğ‘˜ must not contain final.
â€“ Let comptype â€²ğ‘˜ be the composite type in subtype ğ‘˜ .
â€“ The composite type comptype must match comptype â€²ğ‘˜ .
â€¢ Then the sub type is valid for the type index ğ‘¥ and recursive type index ğ‘–.

7.4. Type Soundness

255

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)
*

|ht * | â‰¤ 1
(ht â‰º ğ‘¥, ğ‘–)*
(unrollğ¶ (ht) = sub ht â€² comptype â€² )*
ğ¶ âŠ¢ comptype ok
(ğ¶ âŠ¢ comptype â‰¤ comptype â€² )*
ğ¶ âŠ¢ sub final? ht * comptype ok(ğ‘¥, ğ‘–)
where:
(deftype â‰º ğ‘¥, ğ‘–)
(ğ‘¦ â‰º ğ‘¥, ğ‘–)
(rec ğ‘— â‰º ğ‘¥, ğ‘–)

= true
= ğ‘¦<ğ‘¥
= ğ‘—<ğ‘–

unrollğ¶ (deftype) = unroll(deftype)
unrollğ¶ (ğ‘¦)
= unroll(ğ¶.types[ğ‘¦])
unrollğ¶ (rec ğ‘—)
= ğ¶.recs[ğ‘—]

Ã² Note
This rule is a generalisation of the ones previously given, which only allowed type indices as supertypes.

7.4.3 Subtyping
In a rolled-up recursive type, a recursive type indices rec ğ‘– matches another heap type ht if:
*

â€¢ Let sub final? ht â€² comptype be the sub type ğ¶.recs[ğ‘–].
*

â€¢ The heap type ht is contained in ht â€² .
ğ¶.recs[ğ‘–] = sub final? (ht *1 ht ht *2 ) comptype
ğ¶ âŠ¢ rec ğ‘– â‰¤ ht
Ã² Note
This rule is only invoked when checking validity of rolled-up recursive types.

7.4.4 Results
Results can be classified by result types as follows.
Results val *
â€¢ For each value val ğ‘– in val * :
â€“ The value val ğ‘– is valid with some value type ğ‘¡ğ‘– .
â€¢ Let ğ‘¡* be the concatenation of all ğ‘¡ğ‘– .
â€¢ Then the result is valid with result type [ğ‘¡* ].
(ğ‘† âŠ¢ val : ğ‘¡)*
ğ‘† âŠ¢ val * : [ğ‘¡* ]
Results ğ‘‡ [(ref.exn ğ‘) throw_ref]
â€¢ The value ref.exn ğ‘ must be valid.
*

â€¢ Then the result is valid with result type [ğ‘¡* ], for any sequence ğ‘¡â€² of value types.
ğ‘† âŠ¢ tag tagaddr : tag [ğ‘¡* ] â†’ []
(ğ‘† âŠ¢ val : ğ‘¡)*
ğ‘† âŠ¢ ğ‘‡ [(ref.exn ğ‘) throw_ref] : [ğ‘¡â€² * ]

256

Chapter 7. Appendix

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

Results trap
â€¢ The result is valid with result type [ğ‘¡* ], for any valid closed result types.
âŠ¢ [ğ‘¡* ] ok
ğ‘† âŠ¢ trap : [ğ‘¡* ]

7.4.5 Store Validity
The following typing rules specify when a runtime store ğ‘† is valid. A valid store must consist of function, table,
memory, global, tag, element, data, structure, array, exception, and module instances that are themselves valid,
relative to ğ‘†.
To that end, each kind of instance is classified by a respective function, table, memory, global, tag, element, or data
type, or just ok in the case of structures, arrays, or exceptions. Module instances are classified by module contexts,
which are regular contexts repurposed as module types describing the index spaces defined by a module.
Store ğ‘†
â€¢ Each function instance funcinst ğ‘– in ğ‘†.funcs must be valid with some function type functype ğ‘– .
â€¢ Each table instance tableinst ğ‘– in ğ‘†.tables must be valid with some table type tabletype ğ‘– .
â€¢ Each memory instance meminst ğ‘– in ğ‘†.mems must be valid with some memory type memtype ğ‘– .
â€¢ Each global instance globalinst ğ‘– in ğ‘†.globals must be valid with some global type globaltype ğ‘– .
â€¢ Each tag instance taginst ğ‘– in ğ‘†.tags must be valid with some tag type tagtype ğ‘– .
â€¢ Each element instance eleminst ğ‘– in ğ‘†.elems must be valid with some reference type reftype ğ‘– .
â€¢ Each data instance datainst ğ‘– in ğ‘†.datas must be valid.
â€¢ Each structure instance structinst ğ‘– in ğ‘†.structs must be valid.
â€¢ Each array instance arrayinst ğ‘– in ğ‘†.arrays must be valid.
â€¢ Each exception instance exninst ğ‘– in ğ‘†.exns must be valid.
â€¢ No reference to a bound structure address must be reachable from itself through a path consisting only of
indirections through immutable structure, or array fields or fields of exception instances.
â€¢ No reference to a bound array address must be reachable from itself through a path consisting only of indirections through immutable structure or array fields or fields of exception instances.
â€¢ No reference to a bound exception address must be reachable from itself through a path consisting only of
indirections through immutable structure or array fields or fields of exception instances.
â€¢ Then the store is valid.
(ğ‘† âŠ¢ funcinst : deftype)*
(ğ‘† âŠ¢ tableinst : tabletype)*
*
(ğ‘† âŠ¢ meminst : memtype)
(ğ‘† âŠ¢ globalinst : globaltype)*
(ğ‘† âŠ¢ taginst : tagtype)*
(ğ‘† âŠ¢ eleminst : reftype)*
(ğ‘† âŠ¢ datainst ok)*
*
(ğ‘† âŠ¢ structinst ok)
(ğ‘† âŠ¢ arrayinst ok)*
(ğ‘† âŠ¢ exninst ok)*
*
*
*
ğ‘† = {funcs funcinst , globals globalinst , tables tableinst , mems meminst * , tags taginst * ,
elems eleminst * , datas datainst * , structs structinst * , arrays arrayinst * , exns exninst * }
*
(ğ‘†.structs[ğ‘s ] = structinst)*
((ref.struct ğ‘s ) Ì¸â‰«+
ğ‘† (ref.struct ğ‘s ))
+
*
*
(ğ‘†.arrays[ğ‘a ] = arrayinst)
((ref.array ğ‘a ) Ì¸â‰«ğ‘† (ref.array ğ‘a ))
*
(ğ‘†.exns[ğ‘e ] = exninst)*
((ref.exn ğ‘e ) Ì¸â‰«+
ğ‘† (ref.exn ğ‘e ))
âŠ¢ ğ‘† ok
+
where val 1 â‰«ğ‘† val 2 denotes the transitive closure of the following immutable reachability relation on values:
(ref.struct ğ‘)
(ref.array ğ‘)
(ref.exn ğ‘)
(ref.extern ref )

â‰«ğ‘†
â‰«ğ‘†
â‰«ğ‘†
â‰«ğ‘†

7.4. Type Soundness

ğ‘†.structs[ğ‘].fields[ğ‘–] if expand(ğ‘†.structs[ğ‘].type) = struct ft ğ‘–1 (const st) ft *2
ğ‘†.arrays[ğ‘].fields[ğ‘–] if expand(ğ‘†.arrays[ğ‘].type) = array (const st)
ğ‘†.exns[ğ‘].fields[ğ‘–]
ref
257

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

Ã² Note
The constraint on reachability through immutable fields prevents the presence of cyclic data structures that can
not be constructed in the language. Cycles can only be formed using mutation.

Function Instances {type functype, module moduleinst, code func}
â€¢ The function type functype must be valid under an empty context.
â€¢ The module instance moduleinst must be valid with some context ğ¶.
â€¢ Under context ğ¶:
â€“ The function func must be valid with some function type functype â€² .
â€“ The function type functype â€² must match functype.
â€¢ Then the function instance is valid with function type functype.
âŠ¢ functype ok
ğ‘† âŠ¢ moduleinst : ğ¶
ğ¶ âŠ¢ func : functype â€²
ğ¶ âŠ¢ functype â€² â‰¤ functype
ğ‘† âŠ¢ {type functype, module moduleinst, code func} : functype

Host Function Instances {type functype, hostcode hf }
â€¢ The function type functype must be valid under an empty context.
â€¢ Let [ğ‘¡*1 ] â†’ [ğ‘¡*2 ] be the function type functype.
â€¢ For every valid store ğ‘†1 extending ğ‘† and every sequence val * of values whose types coincide with ğ‘¡*1 :
â€“ Executing hf in store ğ‘†1 with arguments val * has a non-empty set of possible outcomes.
â€“ For every element ğ‘… of this set:
âˆ— Either ğ‘… must be âŠ¥ (i.e., divergence).
âˆ— Or ğ‘… consists of a valid store ğ‘†2 extending ğ‘†1 and a result result whose type coincides with [ğ‘¡*2 ].
â€¢ Then the function instance is valid with function type functype.

âŠ¢ [ğ‘¡*1 ] â†’ [ğ‘¡*2 ] ok

âˆ€ğ‘†1 , val * , âŠ¢ ğ‘†1 ok âˆ§ âŠ¢ ğ‘† âª¯ ğ‘†1 âˆ§ ğ‘†1 âŠ¢ val * : [ğ‘¡*1 ] =â‡’
hf (ğ‘†1 ; val * ) âŠƒ âˆ… âˆ§
âˆ€ğ‘… âˆˆ hf (ğ‘†1 ; val * ), ğ‘… = âŠ¥ âˆ¨
âˆƒğ‘†2 , result, âŠ¢ ğ‘†2 ok âˆ§ âŠ¢ ğ‘†1 âª¯ ğ‘†2 âˆ§ ğ‘†2 âŠ¢ result : [ğ‘¡*2 ] âˆ§ ğ‘… = (ğ‘†2 ; result)
ğ‘† âŠ¢ {type [ğ‘¡*1 ] â†’ [ğ‘¡*2 ], hostcode hf } : [ğ‘¡*1 ] â†’ [ğ‘¡*2 ]

Ã² Note
This rule states that, if appropriate pre-conditions about store and arguments are satisfied, then executing the
host function must satisfy appropriate post-conditions about store and results. The post-conditions match the
ones in the execution rule for invoking host functions.
Any store under which the function is invoked is assumed to be an extension of the current store. That way, the
function itself is able to make sufficient assumptions about future stores.

Table Instances {type addrtype limits ğ‘¡, elem ref * }
â€¢ The table type addrtype limits ğ‘¡ must be valid under the empty context.
â€¢ The length of ref * must equal limits.min.
â€¢ For each reference ref ğ‘– in the tableâ€™s elements ref ğ‘› :

258

Chapter 7. Appendix

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

â€“ The reference ref ğ‘– must be valid with some reference type ğ‘¡â€²ğ‘– .
â€“ The reference type ğ‘¡â€²ğ‘– must match the reference type ğ‘¡.
â€¢ Then the table instance is valid with table type addrtype limits ğ‘¡.
âŠ¢ addrtype limits ğ‘¡ ok
ğ‘› = limits.min
(ğ‘† âŠ¢ ref : ğ‘¡â€² )ğ‘›
(âŠ¢ ğ‘¡â€² â‰¤ ğ‘¡)ğ‘›
ğ‘† âŠ¢ {type addrtype limits ğ‘¡, elem ref ğ‘› } : addrtype limits ğ‘¡

Memory Instances {type addrtype limits, data ğ‘* }
â€¢ The memory type addrtype limits must be valid under the empty context.
â€¢ The length of ğ‘* must equal limits.min multiplied by the page size 64 Ki.
â€¢ Then the memory instance is valid with memory type addrtype limits.
âŠ¢ addrtype limits ok
ğ‘› = limits.min Â· 64 Ki
ğ‘† âŠ¢ {type addrtype limits, data ğ‘ğ‘› } : addrtype limits

Global Instances {type mut ğ‘¡, value val }
â€¢ The global type mut ğ‘¡ must be valid under the empty context.
â€¢ The value val must be valid with some value type ğ‘¡â€² .
â€¢ The value type ğ‘¡â€² must match the value type ğ‘¡.
â€¢ Then the global instance is valid with global type mut ğ‘¡.
âŠ¢ mut ğ‘¡ ok
ğ‘† âŠ¢ val : ğ‘¡â€²
âŠ¢ ğ‘¡â€² â‰¤ ğ‘¡
ğ‘† âŠ¢ {type mut ğ‘¡, value val } : mut ğ‘¡

Tag Instances {type tagtype}
â€¢ The tag type tagtype must be valid under the empty context.
â€¢ Then the tag instance is valid with tag type tagtype.
âŠ¢ tagtype ok
ğ‘† âŠ¢ {type tagtype} : tagtype

Element Instances {type ğ‘¡, elem ref * }
â€¢ The reference type ğ‘¡ must be valid under the empty context.
â€¢ For each reference ref ğ‘– in the elements ref ğ‘› :
â€“ The reference ref ğ‘– must be valid with some reference type ğ‘¡â€²ğ‘– .
â€“ The reference type ğ‘¡â€²ğ‘– must match the reference type ğ‘¡.
â€¢ Then the element instance is valid with reference type ğ‘¡.
âŠ¢ ğ‘¡ ok

(ğ‘† âŠ¢ ref : ğ‘¡â€² )*
(âŠ¢ ğ‘¡â€² â‰¤ ğ‘¡)*
*
ğ‘† âŠ¢ {type ğ‘¡, elem ref } : ğ‘¡

Data Instances {data ğ‘* }
â€¢ The data instance is valid.
ğ‘† âŠ¢ {data ğ‘* } ok

7.4. Type Soundness

259

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

Structure Instances {type deftype, fields fieldval * }
â€¢ The defined type deftype must be valid under the empty context.
â€¢ The expansion of deftype must be a structure type struct fieldtype * .
â€¢ The length of the sequence of field values fieldval * must be the same as the length of the sequence of field
types fieldtype * .
â€¢ For each field value fieldval ğ‘– in fieldval * and corresponding field type fieldtype ğ‘– in fieldtype * :
â€“ Let fieldtype ğ‘– be mut storagetype ğ‘– .
â€“ The field value fieldval ğ‘– must be valid with storage type storagetype ğ‘– .
â€¢ Then the structure instance is valid.
âŠ¢ dt ok
expand(dt) = struct (mut st)*
ğ‘† âŠ¢ {type dt, fields fv * } ok

(ğ‘† âŠ¢ fv : st)*

Array Instances {type deftype, fields fieldval * }
â€¢ The defined type deftype must be valid under the empty context.
â€¢ The expansion of deftype must be an array type array fieldtype.
â€¢ Let fieldtype be mut storagetype.
â€¢ For each field value fieldval ğ‘– in fieldval * :
â€“ The field value fieldval ğ‘– must be valid with storage type storagetype.
â€¢ Then the array instance is valid.
âŠ¢ dt ok

expand(dt) = array (mut st)
ğ‘† âŠ¢ {type dt, fields fv * } ok

(ğ‘† âŠ¢ fv : st)*

Field Values fieldval
â€¢ If fieldval is a value val , then:
â€“ The value val must be valid with value type ğ‘¡.
â€“ Then the field value is valid with value type ğ‘¡.
â€¢ Else, fieldval is a packed value packedval :
â€“ Let packedtype.pack ğ‘– be the field value fieldval .
â€“ Then the field value is valid with packed type packedtype.
ğ‘† âŠ¢ pt.pack ğ‘– : pt

Exception Instances {tag ğ‘, fields val * }
â€¢ The store entry ğ‘†.tags[ğ‘] must exist.
*

â€¢ Let [ğ‘¡* ] â†’ [ğ‘¡â€² ] be the tag type ğ‘†.tags[ğ‘].type.
*

â€¢ The result type [ğ‘¡â€² ] must be empty.
â€¢ The sequence val ğ‘ ğ‘ ğ‘¡ of values must have the same length as the sequence ğ‘¡* of value types.
â€¢ For each value val ğ‘– in val ğ‘ ğ‘ ğ‘¡ and corresponding value type ğ‘¡ğ‘– in ğ‘¡* , the value val ğ‘– must be valid with type
ğ‘¡ğ‘– .
â€¢ Then the exception instance is valid.

260

Chapter 7. Appendix

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)
ğ‘†.tags[ğ‘] = {type = [ğ‘¡* ] â†’ []}
(ğ‘† âŠ¢ val : ğ‘¡)*
*
ğ‘† âŠ¢ {tag ğ‘, fields val } ok

Export Instances {name name, value externval }
â€¢ The external value externval must be valid with some external type externtype.
â€¢ Then the export instance is valid.
ğ‘† âŠ¢ externval : externtype
ğ‘† âŠ¢ {name name, value externval } ok

Module Instances moduleinst
â€¢ Each defined type deftype ğ‘– in moduleinst.types must be valid under the empty context.
â€¢ For each function address funcaddr ğ‘– in moduleinst.funcaddrs, the external value func funcaddr ğ‘– must be
valid with some external type func functype ğ‘– .
â€¢ For each table address tableaddr ğ‘– in moduleinst.tableaddrs, the external value table tableaddr ğ‘– must be
valid with some external type table tabletype ğ‘– .
â€¢ For each memory address memaddr ğ‘– in moduleinst.memaddrs, the external value mem memaddr ğ‘– must
be valid with some external type mem memtype ğ‘– .
â€¢ For each global address globaladdr ğ‘– in moduleinst.globaladdrs, the external value global globaladdr ğ‘– must
be valid with some external type global globaltype ğ‘– .
â€¢ For each tag address tagaddr ğ‘– in moduleinst.tagaddrs, the external value tag tagaddr ğ‘– must be valid with
some external type tag tagtype ğ‘– .
â€¢ For each element address elemaddr ğ‘– in moduleinst.elemaddrs, the element instance ğ‘†.elems[elemaddr ğ‘– ]
must be valid with some reference type reftype ğ‘– .
â€¢ For each data address dataaddr ğ‘– in moduleinst.dataaddrs, the data instance ğ‘†.datas[dataaddr ğ‘– ] must be
valid.
â€¢ Each export instance exportinst ğ‘– in moduleinst.exports must be valid.
â€¢ For each export instance exportinst ğ‘– in moduleinst.exports, the name exportinst ğ‘– .name must be different
from any other name occurring in moduleinst.exports.
â€¢ Let deftype * be the concatenation of all deftype ğ‘– in order.
â€¢ Let functype * be the concatenation of all functype ğ‘– in order.
â€¢ Let tabletype * be the concatenation of all tabletype ğ‘– in order.
â€¢ Let memtype * be the concatenation of all memtype ğ‘– in order.
â€¢ Let globaltype * be the concatenation of all globaltype ğ‘– in order.
â€¢ Let tagtype * be the concatenation of all tagtype ğ‘– in order.
â€¢ Let reftype * be the concatenation of all reftype ğ‘– in order.
â€¢ Let ğ‘š be the length of moduleinst.funcaddrs.
â€¢ Let ğ‘› be the length of moduleinst.dataaddrs.
â€¢ Let ğ‘¥* be the sequence of function indices from 0 to ğ‘š âˆ’ 1.
â€¢ Then the module instance is valid with context {types deftype * , funcs functype * , tables tabletype * ,
mems memtype * , globals globaltype * , CTAGS~tagtype^ast, elems reftype * , datas okğ‘› , refs ğ‘¥* }.

7.4. Type Soundness

261

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

(âŠ¢ deftype ok)*
(ğ‘† âŠ¢ func funcaddr : func functype)*
(ğ‘† âŠ¢ table tableaddr : table tabletype)*
*
(ğ‘† âŠ¢ mem memaddr : mem memtype)
(ğ‘† âŠ¢ global globaladdr : global globaltype)*
(ğ‘† âŠ¢ tag tagaddr : tag tagtype)*
(ğ‘† âŠ¢ ğ‘†.elems[elemaddr ] : reftype)*
(ğ‘† âŠ¢ ğ‘†.datas[dataaddr ] ok)ğ‘›
*
(ğ‘† âŠ¢ exportinst ok)
(exportinst.name)* disjoint
*
ğ‘† âŠ¢ {types
deftype ,
funcaddrs funcaddr * ,
tableaddrs tableaddr * ,
memaddrs memaddr * ,
globaladdrs globaladdr * ,
tagaddrs tagaddr * ,
elemaddrs elemaddr * ,
dataaddrs dataaddr ğ‘› ,
exports
exportinst * } : {types deftype * ,
funcs functype * ,
tables tabletype * ,
mems memtype * ,
globals globaltype * ,
tags tagtype * ,
elems reftype * ,
datas okğ‘› ,
refs
0 . . . (|funcaddr * | âˆ’ 1) }

7.4.6 Configuration Validity
To relate the WebAssembly type system to its execution semantics, the typing rules for instructions must be extended to configurations ğ‘†; ğ‘‡ , which relates the store to execution threads.
Configurations and threads are classified by their result type. In addition to the store ğ‘†, threads are typed under a
return type resulttype ? , which controls whether and with which type a return instruction is allowed. This type is
absent (ğœ–) except for instruction sequences inside an administrative frame instruction.
Finally, frames are classified with frame contexts, which extend the module contexts of a frameâ€™s associated module
instance with the locals that the frame contains.
Configurations ğ‘†; ğ‘‡
â€¢ The store ğ‘† must be valid.
â€¢ Under no allowed return type, the thread ğ‘‡ must be valid with some result type [ğ‘¡* ].
â€¢ Then the configuration is valid with the result type [ğ‘¡* ].
âŠ¢ ğ‘† ok

ğ‘†; ğœ– âŠ¢ ğ‘‡ : [ğ‘¡* ]
âŠ¢ ğ‘†; ğ‘‡ : [ğ‘¡* ]

Threads ğ¹ ; instr *
â€¢ Let resulttype ? be the current allowed return type.
â€¢ The frame ğ¹ must be valid with a context ğ¶.
â€¢ Let ğ¶ â€² be the same context as ğ¶, but with return set to resulttype ? .
â€¢ Under context ğ¶ â€² , the instruction sequence instr * must be valid with some type [] â†’ [ğ‘¡* ].
â€¢ Then the thread is valid with the result type [ğ‘¡* ].
ğ‘†âŠ¢ğ¹ :ğ¶

262

ğ‘†; ğ¶, return resulttype ? âŠ¢ instr * : [] â†’ [ğ‘¡* ]
ğ‘†; resulttype ? âŠ¢ ğ¹ ; instr * : [ğ‘¡* ]

Chapter 7. Appendix

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

Frames {locals val * , module moduleinst}
â€¢ The module instance moduleinst must be valid with some module context ğ¶.
â€¢ Each value val ğ‘– in val * must be valid with some value type ğ‘¡ğ‘– .
â€¢ Let ğ‘¡* be the concatenation of all ğ‘¡ğ‘– in order.
â€¢ Let ğ¶ â€² be the same context as ğ¶, but with the value types ğ‘¡* prepended to the locals vector.
â€¢ Then the frame is valid with frame context ğ¶ â€² .
ğ‘† âŠ¢ moduleinst : ğ¶
(ğ‘† âŠ¢ val : ğ‘¡)*
ğ‘† âŠ¢ {locals val * , module moduleinst} : (ğ¶, locals ğ‘¡* )

7.4.7 Administrative Instructions
Typing rules for administrative instructions are specified as follows. In addition to the context ğ¶, typing of these
instructions is defined under a given store ğ‘†.
To that end, all previous typing judgements ğ¶ âŠ¢ prop are generalized to include the store, as in ğ‘†; ğ¶ âŠ¢ prop, by
implicitly adding ğ‘† to all rules â€“ ğ‘† is never modified by the pre-existing rules, but it is accessed in the extra rules
for administrative instructions given below.
trap
â€¢ The instruction is valid with any valid instruction type of the form [ğ‘¡*1 ] â†’ [ğ‘¡*2 ].
ğ¶ âŠ¢ [ğ‘¡*1 ] â†’ [ğ‘¡*2 ] ok
ğ‘†; ğ¶ âŠ¢ trap : [ğ‘¡*1 ] â†’ [ğ‘¡*2 ]

val
â€¢ The value val must be valid with value type ğ‘¡.
â€¢ Then it is valid as an instruction with type [] â†’ [ğ‘¡].
ğ‘† âŠ¢ val : ğ‘¡
ğ‘†; ğ¶ âŠ¢ val : [] â†’ [ğ‘¡]

invoke funcaddr
â€¢ The external function value func funcaddr must be valid with external function type funcfunctype â€² .
â€¢ Let [ğ‘¡*1 ] â†’ [ğ‘¡*2 ]) be the function type functype.
â€¢ Then the instruction is valid with type [ğ‘¡*1 ] â†’ [ğ‘¡*2 ].
ğ‘† âŠ¢ func funcaddr : func [ğ‘¡*1 ] â†’ [ğ‘¡*2 ]
ğ‘†; ğ¶ âŠ¢ invoke funcaddr : [ğ‘¡*1 ] â†’ [ğ‘¡*2 ]

labelğ‘› {instr *0 } instr * end
â€¢ The instruction sequence instr *0 must be valid with some type [ğ‘¡ğ‘›1 ] â†’ğ‘¥* [ğ‘¡*2 ].
â€¢ Let ğ¶ â€² be the same context as ğ¶, but with the result type [ğ‘¡ğ‘›1 ] prepended to the labels vector.
â€¢ Under context ğ¶ â€² , the instruction sequence instr * must be valid with type [] â†’ğ‘¥â€² * [ğ‘¡*2 ].
â€¢ Then the compound instruction is valid with type [] â†’ [ğ‘¡*2 ].
ğ‘†; ğ¶, labels [ğ‘¡ğ‘›1 ] âŠ¢ instr * : [] â†’ğ‘¥â€² * [ğ‘¡*2 ]
ğ‘†; ğ¶ âŠ¢ instr *0 : [ğ‘¡ğ‘›1 ] â†’ğ‘¥* [ğ‘¡*2 ]
ğ‘†; ğ¶ âŠ¢ labelğ‘› {instr *0 } instr * end : [] â†’ [ğ‘¡*2 ]

7.4. Type Soundness

263

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

handlerğ‘› {catch * } instr * end
â€¢ For every catch clause catch ğ‘– in catch * , catch ğ‘– must be valid.
â€¢ The instruction sequence instr * must be valid with some type [ğ‘¡*1 ] â†’ [ğ‘¡*2 ].
â€¢ Then the compound instruction is valid with type [ğ‘¡*1 ] â†’ [ğ‘¡*2 ].
(ğ¶ âŠ¢ catch ok)*
ğ‘†; ğ¶ âŠ¢ instr * : [ğ‘¡*1 ] â†’ [ğ‘¡*2 ]
ğ‘†; ğ¶ âŠ¢ handlerğ‘› {catch * } instr * end : [ğ‘¡*1 ] â†’ [ğ‘¡*2 ]
frameğ‘› {ğ¹ } instr * end
â€¢ Under the valid return type [ğ‘¡ğ‘› ], the thread ğ¹ ; instr * must be valid with result type [ğ‘¡ğ‘› ].
â€¢ Then the compound instruction is valid with type [] â†’ [ğ‘¡ğ‘› ].
ğ¶ âŠ¢ [ğ‘¡ğ‘› ] ok
ğ‘†; [ğ‘¡ğ‘› ] âŠ¢ ğ¹ ; instr * : [ğ‘¡ğ‘› ]
ğ‘†; ğ¶ âŠ¢ frameğ‘› {ğ¹ } instr * end : [] â†’ [ğ‘¡ğ‘› ]

7.4.8 Store Extension
Programs can mutate the store and its contained instances. Any such modification must respect certain invariants,
such as not removing allocated instances or changing immutable definitions. While these invariants are inherent
to the execution semantics of WebAssembly instructions and modules, host functions do not automatically adhere
to them. Consequently, the required invariants must be stated as explicit constraints on the invocation of host
functions. Soundness only holds when the embedder ensures these constraints.
The necessary constraints are codified by the notion of store extension: a store state ğ‘† â€² extends state ğ‘†, written
ğ‘† âª¯ ğ‘† â€² , when the following rules hold.
Ã² Note
Extension does not imply that the new store is valid, which is defined separately above.

Store ğ‘†
â€¢ The length of ğ‘†.funcs must not shrink.
â€¢ The length of ğ‘†.tables must not shrink.
â€¢ The length of ğ‘†.mems must not shrink.
â€¢ The length of ğ‘†.globals must not shrink.
â€¢ The length of ğ‘†.tags must not shrink.
â€¢ The length of ğ‘†.elems must not shrink.
â€¢ The length of ğ‘†.datas must not shrink.
â€¢ The length of ğ‘†.structs must not shrink.
â€¢ The length of ğ‘†.arrays must not shrink.
â€¢ The length of ğ‘†.exns must not shrink.
â€¢ For each function instance funcinst ğ‘– in the original ğ‘†.funcs, the new function instance must be an extension
of the old.
â€¢ For each table instance tableinst ğ‘– in the original ğ‘†.tables, the new table instance must be an extension of the
old.
â€¢ For each memory instance meminst ğ‘– in the original ğ‘†.mems, the new memory instance must be an extension
of the old.
264

Chapter 7. Appendix

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

â€¢ For each global instance globalinst ğ‘– in the original ğ‘†.globals, the new global instance must be an extension
of the old.
â€¢ For each tag instance taginst ğ‘– in the original ğ‘†.tags, the new tag instance must be an extension of the old.
â€¢ For each element instance eleminst ğ‘– in the original ğ‘†.elems, the new element instance must be an extension
of the old.
â€¢ For each data instance datainst ğ‘– in the original ğ‘†.datas, the new data instance must be an extension of the
old.
â€¢ For each structure instance structinst ğ‘– in the original ğ‘†.structs, the new structure instance must be an extension of the old.
â€¢ For each array instance arrayinst ğ‘– in the original ğ‘†.arrays, the new array instance must be an extension of
the old.
â€¢ For each exception instance exninst ğ‘– in the original ğ‘†.exns, the new exception instance must be an extension
of the old.
ğ‘†1 .funcs = funcinst *1
ğ‘†1 .tables = tableinst *1
ğ‘†1 .mems = meminst *1
ğ‘†1 .globals = globalinst *1
ğ‘†1 .tags = taginst *1
ğ‘†1 .elems = eleminst *1
ğ‘†1 .datas = datainst *1
ğ‘†1 .structs = structinst *1
ğ‘†1 .arrays = arrayinst *1
ğ‘†1 .exns = exninst *1

*

ğ‘†2 .funcs = funcinst â€²1 funcinst *2
*
ğ‘†2 .tables = tableinst â€²1 tableinst *2
*
ğ‘†2 .mems = meminst â€²1 meminst *2
*
ğ‘†2 .globals = globalinst â€²1 globalinst *2
*
ğ‘†2 .tags = taginst â€²1 taginst *2
*
ğ‘†2 .elems = eleminst â€²1 eleminst *2
*
ğ‘†2 .datas = datainst â€²1 datainst *2
*
ğ‘†2 .structs = structinst â€²1 structinst *2
*
ğ‘†2 .arrays = arrayinst â€²1 arrayinst *2
*
ğ‘†2 .exns = exninst â€²1 exninst *2
âŠ¢ ğ‘†1 âª¯ ğ‘†2

(âŠ¢ funcinst 1 âª¯ funcinst â€²1 )*
(âŠ¢ tableinst 1 âª¯ tableinst â€²1 )*
(âŠ¢ meminst 1 âª¯ meminst â€²1 )*
(âŠ¢ globalinst 1 âª¯ globalinst â€²1 )*
(âŠ¢ taginst 1 âª¯ taginst â€²1 )*
(âŠ¢ eleminst 1 âª¯ eleminst â€²1 )*
(âŠ¢ datainst 1 âª¯ datainst â€²1 )*
(âŠ¢ structinst 1 âª¯ structinst â€²1 )*
(âŠ¢ arrayinst 1 âª¯ arrayinst â€²1 )*
(âŠ¢ exninst 1 âª¯ exninst â€²1 )*

Function Instance funcinst
â€¢ A function instance must remain unchanged.
âŠ¢ funcinst âª¯ funcinst

Table Instance tableinst
â€¢ The table type tableinst.type must remain unchanged.
â€¢ The length of tableinst.elem must not shrink.
ğ‘›1 â‰¤ ğ‘›2
? ğ‘›1
âŠ¢ {type tt, elem (fa 1 ) } âª¯ {type tt, elem (fa ?2 )ğ‘›2 }

Memory Instance meminst
â€¢ The memory type meminst.type must remain unchanged.
â€¢ The length of meminst.data must not shrink.
ğ‘›1 â‰¤ ğ‘›2
âŠ¢ {type mt, data ğ‘ğ‘›1 1 } âª¯ {type mt, data ğ‘ğ‘›2 2 }

7.4. Type Soundness

265

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

Global Instance globalinst
â€¢ The global type globalinst.type must remain unchanged.
â€¢ Let mut ğ‘¡ be the structure of globalinst.type.
â€¢ If mut is const, then the value globalinst.value must remain unchanged.
mut = var âˆ¨ val 1 = val 2
âŠ¢ {type (mut ğ‘¡), value val 1 } âª¯ {type (mut ğ‘¡), value val 2 }

Tag Instance taginst
â€¢ A tag instance must remain unchanged.
âŠ¢ taginst âª¯ taginst

Element Instance eleminst
â€¢ The reference type eleminst.type must remain unchanged.
â€¢ The vector eleminst.elem must:
â€“ either remain unchanged,
â€“ or shrink to length 0.
âŠ¢ {type ğ‘¡, elem ğ‘* } âª¯ {type ğ‘¡, elem ğ‘* }
âŠ¢ {type ğ‘¡, elem ğ‘* } âª¯ {type ğ‘¡, elem ğœ–}

Data Instance datainst
â€¢ The vector datainst.data must:
â€“ either remain unchanged,
â€“ or shrink to length 0.
âŠ¢ {data ğ‘* } âª¯ {data ğ‘* }
âŠ¢ {data ğ‘* } âª¯ {data ğœ–}

Structure Instance structinst
â€¢ The defined type structinst.type must remain unchanged.
â€¢ Assert: due to store well-formedness, the expansion of structinst.type is a structure type.
â€¢ Let struct fieldtype * be the expansion of structinst.type.
â€¢ The length of the vector structinst.fields must remain unchanged.
â€¢ Assert: due to store well-formedness, the length of structinst.fields is the same as the length of fieldtype * .
â€¢ For each field value fieldval ğ‘– in structinst.fields and corresponding field type fieldtype ğ‘– in fieldtype * :
â€“ Let mut ğ‘– st ğ‘– be the structure of fieldtype ğ‘– .
â€“ If mut ğ‘– is const, then the field value fieldval ğ‘– must remain unchanged.
(mut = var âˆ¨ fieldval 1 = fieldval 2 )*
âŠ¢ {type (mut st)* , fields fieldval *1 } âª¯ {type (mut st)* , fields fieldval *2 }

266

Chapter 7. Appendix

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

Array Instance arrayinst
â€¢ The defined type arrayinst.type must remain unchanged.
â€¢ Assert: due to store well-formedness, the expansion of arrayinst.type is an array type.
â€¢ Let array fieldtype be the expansion of arrayinst.type.
â€¢ The length of the vector arrayinst.fields must remain unchanged.
â€¢ Let mut st be the structure of fieldtype.
â€¢ If mut is const, then the sequence of field values arrayinst.fields must remain unchanged.
mut = var âˆ¨ fieldval *1 = fieldval *2
âŠ¢ {type (mut st), fields fieldval *1 } âª¯ {type (mut st), fields fieldval *2 }

Exception Instance exninst
â€¢ An exception instance must remain unchanged.
âŠ¢ exninst âª¯ exninst

7.4.9 Theorems
Given the definition of valid configurations, the standard soundness theorems hold.5355
Theorem (Preservation). If a configuration ğ‘†; ğ‘‡ is valid with result type [ğ‘¡* ] (i.e., âŠ¢ ğ‘†; ğ‘‡ : [ğ‘¡* ]), and steps to
ğ‘† â€² ; ğ‘‡ â€² (i.e., ğ‘†; ğ‘‡ Ë“â†’ ğ‘† â€² ; ğ‘‡ â€² ), then ğ‘† â€² ; ğ‘‡ â€² is a valid configuration with the same result type (i.e., âŠ¢ ğ‘† â€² ; ğ‘‡ â€² : [ğ‘¡* ]).
Furthermore, ğ‘† â€² is an extension of ğ‘† (i.e., âŠ¢ ğ‘† âª¯ ğ‘† â€² ).
A terminal thread is one whose sequence of instructions is a result. A terminal configuration is a configuration
whose thread is terminal.
Theorem (Progress). If a configuration ğ‘†; ğ‘‡ is valid (i.e., âŠ¢ ğ‘†; ğ‘‡ : [ğ‘¡* ] for some result type [ğ‘¡* ]), then either it is
terminal, or it can step to some configuration ğ‘† â€² ; ğ‘‡ â€² (i.e., ğ‘†; ğ‘‡ Ë“â†’ ğ‘† â€² ; ğ‘‡ â€² ).
From Preservation and Progress the soundness of the WebAssembly type system follows directly.
Corollary (Soundness). If a configuration ğ‘†; ğ‘‡ is valid (i.e., âŠ¢ ğ‘†; ğ‘‡ : [ğ‘¡* ] for some result type [ğ‘¡* ]), then it either
diverges or takes a finite number of steps to reach a terminal configuration ğ‘† â€² ; ğ‘‡ â€² (i.e., ğ‘†; ğ‘‡ Ë“â†’ * ğ‘† â€² ; ğ‘‡ â€² ) that is
valid with the same result type (i.e., âŠ¢ ğ‘† â€² ; ğ‘‡ â€² : [ğ‘¡* ]) and where ğ‘† â€² is an extension of ğ‘† (i.e., âŠ¢ ğ‘† âª¯ ğ‘† â€² ).
In other words, every thread in a valid configuration either runs forever, traps, throws an exception, or terminates
with a result that has the expected type. Consequently, given a valid store, no computation defined by instantiation or
invocation of a valid module can â€œcrashâ€ or otherwise (mis)behave in ways not covered by the execution semantics
given in this specification.

7.5 Type System Properties
7.5.1 Principal Types
The type system of WebAssembly features both subtyping and simple forms of polymorphism for instruction types.
That has the effect that every instruction or instruction sequence can be classified with multiple different instruction
types.
53 A machine-verified version of the formalization and soundness proof of the PLDI 2017 paper is described in the following article: Conrad
Watt. Mechanising and Verifying the WebAssembly Specification54 . Proceedings of the 7th ACM SIGPLAN Conference on Certified Programs
and Proofs (CPP 2018). ACM 2018.
54 https://dl.acm.org/citation.cfm?id=3167082
55 Machine-verified formalizations and soundness proofs of the semantics from the official specification are described in the following article:
Conrad Watt, Xiaojia Rao, Jean Pichon-Pharabod, Martin Bodin, Philippa Gardner. Two Mechanisations of WebAssembly 1.056 . Proceedings
of the 24th International Symposium on Formal Methods (FM 2021). Springer 2021.
56 https://link.springer.com/chapter/10.1007/978-3-030-90870-6_4

7.5. Type System Properties

267

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

However, the typing rules still allow deriving principal types for instruction sequences. That is, every valid instruction sequence has one particular type scheme, possibly containing some unconstrained place holder type variables,
that is a subtype of all its valid instruction types, after substituting its type variables with suitable specific types.
Moreover, when deriving an instruction type in a â€œforwardâ€ manner, i.e., the input of the instruction sequence is
already fixed to specific types, then it has a principal output type expressible without type variables, up to a possibly
polymorphic stack bottom representable with one single variable. In other words, â€œforwardâ€ principal types are
effectively closed.
Ã² Note
For example, in isolation, the instruction ref.as_non_null has the type [(ref null ht)] â†’ [(ref ht)] for any choice
of valid heap type ht. Moreover, if the input type [(ref null ht)] is already determined, i.e., a specific ht is given,
then the output type [(ref ht)] is fully determined as well.
The implication of the latter property is that a validator for complete instruction sequences (as they occur in
valid modules) can be implemented with a simple left-to-right algorithm that does not require the introduction
of type variables.
A typing algorithm capable of handling partial instruction sequences (as might be considered for program
analysis or program manipulation) needs to introduce type variables and perform substitutions, but it does not
need to perform backtracking or record any non-syntactic constraints on these type variables.
Technically, the syntax of heap, value, and result types can be enriched with type variables as follows:
null
heaptype
reftype
valtype
resulttype

::= null? | ğ›¼null
::= . . . | ğ›¼heaptype
::= ref null heaptype
::= . . . | ğ›¼valtype | ğ›¼numvectype
?
*
::= [ğ›¼valtype
* valtype ]

where each ğ›¼xyz ranges over a set of type variables for syntactic class xyz , respectively. The special class
numvectype is defined as numtype | vectype | bot, and is only needed to handle unannotated select instructions.
A type is closed when it does not contain any type variables, and open otherwise. A type substitution ğœ is a finite
mapping from type variables to closed types of the respective syntactic class. When applied to an open type, it
replaces the type variables ğ›¼ from its domain with the respective ğœ(ğ›¼).
Theorem (Principal Types). If an instruction sequence instr * is valid with some closed instruction type instrtype
(i.e., ğ¶ âŠ¢ instr * : instrtype), then it is also valid with a possibly open instruction type instrtype min (i.e., ğ¶ âŠ¢
instr * : instrtype min ), such that for every closed type instrtype â€² with which instr * is valid (i.e., for all ğ¶ âŠ¢
instr * : instrtype â€² ), there exists a substitution ğœ, such that ğœ(instrtype min ) is a subtype of instrtype â€² (i.e.,
ğ¶ âŠ¢ ğœ(instrtype min ) â‰¤ instrtype â€² ). Furthermore, instrtype min is unique up to the choice of type variables.
Theorem (Closed Principal Forward Types). If closed input type [ğ‘¡*1 ] is given and the instruction sequence instr *
is valid with instruction type [ğ‘¡*1 ] â†’ğ‘¥* [ğ‘¡*2 ] (i.e., ğ¶ âŠ¢ instr * : [ğ‘¡*1 ] â†’ğ‘¥* [ğ‘¡*2 ]), then it is also valid with instruction
type [ğ‘¡*1 ] â†’ğ‘¥* [ğ›¼valtype * ğ‘¡* ] (i.e., ğ¶ âŠ¢ instr * : [ğ‘¡*1 ] â†’ğ‘¥* [ğ›¼valtype * ğ‘¡* ]), where all ğ‘¡* are closed, such that for
*
*
every closed result type [ğ‘¡â€²2 ] with which instr * is valid (i.e., for all ğ¶ âŠ¢ instr * : [ğ‘¡*1 ] â†’ğ‘¥* [ğ‘¡â€²2 ]), there exists a
*
substitution ğœ, such that [ğ‘¡â€²2 ] = [ğœ(ğ›¼valtype * ) ğ‘¡* ].

7.5.2 Type Lattice
The Principal Types property depends on the existence of a greatest lower bound for any pair of types.
Theorem (Greatest Lower Bounds for Value Types). For any two value types ğ‘¡1 and ğ‘¡2 that are valid (i.e.,
ğ¶ âŠ¢ ğ‘¡1 ok and ğ¶ âŠ¢ ğ‘¡2 ok), there exists a valid value type ğ‘¡ that is a subtype of both ğ‘¡1 and ğ‘¡2 (i.e., ğ¶ âŠ¢ ğ‘¡ ok and
ğ¶ âŠ¢ ğ‘¡ â‰¤ ğ‘¡1 and ğ¶ âŠ¢ ğ‘¡ â‰¤ ğ‘¡2 ), such that every valid value type ğ‘¡â€² that also is a subtype of both ğ‘¡1 and ğ‘¡2 (i.e., for all
ğ¶ âŠ¢ ğ‘¡â€² ok and ğ¶ âŠ¢ ğ‘¡â€² â‰¤ ğ‘¡1 and ğ¶ âŠ¢ ğ‘¡â€² â‰¤ ğ‘¡2 ), is a subtype of ğ‘¡ (i.e., ğ¶ âŠ¢ ğ‘¡â€² â‰¤ ğ‘¡).

268

Chapter 7. Appendix

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

Ã² Note
The greatest lower bound of two types may be bot.
Theorem (Conditional Least Upper Bounds for Value Types). Any two value types ğ‘¡1 and ğ‘¡2 that are valid (i.e.,
ğ¶ âŠ¢ ğ‘¡1 ok and ğ¶ âŠ¢ ğ‘¡2 ok) either have no common supertype, or there exists a valid value type ğ‘¡ that is a supertype
of both ğ‘¡1 and ğ‘¡2 (i.e., ğ¶ âŠ¢ ğ‘¡ ok and ğ¶ âŠ¢ ğ‘¡1 â‰¤ ğ‘¡ and ğ¶ âŠ¢ ğ‘¡2 â‰¤ ğ‘¡), such that every valid value type ğ‘¡â€² that also is
a supertype of both ğ‘¡1 and ğ‘¡2 (i.e., for all ğ¶ âŠ¢ ğ‘¡â€² ok and ğ¶ âŠ¢ ğ‘¡1 â‰¤ ğ‘¡â€² and ğ¶ âŠ¢ ğ‘¡2 â‰¤ ğ‘¡â€² ), is a supertype of ğ‘¡ (i.e.,
ğ¶ âŠ¢ ğ‘¡ â‰¤ ğ‘¡â€² ).
Ã² Note
If a top type was added to the type system, a least upper bound would exist for any two types.
Corollary (Type Lattice). Assuming the addition of a provisional top type, value types form a lattice with respect
to their subtype relation.
Finally, value types can be partitioned into multiple disjoint hierarchies that are not related by subtyping, except
through bot.
Theorem (Disjoint Subtype Hierarchies). The greatest lower bound of two value types is bot or ref bot if and
only if they do not have a least upper bound.
In other words, types that do not have common supertypes, do not have common subtypes either (other than bot
or ref bot), and vice versa.
Ã² Note
Types from disjoint hierarchies can safely be represented in mutually incompatible ways in an implementation,
because their values can never flow to the same place.

7.5.3 Compositionality
Valid instruction sequences can be freely composed, as long as their types match up.
Theorem (Composition). If two instruction sequences instr *1 and instr *2 are valid with types [ğ‘¡*1 ] â†’ğ‘¥*1 [ğ‘¡* ] and
[ğ‘¡* ] â†’ğ‘¥*2 [ğ‘¡*2 ], respectively (i.e., ğ¶ âŠ¢ instr *1 : [ğ‘¡*1 ] â†’ğ‘¥*1 [ğ‘¡* ] and ğ¶ âŠ¢ instr *1 : [ğ‘¡* ] â†’ğ‘¥*2 [ğ‘¡*2 ]), then the concatenated
instruction sequence (instr *1 instr *2 ) is valid with type [ğ‘¡*1 ] â†’ğ‘¥*1 ğ‘¥*2 [ğ‘¡*2 ] (i.e., ğ¶ âŠ¢ instr *1 instr *2 : [ğ‘¡*1 ] â†’ğ‘¥*1 ğ‘¥*2 [ğ‘¡*2 ]).
Ã² Note
More generally, instead of a shared type [ğ‘¡* ], it suffices if the output type of instr *1 is a subtype of the input
type of instr *1 , since the subtype can always be weakened to its supertype by subsumption.
Inversely, valid instruction sequences can also freely be decomposed, that is, splitting them anywhere produces two
instruction sequences that are both valid.
Theorem (Decomposition). If an instruction sequence instr * that is valid with type [ğ‘¡*1 ] â†’ğ‘¥* [ğ‘¡*2 ] (i.e., ğ¶ âŠ¢
instr * : [ğ‘¡*1 ] â†’ğ‘¥* [ğ‘¡*2 ]) is split into two instruction sequences instr *1 and instr *2 at any point (i.e., instr * =
instr *1 instr *2 ), then these are separately valid with some types [ğ‘¡*1 ] â†’ğ‘¥*1 [ğ‘¡* ] and [ğ‘¡* ] â†’ğ‘¥*2 [ğ‘¡*2 ], respectively (i.e.,
ğ¶ âŠ¢ instr *1 : [ğ‘¡*1 ] â†’ğ‘¥*1 [ğ‘¡* ] and ğ¶ âŠ¢ instr *1 : [ğ‘¡* ] â†’ğ‘¥*2 [ğ‘¡*2 ]), where ğ‘¥* = ğ‘¥*1 ğ‘¥*2 .
Ã² Note

7.5. Type System Properties

269

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

This property holds because validation is required even for unreachable code. Without that, instr *2 might not
be valid in isolation.

7.6 Validation Algorithm
The specification of WebAssembly validation is purely declarative. It describes the constraints that must be met
by a module or instruction sequence to be valid.
This section sketches the skeleton of a sound and complete algorithm for effectively validating code, i.e., sequences
of instructions. (Other aspects of validation are straightforward to implement.)
In fact, the algorithm is expressed over the flat sequence of opcodes as occurring in the binary format, and performs
only a single pass over it. Consequently, it can be integrated directly into a decoder.
The algorithm is expressed in typed pseudo code whose semantics is intended to be self-explanatory.

7.6.1 Data Structures
Types
Value types are representable as sets of enumerations:
type num_type = I32 | I64 | F32 | F64
type vec_type = V128
type heap_type =
Any | Eq | I31 | Struct | Array | None |
Func | Nofunc | Exn | Noexn | Extern | Noextern | Bot |
Def(def : def_type)
type ref_type = Ref(heap : heap_type, null : bool)
type val_type = num_type | vec_type | ref_type | Bot
func is_num(t : val_type) : bool =
return t = I32 || t = I64 || t = F32 || t = F64 || t = Bot
func is_vec(t : val_type) : bool =
return t = V128 || t = Bot
func is_ref(t : val_type) : bool =
return not (is_num t || is_vec t) || t = Bot
Similarly, defined types def_type can be represented:
type packed_type = I8 | I16
type field_type = Field(val : val_type | packed_type, mut : bool)
type struct_type = Struct(fields : list(field_type))
type array_type = Array(fields : field_type)
type func_type = Func(params : list(val_type), results : list(val_type))
type comp_type = struct_type | array_type | func_type
type sub_type = Sub(super : list(def_type), body : comp_type, final : bool)
type rec_type = Rec(types : list(sub_type))
type def_type = Def(rec : rec_type, proj : int32)
func unpack_field(t : field_type) : val_type =
if (it = I8 || t = I16) return I32
return t
(continues on next page)

270

Chapter 7. Appendix

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

(continued from previous page)

func expand_def(t : def_type) : comp_type =
return t.rec.types[t.proj].body
These representations assume that all types have been closed by substituting all type indices (in concrete heap types
and in sub types) with their respective defined types. This includes recursive references to enclosing defined types,
such that type representations form graphs and may be cyclic for recursive types.
We assume that all types have been canonicalized, such that equality on two type representations holds if and only
if their closures are syntactically equivalent, making it a constant-time check.
Ã² Note
For the purpose of type canonicalization, recursive references from a heap type to an enclosing recursive type
(i.e., forward edges in the graph that form a cycle) need to be distinguished from references to previously
defined types. However, this distinction does not otherwise affect validation, so is ignored here. In the graph
representation, all recursive types are effectively infinitely unrolled.
We further assume that validation and subtyping checks are defined on value types, as well as a few auxiliary
functions on composite types:
func validate_val_type(t : val_type)
func validate_ref_type(t : ref_type)
func matches_val(t1 : val_type, t2 : val_type) : bool
func matches_ref(t1 : val_type, t2 : val_type) : bool
func is_func(t : comp_type) : bool
func is_struct(t : comp_type) : bool
func is_array(t : comp_type) : bool
Finally, the following function computes the least precise supertype of a given heap type (its corresponding top
type):
func top_heap_type(t : heap_type) : heap_type =
switch (t)
case (Any | Eq | I31 | Struct | Array | None)
return Any
case (Func | Nofunc)
return Func
case (Extern | Noextern)
return Extern
case (Def(dt))
switch (dt.rec.types[dt.proj].body)
case (Struct(_) | Array(_))
return Any
case (Func(_))
return Func
case (Bot)
raise CannotOccurInSource
Context
Validation requires a context for checking uses of indices. For the purpose of presenting the algorithm, it is maintained in a set of global variables:

7.6. Validation Algorithm

271

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

var return_type : list(val_type)
var types : array(def_type)
var locals : array(val_type)
var locals_init : array(bool)
var globals : array(global_type)
var funcs : array(func_type)
var tables : array(table_type)
var mems : array(mem_type)
This assumes suitable representations for the various types besides val_type, which are omitted here.
For locals, there is an additional array recording the initialization status of each local.
Stacks
The algorithm uses three separate stacks: the value stack, the control stack, and the initialization stack. The value
stack tracks the types of operand values on the stack. The control stack tracks surrounding structured control
instructions and their associated blocks. The initialization stack records all locals that have been initialized since
the beginning of the function.
type val_stack = stack(val_type)
type init_stack = stack(u32)
type ctrl_stack = stack(ctrl_frame)
type ctrl_frame = {
opcode : opcode
start_types : list(val_type)
end_types : list(val_type)
val_height : nat
init_height : nat
unreachable : bool
}
For each entered block, the control stack records a control frame with the originating opcode, the types on the top
of the operand stack at the start and end of the block (used to check its result as well as branches), the height of the
operand stack at the start of the block (used to check that operands do not underflow the current block), the height
of the initialization stack at the start of the block (used to reset initialization status at the end of the block), and a
flag recording whether the remainder of the block is unreachable (used to handle stack-polymorphic typing after
branches).
For the purpose of presenting the algorithm, these stacks are simply maintained as global variables:
var vals : val_stack
var inits : init_stack
var ctrls : ctrl_stack
However, these variables are not manipulated directly by the main checking function, but through a set of auxiliary
functions:
func push_val(type : val_type) =
vals.push(type)
func pop_val() : val_type =
if (vals.size() = ctrls[0].val_height && ctrls[0].unreachable) return Bot
error_if(vals.size() = ctrls[0].val_height)
return vals.pop()
func pop_val(expect : val_type) : val_type =
let actual = pop_val()
(continues on next page)

272

Chapter 7. Appendix

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

(continued from previous page)

error_if(not matches_val(actual, expect))
return actual
func pop_num() : num_type | Bot =
let actual = pop_val()
error_if(not is_num(actual))
return actual
func pop_ref() : ref_type =
let actual = pop_val()
error_if(not is_ref(actual))
if (actual = Bot) return Ref(Bot, false)
return actual
func push_vals(types : list(val_type)) = foreach (t in types) push_val(t)
func pop_vals(types : list(val_type)) : list(val_type) =
var popped := []
foreach (t in reverse(types)) popped.prepend(pop_val(t))
return popped
Pushing an operand value simply pushes the respective type to the value stack.
Popping an operand value checks that the value stack does not underflow the current block and then removes
one type. But first, a special case is handled where the block contains no known values, but has been marked as
unreachable. That can occur after an unconditional branch, when the stack is typed polymorphically. In that case,
the Bot type is returned, because that is a principal choice trivially satisfying all use constraints.
A second function for popping an operand value takes an expected type, which the actual operand type is checked
against. The types may differ by subtyping, including the case where the actual type is Bot, and thereby matches
unconditionally. The function returns the actual type popped from the stack.
Finally, there are accumulative functions for pushing or popping multiple operand types.
Ã² Note
The notation stack[i] is meant to index the stack from the top, so that, e.g., ctrls[0] accesses the element
pushed last.
The initialization stack and the initialization status of locals is manipulated through the following functions:
func get_local(idx : u32) =
error_if(not locals_init[idx])
func set_local(idx : u32) =
if (not locals_init[idx])
inits.push(idx)
locals_init[idx] := true
func reset_locals(height : nat) =
while (inits.size() > height)
locals_init[inits.pop()] := false
Getting a local verifies that it is known to be initialized. When a local is set that was not set already, then its
initialization status is updated and the change is recorded in the initialization stack. Thus, the initialization status
of all locals can be reset to a previous state by denoting a specific height in the initialization stack.
The size of the initialization stack is bounded by the number of (non-defaultable) locals in a function, so can be
preallocated by an algorithm.

7.6. Validation Algorithm

273

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

The control stack is likewise manipulated through auxiliary functions:
func push_ctrl(opcode : opcode, in : list(val_type), out : list(val_type)) =
let frame = ctrl_frame(opcode, in, out, vals.size(), inits.size(), false)
ctrls.push(frame)
push_vals(in)
func pop_ctrl() : ctrl_frame =
error_if(ctrls.is_empty())
let frame = ctrls[0]
pop_vals(frame.end_types)
error_if(vals.size() =/= frame.val_height)
reset_locals(frame.init_height)
ctrls.pop()
return frame
func label_types(frame : ctrl_frame) : list(val_types) =
return (if (frame.opcode = loop) frame.start_types else frame.end_types)
func unreachable() =
vals.resize(ctrls[0].val_height)
ctrls[0].unreachable := true
Pushing a control frame takes the types of the label and result values. It allocates a new frame record recording
them along with the current height of the operand stack and marks the block as reachable.
Popping a frame first checks that the control stack is not empty. It then verifies that the operand stack contains the
right types of values expected at the end of the exited block and pops them off the operand stack. Afterwards, it
checks that the stack has shrunk back to its initial height. Finally, it undoes all changes to the initialization status
of locals that happend inside the block.
The type of the label associated with a control frame is either that of the stack at the start or the end of the frame,
determined by the opcode that it originates from.
Finally, the current frame can be marked as unreachable. In that case, all existing operand types are purged from the
value stack, in order to allow for the stack-polymorphism logic in pop_val to take effect. Because every function
has an implicit outermost label that corresponds to an implicit block frame, it is an invariant of the validation
algorithm that there always is at least one frame on the control stack when validating an instruction, and hence,
ctrls[0] is always defined.
Ã² Note
Even with the unreachable flag set, consecutive operands are still pushed to and popped from the operand stack.
That is necessary to detect invalid examples like (unreachable (i32.const) i64.add). However, a polymorphic
stack cannot underflow, but instead generates Bot types as needed.

7.6.2 Validation of Opcode Sequences
The following function shows the validation of a number of representative instructions that manipulate the stack.
Other instructions are checked in a similar manner.
func validate(opcode) =
switch (opcode)
case (i32.add)
pop_val(I32)
pop_val(I32)
push_val(I32)
(continues on next page)

274

Chapter 7. Appendix

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

(continued from previous page)

case (drop)
pop_val()
case (select)
pop_val(I32)
let t1 = pop_val()
let t2 = pop_val()
error_if(not (is_num(t1) && is_num(t2) || is_vec(t1) && is_vec(t2)))
error_if(t1 =/= t2 && t1 =/= Bot && t2 =/= Bot)
push_val(if (t1 = Bot) t2 else t1)
case (select t)
pop_val(I32)
pop_val(t)
pop_val(t)
push_val(t)
case (ref.is_null)
pop_ref()
push_val(I32)
case (ref.as_non_null)
let rt = pop_ref()
push_val(Ref(rt.heap, false))
case (ref.test rt)
validate_ref_type(rt)
pop_val(Ref(top_heap_type(rt), true))
push_val(I32)
case (local.get x)
get_local(x)
push_val(locals[x])
case (local.set x)
pop_val(locals[x])
set_local(x)
case (unreachable)
unreachable()
case (block t1*->t2*)
pop_vals([t1*])
push_ctrl(block, [t1*], [t2*])
case (loop t1*->t2*)
pop_vals([t1*])
push_ctrl(loop, [t1*], [t2*])
case (if t1*->t2*)
pop_val(I32)
pop_vals([t1*])
push_ctrl(if, [t1*], [t2*])
case (end)
let frame = pop_ctrl()
(continues on next page)

7.6. Validation Algorithm

275

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

(continued from previous page)

push_vals(frame.end_types)
case (else)
let frame = pop_ctrl()
error_if(frame.opcode =/= if)
push_ctrl(else, frame.start_types, frame.end_types)
case (br n)
error_if(ctrls.size() < n)
pop_vals(label_types(ctrls[n]))
unreachable()
case (br_if n)
error_if(ctrls.size() < n)
pop_val(I32)
pop_vals(label_types(ctrls[n]))
push_vals(label_types(ctrls[n]))
case (br_table n* m)
pop_val(I32)
error_if(ctrls.size() < m)
let arity = label_types(ctrls[m]).size()
foreach (n in n*)
error_if(ctrls.size() < n)
error_if(label_types(ctrls[n]).size() =/= arity)
push_vals(pop_vals(label_types(ctrls[n])))
pop_vals(label_types(ctrls[m]))
unreachable()
case (br_on_null n)
error_if(ctrls.size() < n)
let rt = pop_ref()
pop_vals(label_types(ctrls[n]))
push_vals(label_types(ctrls[n]))
push_val(Ref(rt.heap, false))
case (br_on_cast n rt1 rt2)
validate_ref_type(rt1)
validate_ref_type(rt2)
pop_val(rt1)
push_val(rt2)
pop_vals(label_types(ctrls[n]))
push_vals(label_types(ctrls[n]))
pop_val(rt2)
push_val(diff_ref_type(rt2, rt1))
case (return)
pop_vals(return_types)
unreachable()
case (call_ref x)
let t = expand_def(types[x])
error_if(not is_func(t))
pop_vals(t.params)
pop_val(Ref(Def(types[x])))
push_vals(t.results)
(continues on next page)

276

Chapter 7. Appendix

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

(continued from previous page)

case (return_call_ref x)
let t = expand_def(types[x])
error_if(not is_func(t))
pop_vals(t.params)
pop_val(Ref(Def(types[x])))
error_if(t.results.len() =/= return_types.len())
push_vals(t.results)
pop_vals(return_types)
unreachable()
case (struct.new x)
let t = expand_def(types[x])
error_if(not is_struct(t))
for (ti in reverse(t.fields))
pop_val(unpack_field(ti))
push_val(Ref(Def(types[x])))
case (struct.set x n)
let t = expand_def(types[x])
error_if(not is_struct(t) || n >= t.fields.len())
pop_val(Ref(Def(types[x])))
pop_val(unpack_field(st.fields[n]))
case (throw x)
pop_vals(tags[x].type.params)
unreachable()
case (try_table t1*->t2* handler*)
pop_vals([t1*])
foreach (handler in handler*)
error_if(ctrls.size() < handler.label)
push_ctrl(catch, [], label_types(ctrls[handler.label]))
switch (handler.clause)
case (catch x)
push_vals(tags[x].type.params)
case (catch_ref x)
push_vals(tags[x].type.params)
push_val(Exnref)
case (catch_all)
skip
case (catch_all_ref)
push_val(Exnref)
pop_ctrl()
push_ctrl(try_table, [t1*], [t2*])

Ã² Note
It is an invariant under the current WebAssembly instruction set that an operand of Bot type is never duplicated
on the stack. This would change if the language were extended with stack instructions like dup. Under such an
extension, the above algorithm would need to be refined by replacing the Bot type with proper type variables
to ensure that all uses are consistent.

7.6. Validation Algorithm

277

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

7.7 Custom Sections and Annotations
This appendix defines dedicated custom sections for WebAssemblyâ€™s binary format and annotations for the text
format. Such sections or annotations do not contribute to, or otherwise affect, the WebAssembly semantics, and
may be ignored by an implementation. However, they provide useful meta data that implementations can make use
of to improve user experience or take compilation hints.

7.7.1 Name Section
The name section is a custom section whose name string is itself â€˜nameâ€™. The name section should appear only
once in a module, and only after the data section.
The purpose of this section is to attach printable names to definitions in a module, which e.g. can be used by a
debugger or when parts of the module are to be rendered in text form.
Ã² Note
All names are represented in Unicode57 encoded in UTF-8. Names need not be unique.
Subsections
The data of a name section consists of a sequence of subsections. Each subsection consists of a
â€¢ a one-byte subsection id,
â€¢ the u32 size of the contents, in bytes,
â€¢ the actual contents, whose structure is dependent on the subsection id.
::= section0 (namedata)
::= ğ‘›:name
(if ğ‘› = â€˜nameâ€™)
modulenamesubsec?
funcnamesubsec?
localnamesubsec?
typenamesubsec?
fieldnamesubsec?
tagnamesubsec?
namesubsectionğ‘ (B) ::= ğ‘ :byte size:u32 B
(if size = ||B||)
namesec
namedata

The following subsection ids are used:
Id

Subsection

0
1
2
4
10
11

module name
function names
local names
type names
field names
tag names

Each subsection may occur at most once, and in order of increasing id.
Name Maps
A name map assigns names to indices in a given index space. It consists of a vector of index/name pairs in order
of increasing index value. Each index must be unique, but the assigned names need not be.
namemap
::=
nameassoc ::=

vec(nameassoc)
idx name

57 https://www.unicode.org/versions/latest/

278

Chapter 7. Appendix

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

An indirect name map assigns names to a two-dimensional index space, where secondary indices are grouped by
primary indices. It consists of a vector of primary index/name map pairs in order of increasing index value, where
each name map in turn maps secondary indices to names. Each primary index must be unique, and likewise each
secondary index per individual name map.
indirectnamemap
::=
indirectnameassoc ::=

vec(indirectnameassoc)
idx namemap

Module Names
The module name subsection has the id 0. It simply consists of a single name that is assigned to the module itself.
modulenamesubsec ::= namesubsection0 (name)

Function Names
The function name subsection has the id 1. It consists of a name map assigning function names to function indices.
funcnamesubsec ::= namesubsection1 (namemap)

Local Names
The local name subsection has the id 2. It consists of an indirect name map assigning local names to local indices
grouped by function indices.
localnamesubsec ::= namesubsection2 (indirectnamemap)

Type Names
The type name subsection has the id 4. It consists of a name map assigning type names to type indices.
typenamesubsec ::= namesubsection4 (namemap)

Field Names
The field name subsection has the id 10. It consists of an indirect name map assigning field names to field indices
grouped by the type indices of their respective structure types.
fieldnamesubsec ::= namesubsection1 0(indirectnamemap)

Tag Names
The tag name subsection has the id 11. It consists of a name map assigning tag names to tag indices.
tagnamesubsec ::= namesubsection1 (namemap)

7.7. Custom Sections and Annotations

279

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

7.7.2 Name Annotations
Name annotations are the textual analogue to the name section and provide a textual representation for it. Consequently, their id is @name.
Analogous to the name section, name annotations are allowed on modules, functions, and locals (including parameters). They can be placed where the text format allows binding occurrences of respective identifiers. If both
an identifier and a name annotation are given, the annotation is expected after the identifier. In that case, the annotation takes precedence over the identifier as a textual representation of the bindingâ€™s name. At most one name
annotation may be given per binding.
All name annotations have the following format:
nameannot

::= â€˜(@nameâ€™ string â€˜)â€™

Ã² Note
All name annotations can be arbitrary UTF-8 strings. Names need not be unique.

Module Names
A module name annotation must be placed on a module definition, directly after the â€˜moduleâ€™ keyword, or if
present, after the following module identifier.
modulenameannot ::=

nameannot

Function Names
A function name annotation must be placed on a function definition or function import, directly after the â€˜funcâ€™
keyword, or if present, after the following function identifier or.
funcnameannot ::= nameannot

Parameter Names
A parameter name annotation must be placed on a parameter declaration, directly after the â€˜paramâ€™ keyword, or
if present, after the following parameter identifier. It may only be placed on a declaration that declares exactly one
parameter.
paramnameannot ::= nameannot

Local Names
A local name annotation must be placed on a local declaration, directly after the â€˜localâ€™ keyword, or if present,
after the following local identifier. It may only be placed on a declaration that declares exactly one local.
localnameannot ::= nameannot

Type Names
A type name annotation must be placed on a type declaration, directly after the â€˜typeâ€™ keyword, or if present, after
the following type identifier.
typenameannot ::= nameannot

280

Chapter 7. Appendix

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

Field Names
A field name annotation must be placed on the field of a structure type, directly after the â€˜fieldâ€™ keyword, or if
present, after the following field identifier. It may only be placed on a declaration that declares exactly one field.
fieldnameannot ::= nameannot

Tag Names
A tag name annotation must be placed on a tag declaration or tag import, directly after the â€˜tagâ€™ keyword, or if
present, after the following tag identifier.
tagnameannot

::= nameannot

7.7.3 Custom Annotations
Custom annotations are a generic textual representation for any custom section. Their id is @custom. By generating custom annotations, tools converting between binary format and text format can maintain and round-trip the
content of custom sections even when they do not recognize them.
Custom annotations must be placed inside a module definition. They must occur anywhere after the â€˜moduleâ€™
keyword, or if present, after the following module identifier. They must not be nested into other constructs.
customannot
customplace

sec

::=
::=
|
|
|
::=
|
|
|
|
|
|
|
|
|
|
|

â€˜(@customâ€™ string customplace? datastring â€˜)â€™
â€˜(â€™ â€˜beforeâ€™ â€˜firstâ€™ â€˜)â€™
â€˜(â€™ â€˜beforeâ€™ sec â€˜)â€™
â€˜(â€™ â€˜afterâ€™ sec â€˜)â€™
â€˜(â€™ â€˜afterâ€™ â€˜lastâ€™ â€˜)â€™
â€˜typeâ€™
â€˜importâ€™
â€˜funcâ€™
â€˜tableâ€™
â€˜memoryâ€™
â€˜globalâ€™
â€˜exportâ€™
â€˜startâ€™
â€˜elemâ€™
â€˜codeâ€™
â€˜dataâ€™
â€˜datacountâ€™

The first string in a custom annotation denotes the name of the custom section it represents. The remaining strings
collectively represent the sectionâ€™s payload data, written as a data string, which can be split up into a possibly empty
sequence of individual string literals (similar to data segments).
An arbitrary number of custom annotations (even of the same name) may occur in a module, each defining a separate
custom section when converting to binary format. Placement of the sections in the binary can be customized via
explicit placement directives, that position them either directly before or directly after a known section. That section
must exist and be non-empty in the binary encoding of the annotated module. The placements (before first)
and (after last) denote virtual sections before the first and after the last known section, respectively. When the
placement directive is omitted, it defaults to (after last).
If multiple placement directives appear for the same position, then the sections are all placed there, in order of
their appearance in the text. For this purpose, the position after a section is considered different from the position
before the consecutive section, and the former occurs before the latter.

7.7. Custom Sections and Annotations

281

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

Ã² Note
Future versions of WebAssembly may introduce additional sections between others or at the beginning or end
of a module. Using first and last guarantees that placement will still go before or after any future section,
respectively.
If a custom section with a specific section id is given as well as annotations representing the same custom section
(e.g., @name annotations as well as a @custom annotation for a name section), then two sections are assumed to
be created. Their relative placement will depend on the placement directive given for the @custom annotation as
well as the implicit placement requirements of the custom section, which are applied to the other annotation.
Ã² Note
For example, the following module,
(module
(@custom "A" "aaa")
(type $t (func))
(@custom "B" (after func) "bbb")
(@custom "C" (before func) "ccc")
(@custom "D" (after last) "ddd")
(table 10 funcref)
(func (type $t))
(@custom "E" (after import) "eee")
(@custom "F" (before type) "fff")
(@custom "G" (after data) "ggg")
(@custom "H" (after code) "hhh")
(@custom "I" (after func) "iii")
(@custom "J" (before func) "jjj")
(@custom "K" (before first) "kkk")
)
will result in the following section ordering:
custom section "K"
custom section "F"
type section
custom section "E"
custom section "C"
custom section "J"
function section
custom section "B"
custom section "I"
table section
code section
custom section "H"
custom section "G"
custom section "A"
custom section "D"

7.8 Change History
Since the original release 1.0 of the WebAssembly specification, a number of proposals for extensions have been
integrated. The following sections provide an overview of what has changed.
All present and future versions of WebAssembly are intended to be backwards-compatible with all previous ver-

282

Chapter 7. Appendix

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

sions. Concretely:
1. All syntactically well-formed (in binary or text format) and valid modules remain well-formed and valid with
an equivalent module type (or a subtype).
Ã² Note
This allows previously malformed or invalid modules to become legal, e.g., by adding new features
or by relaxing typing rules.
It also allows reclassifying previously malformed modules as well-formed but invalid, or vice
versa.
And it allows refining the typing of imports and exports, such that previously unlinkable modules
become linkable.
Historically, minor breaking changes to the text format have been allowed that turned previously
possible valid modules invalid, as long as they were unlikely to occur in practice.
2. All non-trapping executions of a valid program retain their behaviour with an equivalent set of possible
results (or a non-empty subset).
Ã² Note
This allows previously malformed or invalid programs to become executable.
It also allows program executions that previously trapped to execute successfully, although the
intention is to only exercise this where the possibility of such an extension has been previously
noted.
And it allows reducing the set of observable behaviours of a program execution, e.g., by reducing
non-determinism.
In a program linking prior modules with modules using new features, a prior module may encounter
new behaviours, e.g., new forms of control flow or side effects when calling into a latter module.
In addition, future versions of WebAssembly will not allocate the opcode 0xFF to represent an instruction or
instruction prefix.

7.8.1 Release 2.0
Sign Extension Instructions
Added new numeric instructions for performing sign extension within integer representations.58
â€¢ New numeric instructions:
â€“ inn.extendN _s
Non-trapping Float-to-Int Conversions
Added new conversion instructions that avoid trapping when converting a floating-point number to an integer.59
â€¢ New numeric instructions:
â€“ inn.trunc_sat_fmm_sx
58 https://github.com/WebAssembly/spec/tree/main/proposals/sign-extension-ops/

59 https://github.com/WebAssembly/spec/tree/main/proposals/nontrapping-float-to-int-conversion/

7.8. Change History

283

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

Multiple Values
Generalized the result type of blocks and functions to allow for multiple values; in addition, introduced the ability
to have block parameters.60
â€¢ Function types allow more than one result
â€¢ Block types can be arbitrary function types
Reference Types
Added funcref and externref as new value types and respective instructions.61
â€¢ New reference value types:
â€“ funcref
â€“ externref
â€¢ New reference instructions:
â€“ ref.null
â€“ ref.func
â€“ ref.is_null
â€¢ Extended parametric instruction:
â€“ select with optional type immediate
â€¢ New declarative form of element segment
Table Instructions
Added instructions to directly access and modify tables.61
â€¢ Table types allow any reference type as element type
â€¢ New table instructions:
â€“ table.get
â€“ table.set
â€“ table.size
â€“ table.grow
Multiple Tables
Added the ability to use multiple tables per module.61
â€¢ Modules may
â€“ define multiple tables
â€“ import multiple tables
â€“ export multiple tables
â€¢ Table instructions take a table index immediate:
â€“ table.get
â€“ table.set
â€“ table.size
â€“ table.grow
60 https://github.com/WebAssembly/spec/tree/main/proposals/multi-value/

61 https://github.com/WebAssembly/spec/tree/main/proposals/reference-types/

284

Chapter 7. Appendix

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

â€“ call_indirect
â€¢ Element segments take a table index
Bulk Memory and Table Instructions
Added instructions that modify ranges of memory or table entries.Page 284, 6162
â€¢ New memory instructions:
â€“ memory.fill
â€“ memory.init
â€“ memory.copy
â€“ data.drop
â€¢ New table instructions:
â€“ table.fill
â€“ table.init
â€“ table.copy
â€“ elem.drop
â€¢ New passive form of data segment
â€¢ New passive form of element segment
â€¢ New data count section in binary format
â€¢ Active data and element segments boundaries are no longer checked at compile time but may trap instead
Vector Instructions
Added vector type and instructions that manipulate multiple numeric values in parallel (also known as SIMD, single
instruction multiple data)63
â€¢ New value type:
â€“ v128
â€¢ New memory instructions:
â€“ v128.load
â€“ v128.loadğ‘xğ‘€_sx
â€“ v128.loadğ‘ _zero
â€“ v128.loadğ‘ _splat
â€“ v128.loadğ‘ _lane
â€“ v128.store
â€“ v128.storeğ‘ _lane
â€¢ New constant vector instruction:
â€“ v128.const
â€¢ New unary vector instructions:
â€“ v128.not
â€“ iğ‘xğ‘€.abs
â€“ iğ‘xğ‘€.neg
62 https://github.com/WebAssembly/spec/tree/main/proposals/bulk-memory-operations/
63 https://github.com/WebAssembly/spec/tree/main/proposals/simd/

7.8. Change History

285

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

â€“ i8x16.popcnt
â€“ fğ‘xğ‘€.abs
â€“ fğ‘xğ‘€.neg
â€“ fğ‘xğ‘€.sqrt
â€“ fğ‘xğ‘€.ceil
â€“ fğ‘xğ‘€.floor
â€“ fğ‘xğ‘€.trunc
â€“ fğ‘xğ‘€.nearest
â€¢ New binary vector instructions:
â€“ v128.and
â€“ v128.andnot
â€“ v128.or
â€“ v128.xor
â€“ iğ‘xğ‘€.add
â€“ iğ‘xğ‘€.sub
â€“ iğ‘xğ‘€.mul
â€“ iğ‘xğ‘€.add_sat_sx
â€“ iğ‘xğ‘€.sub_sat_sx
â€“ iğ‘xğ‘€.min_sx
â€“ iğ‘xğ‘€.max_sx
â€“ iğ‘xğ‘€.shl
â€“ iğ‘xğ‘€.shr_sx
â€“ fğ‘xğ‘€.add
â€“ fğ‘xğ‘€.sub
â€“ fğ‘xğ‘€.mul
â€“ fğ‘xğ‘€.div
â€“ i16x8.extadd_pairwise_i8x16_sx
â€“ i32x4.extadd_pairwise_i16x8_sx
â€“ iğ‘xğ‘€.extmul_half _iğ‘ â€²xğ‘€ â€²_sx
â€“ i16x8.q15mulr_sat_s
â€“ i32x4.dot_i16x8_s
â€“ i8x16.avgr_u
â€“ i16x8.avgr_u
â€“ fğ‘xğ‘€.min
â€“ fğ‘xğ‘€.max
â€“ fğ‘xğ‘€.pmin
â€“ fğ‘xğ‘€.pmax
â€¢ New ternary vector instruction:
â€“ v128.bitselect

286

Chapter 7. Appendix

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

â€¢ New test vector instructions:
â€“ v128.any_true
â€“ iğ‘xğ‘€.all_true
â€¢ New relational vector instructions:
â€“ iğ‘xğ‘€.eq
â€“ iğ‘xğ‘€.ne
â€“ iğ‘xğ‘€.lt_sx
â€“ iğ‘xğ‘€.gt_sx
â€“ iğ‘xğ‘€.le_sx
â€“ iğ‘xğ‘€.ge_sx
â€“ fğ‘xğ‘€.eq
â€“ fğ‘xğ‘€.ne
â€“ fğ‘xğ‘€.lt
â€“ fğ‘xğ‘€.gt
â€“ fğ‘xğ‘€.le
â€“ fğ‘xğ‘€.ge
â€¢ New conversion vector instructions:
â€“ i32x4.trunc_sat_f32x4_sx
â€“ i32x4.trunc_sat_f64x2_sx _zero
â€“ f32x4.convert_i32x4_sx
â€“ f32x4.demote_f64x2_zero
â€“ f64x2.convert_low_i32x4_sx
â€“ f64x2.promote_low_f32x4
â€¢ New lane access vector instructions:
â€“ iğ‘xğ‘€.extract_lane_sx ?
â€“ iğ‘xğ‘€.replace_lane
â€“ fğ‘xğ‘€.extract_lane
â€“ fğ‘xğ‘€.replace_lane
â€¢ New lane splitting/combining vector instructions:
â€“ iğ‘xğ‘€.extend_half _iğ‘ â€²xğ‘€ â€²_sx
â€“ i8x16.narrow_i16x8_sx
â€“ i16x8.narrow_i32x4_sx
â€¢ New byte reordering vector instructions:
â€“ i8x16.shuffle
â€“ i8x16.swizzle
â€¢ New injection/projection vector instructions:
â€“ iğ‘xğ‘€.splat
â€“ fğ‘xğ‘€.splat
â€“ iğ‘xğ‘€.bitmask

7.8. Change History

287

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

7.8.2 Release 3.0
Extended Constant Expressions
Allowed basic numeric computations in constant expressions.64
â€¢ Extended set of constant instructions with:
â€“ inn.add
â€“ inn.sub
â€“ inn.mul
â€“ global.get for any previously declared immutable global
Ã² Note
The garbage collection extension added further constant instructions.

Tail Calls
Added instructions to perform tail calls.65
â€¢ New control instructions:
â€“ return_call
â€“ return_call_indirect
Exception Handling
Added tag definitions, imports, and exports, and instructions to throw and catch exceptions66
â€¢ Modules may
â€“ define tags
â€“ import tags
â€“ export tags
â€¢ New heap types:
â€“ exn
â€“ noexn
â€¢ New reference type short-hands:
â€“ exnref
â€“ nullexnref
â€¢ New control instructions:
â€“ throw
â€“ throw_ref
â€“ try_table
â€¢ New tag section in binary format.
64 https://github.com/WebAssembly/spec/tree/main/proposals/extended-const/
65 https://github.com/WebAssembly/spec/tree/main/proposals/tail-call/

66 https://github.com/WebAssembly/spec/tree/main/proposals/exception-handling/

288

Chapter 7. Appendix

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

Multiple Memories
Added the ability to use multiple memories per module.67
â€¢ Modules may
â€“ define multiple memories
â€“ import multiple memories
â€“ export multiple memories
â€¢ Memory instructions take a memory index immediate:
â€“ memory.size
â€“ memory.grow
â€“ memory.fill
â€“ memory.copy
â€“ memory.init
â€“ ğ‘¡.load
â€“ ğ‘¡.store
â€“ ğ‘¡.loadğ‘_sx
â€“ ğ‘¡.storeğ‘
â€“ v128.loadğ‘xğ‘€_sx
â€“ v128.loadğ‘_zero
â€“ v128.loadğ‘_splat
â€“ v128.loadğ‘_lane
â€“ v128.storeğ‘_lane
â€¢ Data segments take a memory index
64-bit Address Space
Added the ability to declare an i64 address type for tables and memories.68
â€¢ Address types denote a subset of the integral number types
â€¢ Table types include an address type
â€¢ Memory types include an address type
â€¢ Operand types of table and memory instructions now depend on the subjectâ€™s declared address type:
â€“ table.get
â€“ table.set
â€“ table.size
â€“ table.grow
â€“ table.fill
â€“ table.copy
â€“ table.init
â€“ memory.size
â€“ memory.grow
67 https://github.com/WebAssembly/spec/tree/main/proposals/multi-memory/
68 https://github.com/WebAssembly/spec/tree/main/proposals/memory64/

7.8. Change History

289

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

â€“ memory.fill
â€“ memory.copy
â€“ memory.init
â€“ ğ‘¡.load
â€“ ğ‘¡.store
â€“ ğ‘¡.loadğ‘_sx
â€“ ğ‘¡.storeğ‘
â€“ v128.loadğ‘xğ‘€_sx
â€“ v128.loadğ‘_zero
â€“ v128.loadğ‘_splat
â€“ v128.loadğ‘_lane
â€“ v128.storeğ‘_lane
Typeful References
Added more precise types for references.69
â€¢ New generalised form of reference types:
â€“ (ref null? heaptype)
â€¢ New class of heap types:
â€“ func
â€“ extern
â€“ typeidx
â€¢ Basic subtyping on reference and value types
â€¢ New reference instructions:
â€“ ref.as_non_null
â€“ br_on_null
â€“ br_on_non_null
â€¢ New control instruction:
â€“ call_ref
â€¢ Refined typing of reference instruction:
â€“ ref.func with more precise result type
â€¢ Refined typing of local instructions and instruction sequences to track the initialization status of locals with
non-defaultable type
â€¢ Refined decoding of active element segments with implicit element type and plain function indices (opcode
0) to produce non-nullable reference type.
â€¢ Extended table definitions with optional initializer expression
69 https://github.com/WebAssembly/spec/tree/main/proposals/function-references/

290

Chapter 7. Appendix

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

Garbage Collection
Added managed reference types.70
â€¢ New forms of heap types:
â€“ any
â€“ eq
â€“ i31
â€“ struct
â€“ array
â€“ none
â€“ nofunc
â€“ noextern
â€¢ New reference type short-hands:
â€“ anyref
â€“ eqref
â€“ i31ref
â€“ structref
â€“ arrayref
â€“ nullref
â€“ nullfuncref
â€“ nullexternref
â€¢ New forms of type definitions:
â€“ structure
â€“ array types
â€“ sub types
â€“ recursive types
â€¢ Enriched subtyping based on explicitly declared sub types and the new heap types
â€¢ New generic reference instructions:
â€“ ref.eq
â€“ ref.test
â€“ ref.cast
â€“ br_on_cast
â€“ br_on_cast_fail
â€¢ New reference instructions for unboxed scalars:
â€“ ref.i31
â€“ i31.get_sx
â€¢ New reference instructions for structure types:
â€“ struct.new
â€“ struct.new_default
70 https://github.com/WebAssembly/spec/tree/main/proposals/gc/

7.8. Change History

291

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

â€“ struct.get_sx ?
â€“ struct.set
â€¢ New reference instructions for array types:
â€“ array.new
â€“ array.new_default
â€“ array.new_fixed
â€“ array.new_data
â€“ array.new_elem
â€“ array.get_sx ?
â€“ array.set
â€“ array.len
â€“ array.fill
â€“ array.copy
â€“ array.init_data
â€“ array.init_elem
â€¢ New reference instructions for converting external types:
â€“ any.convert_extern
â€“ extern.convert_any
â€¢ Extended set of constant instructions with:
â€“ ref.i31
â€“ struct.new
â€“ struct.new_default
â€“ array.new
â€“ array.new_default
â€“ array.new_fixed
â€“ any.convert_extern
â€“ extern.convert_any
Relaxed Vector Instructions
Added new relaxed vector instructions, whose behaviour is non-deterministic and implementation-dependent.71
â€¢ New binary vector instruction:
â€“ fğ‘xğ‘€.relaxed_min
â€“ fğ‘xğ‘€.relaxed_max
â€“ i16x8.relaxed_q15mulr_s
â€“ i16x8.relaxed_dot_i8x16_i7x16_s
â€¢ New ternary vector instruction:
â€“ fğ‘xğ‘€.relaxed_madd
â€“ fğ‘xğ‘€.relaxed_nmadd
71 https://github.com/WebAssembly/spec/tree/main/proposals/relaxed-simd/

292

Chapter 7. Appendix

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

â€“ iğ‘xğ‘€.relaxed_laneselect
â€“ i32x4.relaxed_dot_i8x16_i7x16_add_s
â€¢ New conversion vector instructions:
â€“ i32x4.relaxed_trunc_f32x4_sx
â€“ i32x4.relaxed_trunc_f64x2_sx _zero
â€¢ New byte reordering vector instruction:
â€“ i8x16.relaxed_swizzle
Profiles
Introduced the concept of profile for specifying language subsets.
â€¢ A new profile defining a deterministic mode of execution.
Custom Annotations
Added generic syntax for custom annotations in the text format, mirroring the role of custom sections in the binary
format.72
â€¢ Annotations of the form â€˜(@id . . . )â€™ are allowed anywhere in the text format
â€¢ Identifiers can be escaped as â€˜@â€ . . . â€â€™ with arbitrary names
â€¢ Defined name annotations â€˜(@name â€ . . . â€)â€™ for:
â€“ module names
â€“ type names
â€“ function names
â€“ local names
â€“ field names
â€¢ Defined custom annotation â€˜(@custom â€ . . . â€)â€™ to represent arbitrary custom sections in the text format

7.9 Index of Types
Category

Constructor

Binary Opcode

Type index
Number type
Number type
Number type
Number type
Vector type
(reserved)
Packed type
Packed type
(reserved)
Heap type
Heap type
Heap type
Heap type
Heap type
Heap type

ğ‘¥
i32
i64
f32
f64
v128

(positive number as s32 or u32)
0x7F (-1 as s7)
0x7E (-2 as s7)
0x7D (-3 as s7)
0x7C (-4 as s7)
0x7B (-5 as s7)
0x7A .. 0x79
0x78 (-8 as s7)
0x77 (-9 as s7)
0x78 .. 0x75
0x74 (-14 as s7)
0x73 (-13 as s7)
0x72 (-14 as s7)
0x71 (-15 as s7)
0x70 (-16 as s7)
0x6F (-17 as s7)
continues on next page

i8
i16
noexn
nofunc
noextern
none
func
extern

72 https://github.com/WebAssembly/annotations/tree/main/proposals/annotations/

7.9. Index of Types

293

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

Table 1 â€“ continued from previous page
Category

Constructor

Binary Opcode

Heap type
Heap type
Heap type
Heap type
Heap type
Heap type
(reserved)
Reference type
Reference type
(reserved)
Composite type
Composite type
Composite type
(reserved)
Sub type
Sub type
Recursive type
(reserved)
Result type
Table type
Memory type
Global type
Tag type

any
eq
i31
struct
array
exn

0x6E (-18 as s7)
0x6D (-19 as s7)
0x6C (-20 as s7)
0x6B (-21 as s7)
0x6A (-22 as s7)
0x69 (-23 as s7)
0x68 .. 0x65
0x64 (-28 as s7)
0x63 (-29 as s7)
0x62 .. 0x61
0x60 (-32 as s7)
0x5F (-33 as s7)
0x5E (-34 as s7)
0x5D .. 0x51
0x50 (-48 as s7)
0x4F (-49 as s7)
0x4E (-50 as s7)
0x4D .. 0x41
0x40 (-64 as s7)
(none)
(none)
(none)
(none)

ref
ref null
func [valtype * ] â†’ [valtype * ]
struct fieldtype *
array fieldtype
sub typeidx * comptype
sub final typeidx * comptype
rec subtype *
[ğœ–]
limits reftype
limits
mut valtype
functype

7.10 Index of Instructions
Instruction

Binary Opcode

Type

Validation

Executio

unreachable
nop
block bt
loop bt
if bt
else
(reserved)
(reserved)
throw ğ‘¥
(reserved)
throw_ref
end
br ğ‘™
br_if ğ‘™
br_table ğ‘™* ğ‘™
return
call ğ‘¥
call_indirect ğ‘¥ ğ‘¦
return_call ğ‘¥
return_call_indirect ğ‘¥ ğ‘¦
call_ref ğ‘¥
return_call_ref ğ‘¥
(reserved)
(reserved)
(reserved)

0x00
0x01
0x02
0x03
0x04
0x05
0x06
0x07
0x08
0x09
0x0A
0x0B
0x0C
0x0D
0x0E
0x0F
0x10
0x11
0x12
0x13
0x14
0x15
0x16
0x17
0x18

[ğ‘¡*1 ] â†’ [ğ‘¡*2 ]
[] â†’ []
[ğ‘¡*1 ] â†’ [ğ‘¡*2 ]
[ğ‘¡*1 ] â†’ [ğ‘¡*2 ]
[ğ‘¡*1 i32] â†’ [ğ‘¡*2 ]

validation
validation
validation
validation
validation

execution
execution
execution
execution
execution

[ğ‘¡*1 ğ‘¡*ğ‘¥ ] â†’ [ğ‘¡*2 ]

validation

execution

[ğ‘¡*1 exnref] â†’ [ğ‘¡*2 ]

validation

execution

[ğ‘¡*1 ğ‘¡* ] â†’ [ğ‘¡*2 ]
[ğ‘¡* i32] â†’ [ğ‘¡* ]
[ğ‘¡*1 ğ‘¡* i32] â†’ [ğ‘¡*2 ]
[ğ‘¡*1 ğ‘¡* ] â†’ [ğ‘¡*2 ]
[ğ‘¡*1 ] â†’ [ğ‘¡*2 ]
[ğ‘¡*1 i32] â†’ [ğ‘¡*2 ]
[ğ‘¡*1 ] â†’ [ğ‘¡*2 ]
[ğ‘¡*1 i32] â†’ [ğ‘¡*2 ]
[ğ‘¡*1 (ref null ğ‘¥)] â†’ [ğ‘¡*2 ]
[ğ‘¡*1 (ref null ğ‘¥)] â†’ [ğ‘¡*2 ]

validation
validation
validation
validation
validation
validation
validation
validation
validation
validation

execution
execution
execution
execution
execution
execution
execution
execution
execution
execution

continues on
294

Chapter 7. Appendix

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

Table 2 â€“ continued from previous page
Instruction

Binary Opcode

(reserved)
drop
select
select ğ‘¡
(reserved)
(reserved)
try_table bt
local.get ğ‘¥
local.set ğ‘¥
local.tee ğ‘¥
global.get ğ‘¥
global.set ğ‘¥
table.get ğ‘¥
table.set ğ‘¥
(reserved)
i32.load ğ‘¥ memarg
i64.load ğ‘¥ memarg
f32.load ğ‘¥ memarg
f64.load ğ‘¥ memarg
i32.load8_s ğ‘¥ memarg
i32.load8_u ğ‘¥ memarg
i32.load16_s ğ‘¥ memarg
i32.load16_u ğ‘¥ memarg
i64.load8_s ğ‘¥ memarg
i64.load8_u ğ‘¥ memarg
i64.load16_s ğ‘¥ memarg
i64.load16_u ğ‘¥ memarg
i64.load32_s ğ‘¥ memarg
i64.load32_u ğ‘¥ memarg
i32.store ğ‘¥ memarg
i64.store ğ‘¥ memarg
f32.store ğ‘¥ memarg
f64.store ğ‘¥ memarg
i32.store8 ğ‘¥ memarg
i32.store16 ğ‘¥ memarg
i64.store8 ğ‘¥ memarg
i64.store16 ğ‘¥ memarg
i64.store32 ğ‘¥ memarg
memory.size ğ‘¥
memory.grow ğ‘¥
i32.const i32
i64.const i64
f32.const f32
f64.const f64
i32.eqz
i32.eq
i32.ne
i32.lt_s
i32.lt_u
i32.gt_s
i32.gt_u
i32.le_s
i32.le_u
i32.ge_s
i32.ge_u

0x19
0x1A
0x1B
0x1C
0x1D
0x1E
0x1F
0x20
0x21
0x22
0x23
0x24
0x25
0x26
0x27
0x28
0x29
0x2A
0x2B
0x2C
0x2D
0x2E
0x2F
0x30
0x31
0x32
0x33
0x34
0x35
0x36
0x37
0x38
0x39
0x3A
0x3B
0x3C
0x3D
0x3E
0x3F
0x40
0x41
0x42
0x43
0x44
0x45
0x46
0x47
0x48
0x49
0x4A
0x4B
0x4C
0x4D
0x4E
0x4F

7.10. Index of Instructions

Type

Validation

Executio

[ğ‘¡] â†’ []
[ğ‘¡ ğ‘¡ i32] â†’ [ğ‘¡]
[ğ‘¡ ğ‘¡ i32] â†’ [ğ‘¡]

validation
validation
validation

execution
execution
execution

[ğ‘¡*1 ] â†’ [ğ‘¡*2 ]
[] â†’ [ğ‘¡]
[ğ‘¡] â†’ []
[ğ‘¡] â†’ [ğ‘¡]
[] â†’ [ğ‘¡]
[ğ‘¡] â†’ []
[at] â†’ [ğ‘¡]
[at ğ‘¡] â†’ []

validation
validation
validation
validation
validation
validation
validation
validation

execution
execution
execution
execution
execution
execution
execution
execution

[at] â†’ [i32]
[at] â†’ [i64]
[at] â†’ [f32]
[at] â†’ [f64]
[at] â†’ [i32]
[at] â†’ [i32]
[at] â†’ [i32]
[at] â†’ [i32]
[at] â†’ [i64]
[at] â†’ [i64]
[at] â†’ [i64]
[at] â†’ [i64]
[at] â†’ [i64]
[at] â†’ [i64]
[at i32] â†’ []
[at i64] â†’ []
[at f32] â†’ []
[at f64] â†’ []
[at i32] â†’ []
[at i32] â†’ []
[at i64] â†’ []
[at i64] â†’ []
[at i64] â†’ []
[] â†’ [at]
[at] â†’ [at]
[] â†’ [i32]
[] â†’ [i64]
[] â†’ [f32]
[] â†’ [f64]
[i32] â†’ [i32]
[i32 i32] â†’ [i32]
[i32 i32] â†’ [i32]
[i32 i32] â†’ [i32]
[i32 i32] â†’ [i32]
[i32 i32] â†’ [i32]
[i32 i32] â†’ [i32]
[i32 i32] â†’ [i32]
[i32 i32] â†’ [i32]
[i32 i32] â†’ [i32]
[i32 i32] â†’ [i32]

validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
continues on
295

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

Table 2 â€“ continued from previous page
Instruction

Binary Opcode

Type

Validation

i64.eqz
i64.eq
i64.ne
i64.lt_s
i64.lt_u
i64.gt_s
i64.gt_u
i64.le_s
i64.le_u
i64.ge_s
i64.ge_u
f32.eq
f32.ne
f32.lt
f32.gt
f32.le
f32.ge
f64.eq
f64.ne
f64.lt
f64.gt
f64.le
f64.ge
i32.clz
i32.ctz
i32.popcnt
i32.add
i32.sub
i32.mul
i32.div_s
i32.div_u
i32.rem_s
i32.rem_u
i32.and
i32.or
i32.xor
i32.shl
i32.shr_s
i32.shr_u
i32.rotl
i32.rotr
i64.clz
i64.ctz
i64.popcnt
i64.add
i64.sub
i64.mul
i64.div_s
i64.div_u
i64.rem_s
i64.rem_u
i64.and
i64.or
i64.xor
i64.shl

0x50
0x51
0x52
0x53
0x54
0x55
0x56
0x57
0x58
0x59
0x5A
0x5B
0x5C
0x5D
0x5E
0x5F
0x60
0x61
0x62
0x63
0x64
0x65
0x66
0x67
0x68
0x69
0x6A
0x6B
0x6C
0x6D
0x6E
0x6F
0x70
0x71
0x72
0x73
0x74
0x75
0x76
0x77
0x78
0x79
0x7A
0x7B
0x7C
0x7D
0x7E
0x7F
0x80
0x81
0x82
0x83
0x84
0x85
0x86

[i64] â†’ [i32]
[i64 i64] â†’ [i32]
[i64 i64] â†’ [i32]
[i64 i64] â†’ [i32]
[i64 i64] â†’ [i32]
[i64 i64] â†’ [i32]
[i64 i64] â†’ [i32]
[i64 i64] â†’ [i32]
[i64 i64] â†’ [i32]
[i64 i64] â†’ [i32]
[i64 i64] â†’ [i32]
[f32 f32] â†’ [i32]
[f32 f32] â†’ [i32]
[f32 f32] â†’ [i32]
[f32 f32] â†’ [i32]
[f32 f32] â†’ [i32]
[f32 f32] â†’ [i32]
[f64 f64] â†’ [i32]
[f64 f64] â†’ [i32]
[f64 f64] â†’ [i32]
[f64 f64] â†’ [i32]
[f64 f64] â†’ [i32]
[f64 f64] â†’ [i32]
[i32] â†’ [i32]
[i32] â†’ [i32]
[i32] â†’ [i32]
[i32 i32] â†’ [i32]
[i32 i32] â†’ [i32]
[i32 i32] â†’ [i32]
[i32 i32] â†’ [i32]
[i32 i32] â†’ [i32]
[i32 i32] â†’ [i32]
[i32 i32] â†’ [i32]
[i32 i32] â†’ [i32]
[i32 i32] â†’ [i32]
[i32 i32] â†’ [i32]
[i32 i32] â†’ [i32]
[i32 i32] â†’ [i32]
[i32 i32] â†’ [i32]
[i32 i32] â†’ [i32]
[i32 i32] â†’ [i32]
[i64] â†’ [i64]
[i64] â†’ [i64]
[i64] â†’ [i64]
[i64 i64] â†’ [i64]
[i64 i64] â†’ [i64]
[i64 i64] â†’ [i64]
[i64 i64] â†’ [i64]
[i64 i64] â†’ [i64]
[i64 i64] â†’ [i64]
[i64 i64] â†’ [i64]
[i64 i64] â†’ [i64]
[i64 i64] â†’ [i64]
[i64 i64] â†’ [i64]
[i64 i64] â†’ [i64]

validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
continues on

296

Chapter 7. Appendix

Executio

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

Table 2 â€“ continued from previous page
Instruction

Binary Opcode

Type

Validation

i64.shr_s
i64.shr_u
i64.rotl
i64.rotr
f32.abs
f32.neg
f32.ceil
f32.floor
f32.trunc
f32.nearest
f32.sqrt
f32.add
f32.sub
f32.mul
f32.div
f32.min
f32.max
f32.copysign
f64.abs
f64.neg
f64.ceil
f64.floor
f64.trunc
f64.nearest
f64.sqrt
f64.add
f64.sub
f64.mul
f64.div
f64.min
f64.max
f64.copysign
i32.wrap_i64
i32.trunc_f32_s
i32.trunc_f32_u
i32.trunc_f64_s
i32.trunc_f64_u
i64.extend_i32_s
i64.extend_i32_u
i64.trunc_f32_s
i64.trunc_f32_u
i64.trunc_f64_s
i64.trunc_f64_u
f32.convert_i32_s
f32.convert_i32_u
f32.convert_i64_s
f32.convert_i64_u
f32.demote_f64
f64.convert_i32_s
f64.convert_i32_u
f64.convert_i64_s
f64.convert_i64_u
f64.promote_f32
i32.reinterpret_f32
i64.reinterpret_f64

0x87
0x88
0x89
0x8A
0x8B
0x8C
0x8D
0x8E
0x8F
0x90
0x91
0x92
0x93
0x94
0x95
0x96
0x97
0x98
0x99
0x9A
0x9B
0x9C
0x9D
0x9E
0x9F
0xA0
0xA1
0xA2
0xA3
0xA4
0xA5
0xA6
0xA7
0xA8
0xA9
0xAA
0xAB
0xAC
0xAD
0xAE
0xAF
0xB0
0xB1
0xB2
0xB3
0xB4
0xB5
0xB6
0xB7
0xB8
0xB9
0xBA
0xBB
0xBC
0xBD

[i64 i64] â†’ [i64]
[i64 i64] â†’ [i64]
[i64 i64] â†’ [i64]
[i64 i64] â†’ [i64]
[f32] â†’ [f32]
[f32] â†’ [f32]
[f32] â†’ [f32]
[f32] â†’ [f32]
[f32] â†’ [f32]
[f32] â†’ [f32]
[f32] â†’ [f32]
[f32 f32] â†’ [f32]
[f32 f32] â†’ [f32]
[f32 f32] â†’ [f32]
[f32 f32] â†’ [f32]
[f32 f32] â†’ [f32]
[f32 f32] â†’ [f32]
[f32 f32] â†’ [f32]
[f64] â†’ [f64]
[f64] â†’ [f64]
[f64] â†’ [f64]
[f64] â†’ [f64]
[f64] â†’ [f64]
[f64] â†’ [f64]
[f64] â†’ [f64]
[f64 f64] â†’ [f64]
[f64 f64] â†’ [f64]
[f64 f64] â†’ [f64]
[f64 f64] â†’ [f64]
[f64 f64] â†’ [f64]
[f64 f64] â†’ [f64]
[f64 f64] â†’ [f64]
[i64] â†’ [i32]
[f32] â†’ [i32]
[f32] â†’ [i32]
[f64] â†’ [i32]
[f64] â†’ [i32]
[i32] â†’ [i64]
[i32] â†’ [i64]
[f32] â†’ [i64]
[f32] â†’ [i64]
[f64] â†’ [i64]
[f64] â†’ [i64]
[i32] â†’ [f32]
[i32] â†’ [f32]
[i64] â†’ [f32]
[i64] â†’ [f32]
[f64] â†’ [f32]
[i32] â†’ [f64]
[i32] â†’ [f64]
[i64] â†’ [f64]
[i64] â†’ [f64]
[f32] â†’ [f64]
[f32] â†’ [i32]
[f64] â†’ [i64]

validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
continues on

7.10. Index of Instructions

297

Executio

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

Table 2 â€“ continued from previous page
Instruction

Binary Opcode

Type

Validation

Executio

f32.reinterpret_i32
f64.reinterpret_i64
i32.extend8_s
i32.extend16_s
i64.extend8_s
i64.extend16_s
i64.extend32_s
(reserved)
(reserved)
(reserved)
(reserved)
(reserved)
(reserved)
(reserved)
(reserved)
(reserved)
(reserved)
(reserved)
ref.null ht
ref.is_null
ref.func ğ‘¥
ref.eq
ref.as_non_null
br_on_null ğ‘™
br_on_non_null ğ‘™
(reserved)
(reserved)
(reserved)
(reserved)
(reserved)
(reserved)
(reserved)
(reserved)
(reserved)
(reserved)
(reserved)
(reserved)
(reserved)
(reserved)
(reserved)
(reserved)
(reserved)
(reserved)
(reserved)
(reserved)
(reserved)
(reserved)
(reserved)
(reserved)
(reserved)
(reserved)
(reserved)
(reserved)
(reserved)
(reserved)

0xBE
0xBF
0xC0
0xC1
0xC2
0xC3
0xC4
0xC5
0xC6
0xC7
0xC8
0xC9
0xCA
0xCB
0xCC
0xCD
0xCE
0xCF
0xD0
0xD1
0xD2
0xD3
0xD4
0xD5
0xD6
0xD7
0xD8
0xD9
0xDA
0xDB
0xDC
0xDD
0xDE
0xDF
0xE0
0xE1
0xE2
0xE3
0xE4
0xE5
0xE6
0xE7
0xE8
0xE9
0xEA
0xEB
0xEC
0xED
0xEE
0xEF
0xF0
0xF1
0xF2
0xF3
0xF4

[i32] â†’ [f32]
[i64] â†’ [f64]
[i32] â†’ [i32]
[i32] â†’ [i32]
[i64] â†’ [i64]
[i64] â†’ [i64]
[i64] â†’ [i64]

validation
validation
validation
validation
validation
validation
validation

execution
execution
execution
execution
execution
execution
execution

[] â†’ [(ref null ht)]
[(ref null ht)] â†’ [i32]
[] â†’ [ref ht]
[eqref eqref] â†’ [i32]
[(ref null ht)] â†’ [(ref ht)]
[ğ‘¡* (ref null ht)] â†’ [ğ‘¡* (ref ht)]
[ğ‘¡* (ref null ht)] â†’ [ğ‘¡* ]

validation
validation
validation
validation
validation
validation
validation

execution
execution
execution
execution
execution
execution
execution

continues on
298

Chapter 7. Appendix

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

Table 2 â€“ continued from previous page
Instruction

Binary Opcode

(reserved)
(reserved)
(reserved)
(reserved)
(reserved)
(reserved)
struct.new ğ‘¥
struct.new_default ğ‘¥
struct.get ğ‘¥ ğ‘¦
struct.get_s ğ‘¥ ğ‘¦
struct.get_u ğ‘¥ ğ‘¦
struct.set ğ‘¥ ğ‘¦
array.new ğ‘¥
array.new_default ğ‘¥
array.new_fixed ğ‘¥ ğ‘›
array.new_data ğ‘¥ ğ‘¦
array.new_elem ğ‘¥ ğ‘¦
array.get ğ‘¥
array.get_s ğ‘¥
array.get_u ğ‘¥
array.set ğ‘¥
array.len
array.fill ğ‘¥
array.copy ğ‘¥ ğ‘¦
array.init_data ğ‘¥ ğ‘¦
array.init_elem ğ‘¥ ğ‘¦
ref.test (ref ğ‘¡)
ref.test (ref null ğ‘¡)
ref.cast (ref ğ‘¡)
ref.cast (ref null ğ‘¡)
br_on_cast ğ‘¡1 ğ‘¡2
br_on_cast_fail ğ‘¡1 ğ‘¡2
any.convert_extern
extern.convert_any
ref.i31
i31.get_s
i31.get_u
(reserved)
i32.trunc_sat_f32_s
i32.trunc_sat_f32_u
i32.trunc_sat_f64_s
i32.trunc_sat_f64_u
i64.trunc_sat_f32_s
i64.trunc_sat_f32_u
i64.trunc_sat_f64_s
i64.trunc_sat_f64_u
memory.init ğ‘¥ ğ‘¦
data.drop ğ‘¥
memory.copy ğ‘¥ ğ‘¦
memory.fill ğ‘¦
table.init ğ‘¥ ğ‘¦
elem.drop ğ‘¥
table.copy ğ‘¥ ğ‘¦
table.grow ğ‘¥
table.size ğ‘¥

0xF5
0xF6
0xF7
0xF8
0xF9
0xFA
0xFB 0x00
0xFB 0x01
0xFB 0x02
0xFB 0x03
0xFB 0x04
0xFB 0x05
0xFB 0x06
0xFB 0x07
0xFB 0x08
0xFB 0x09
0xFB 0x0A
0xFB 0x0B
0xFB 0x0C
0xFB 0x0D
0xFB 0x0E
0xFB 0x0F
0xFB 0x10
0xFB 0x11
0xFB 0x12
0xFB 0x13
0xFB 0x14
0xFB 0x15
0xFB 0x16
0xFB 0x17
0xFB 0x18
0xFB 0x19
0xFB 0x1A
0xFB 0x1B
0xFB 0x1C
0xFB 0x1D
0xFB 0x1E
0xFB 0x1E . . .
0xFC 0x00
0xFC 0x01
0xFC 0x02
0xFC 0x03
0xFC 0x04
0xFC 0x05
0xFC 0x06
0xFC 0x07
0xFC 0x08
0xFC 0x09
0xFC 0x0A
0xFC 0x0B
0xFC 0x0C
0xFC 0x0D
0xFC 0x0E
0xFC 0x0F
0xFC 0x10

7.10. Index of Instructions

Type

Validation

Executio

[ğ‘¡* ] â†’ [(ref ğ‘¥)]
[] â†’ [(ref ğ‘¥)]
[(ref null ğ‘¥)] â†’ [ğ‘¡]
[(ref null ğ‘¥)] â†’ [i32]
[(ref null ğ‘¥)] â†’ [i32]
[(ref null ğ‘¥) ğ‘¡] â†’ []
[ğ‘¡ i32] â†’ [(ref ğ‘¥)]
[i32] â†’ [(ref ğ‘¥)]
[ğ‘¡ğ‘› ] â†’ [(ref ğ‘¥)]
[i32 i32] â†’ [(ref ğ‘¥)]
[i32 i32] â†’ [(ref ğ‘¥)]
[(ref null ğ‘¥) i32] â†’ [ğ‘¡]
[(ref null ğ‘¥) i32] â†’ [i32]
[(ref null ğ‘¥) i32] â†’ [i32]
[(ref null ğ‘¥) i32 ğ‘¡] â†’ []
[(ref null array)] â†’ [i32]
[(ref null ğ‘¥) i32 ğ‘¡ i32] â†’ []
[(ref null ğ‘¥) i32 (ref null ğ‘¦) i32 i32] â†’ []
[(ref null ğ‘¥) i32 i32 i32] â†’ []
[(ref null ğ‘¥) i32 i32 i32] â†’ []
[(ref ğ‘¡â€² )] â†’ [i32]
[(ref null ğ‘¡â€² )] â†’ [i32]
[(ref ğ‘¡â€² )] â†’ [(ref ğ‘¡)]
[(ref null ğ‘¡â€² )] â†’ [(ref null ğ‘¡)]
[ğ‘¡1 ] â†’ [ğ‘¡1 âˆ– ğ‘¡2 ]
[ğ‘¡1 ] â†’ [ğ‘¡2 ]
[(ref null extern)] â†’ [(ref null any)]
[(ref null any)] â†’ [(ref null extern)]
[i32] â†’ [(ref i31)]
[i31ref] â†’ [i32]
[i31ref] â†’ [i32]

validation
validation
validation
validation
validation
validation
validation
validation
validation
validation
validation
validation
validation
validation
validation
validation
validation
validation
validation
validation
validation
validation
validation
validation
validation
validation
validation
validation
validation
validation
validation

execution
execution
execution
execution
execution
execution
execution
execution
execution
execution
execution
execution
execution
execution
execution
execution
execution
execution
execution
execution
execution
execution
execution
execution
execution
execution
execution
execution
execution
execution
execution

[f32] â†’ [i32]
[f32] â†’ [i32]
[f64] â†’ [i32]
[f64] â†’ [i32]
[f32] â†’ [i64]
[f32] â†’ [i64]
[f64] â†’ [i64]
[f64] â†’ [i64]
[at i32 i32] â†’ []
[] â†’ []
[at 1 at 2 min(at ğ‘¥ , at ğ‘¦ )] â†’ []
[at i32 at] â†’ []
[at i32 i32] â†’ []
[] â†’ []
[at 1 at 2 min(at 1 , at 2 )] â†’ []
[ğ‘¡ at] â†’ [at]
[] â†’ [at]

validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
continues on
299

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

Table 2 â€“ continued from previous page
Instruction

Binary Opcode

Type

Validation

Executio

table.fill ğ‘¥
(reserved)
v128.load ğ‘¥ memarg
v128.load8x8_s ğ‘¥ memarg
v128.load8x8_u ğ‘¥ memarg
v128.load16x4_s ğ‘¥ memarg
v128.load16x4_u ğ‘¥ memarg
v128.load32x2_s ğ‘¥ memarg
v128.load32x2_u ğ‘¥ memarg
v128.load8_splat ğ‘¥ memarg
v128.load16_splat ğ‘¥ memarg
v128.load32_splat ğ‘¥ memarg
v128.load64_splat ğ‘¥ memarg
v128.store ğ‘¥ memarg
v128.const i128
i8x16.shuffle laneidx 16
i8x16.swizzle
i8x16.splat
i16x8.splat
i32x4.splat
i64x2.splat
f32x4.splat
f64x2.splat
i8x16.extract_lane_s laneidx
i8x16.extract_lane_u laneidx
i8x16.replace_lane laneidx
i16x8.extract_lane_s laneidx
i16x8.extract_lane_u laneidx
i16x8.replace_lane laneidx
i32x4.extract_lane laneidx
i32x4.replace_lane laneidx
i64x2.extract_lane laneidx
i64x2.replace_lane laneidx
f32x4.extract_lane laneidx
f32x4.replace_lane laneidx
f64x2.extract_lane laneidx
f64x2.replace_lane laneidx
i8x16.eq
i8x16.ne
i8x16.lt_s
i8x16.lt_u
i8x16.gt_s
i8x16.gt_u
i8x16.le_s
i8x16.le_u
i8x16.ge_s
i8x16.ge_u
i16x8.eq
i16x8.ne
i16x8.lt_s
i16x8.lt_u
i16x8.gt_s
i16x8.gt_u
i16x8.le_s
i16x8.le_u

0xFC 0x11
0xFC 0x1E . . .
0xFD 0x00
0xFD 0x01
0xFD 0x02
0xFD 0x03
0xFD 0x04
0xFD 0x05
0xFD 0x06
0xFD 0x07
0xFD 0x08
0xFD 0x09
0xFD 0x0A
0xFD 0x0B
0xFD 0x0C
0xFD 0x0D
0xFD 0x0E
0xFD 0x0F
0xFD 0x10
0xFD 0x11
0xFD 0x12
0xFD 0x13
0xFD 0x14
0xFD 0x15
0xFD 0x16
0xFD 0x17
0xFD 0x18
0xFD 0x19
0xFD 0x1A
0xFD 0x1B
0xFD 0x1C
0xFD 0x1D
0xFD 0x1E
0xFD 0x1F
0xFD 0x20
0xFD 0x21
0xFD 0x22
0xFD 0x23
0xFD 0x24
0xFD 0x25
0xFD 0x26
0xFD 0x27
0xFD 0x28
0xFD 0x29
0xFD 0x2A
0xFD 0x2B
0xFD 0x2C
0xFD 0x2D
0xFD 0x2E
0xFD 0x2F
0xFD 0x30
0xFD 0x31
0xFD 0x32
0xFD 0x33
0xFD 0x34

[at ğ‘¡ at] â†’ []

validation

execution

[at] â†’ [v128]
[at] â†’ [v128]
[at] â†’ [v128]
[at] â†’ [v128]
[at] â†’ [v128]
[at] â†’ [v128]
[at] â†’ [v128]
[at] â†’ [v128]
[at] â†’ [v128]
[at] â†’ [v128]
[at] â†’ [v128]
[at v128] â†’ []
[] â†’ [v128]
[v128 v128] â†’ [v128]
[v128 v128] â†’ [v128]
[i32] â†’ [v128]
[i32] â†’ [v128]
[i32] â†’ [v128]
[i64] â†’ [v128]
[f32] â†’ [v128]
[f64] â†’ [v128]
[v128] â†’ [i32]
[v128] â†’ [i32]
[v128 i32] â†’ [v128]
[v128] â†’ [i32]
[v128] â†’ [i32]
[v128 i32] â†’ [v128]
[v128] â†’ [i32]
[v128 i32] â†’ [v128]
[v128] â†’ [i64]
[v128 i64] â†’ [v128]
[v128] â†’ [f32]
[v128 f32] â†’ [v128]
[v128] â†’ [f64]
[v128 f64] â†’ [v128]
[v128 v128] â†’ [v128]
[v128 v128] â†’ [v128]
[v128 v128] â†’ [v128]
[v128 v128] â†’ [v128]
[v128 v128] â†’ [v128]
[v128 v128] â†’ [v128]
[v128 v128] â†’ [v128]
[v128 v128] â†’ [v128]
[v128 v128] â†’ [v128]
[v128 v128] â†’ [v128]
[v128 v128] â†’ [v128]
[v128 v128] â†’ [v128]
[v128 v128] â†’ [v128]
[v128 v128] â†’ [v128]
[v128 v128] â†’ [v128]
[v128 v128] â†’ [v128]
[v128 v128] â†’ [v128]
[v128 v128] â†’ [v128]

validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
continues on

300

Chapter 7. Appendix

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

Table 2 â€“ continued from previous page
Instruction

Binary Opcode

Type

Validation

i16x8.ge_s
i16x8.ge_u
i32x4.eq
i32x4.ne
i32x4.lt_s
i32x4.lt_u
i32x4.gt_s
i32x4.gt_u
i32x4.le_s
i32x4.le_u
i32x4.ge_s
i32x4.ge_u
f32x4.eq
f32x4.ne
f32x4.lt
f32x4.gt
f32x4.le
f32x4.ge
f64x2.eq
f64x2.ne
f64x2.lt
f64x2.gt
f64x2.le
f64x2.ge
v128.not
v128.and
v128.andnot
v128.or
v128.xor
v128.bitselect
v128.any_true
v128.load8_lane memarg laneidx
v128.load16_lane memarg laneidx
v128.load32_lane memarg laneidx
v128.load64_lane memarg laneidx
v128.store8_lane memarg laneidx
v128.store16_lane memarg laneidx
v128.store32_lane memarg laneidx
v128.store64_lane memarg laneidx
v128.load32_zero memarg
v128.load64_zero memarg
f32x4.demote_f64x2_zero
f64x2.promote_low_f32x4
i8x16.abs
i8x16.neg
i8x16.popcnt
i8x16.all_true
i8x16.bitmask
i8x16.narrow_i16x8_s
i8x16.narrow_i16x8_u
f32x4.ceil
f32x4.floor
f32x4.trunc
f32x4.nearest
i8x16.shl

0xFD 0x35
0xFD 0x36
0xFD 0x37
0xFD 0x38
0xFD 0x39
0xFD 0x3A
0xFD 0x3B
0xFD 0x3C
0xFD 0x3D
0xFD 0x3E
0xFD 0x3F
0xFD 0x40
0xFD 0x41
0xFD 0x42
0xFD 0x43
0xFD 0x44
0xFD 0x45
0xFD 0x46
0xFD 0x47
0xFD 0x48
0xFD 0x49
0xFD 0x4A
0xFD 0x4B
0xFD 0x4C
0xFD 0x4D
0xFD 0x4E
0xFD 0x4F
0xFD 0x50
0xFD 0x51
0xFD 0x52
0xFD 0x53
0xFD 0x54
0xFD 0x55
0xFD 0x56
0xFD 0x57
0xFD 0x58
0xFD 0x59
0xFD 0x5A
0xFD 0x5B
0xFD 0x5C
0xFD 0x5D
0xFD 0x5E
0xFD 0x5F
0xFD 0x60
0xFD 0x61
0xFD 0x62
0xFD 0x63
0xFD 0x64
0xFD 0x65
0xFD 0x66
0xFD 0x67
0xFD 0x68
0xFD 0x69
0xFD 0x6A
0xFD 0x6B

[v128 v128] â†’ [v128]
[v128 v128] â†’ [v128]
[v128 v128] â†’ [v128]
[v128 v128] â†’ [v128]
[v128 v128] â†’ [v128]
[v128 v128] â†’ [v128]
[v128 v128] â†’ [v128]
[v128 v128] â†’ [v128]
[v128 v128] â†’ [v128]
[v128 v128] â†’ [v128]
[v128 v128] â†’ [v128]
[v128 v128] â†’ [v128]
[v128 v128] â†’ [v128]
[v128 v128] â†’ [v128]
[v128 v128] â†’ [v128]
[v128 v128] â†’ [v128]
[v128 v128] â†’ [v128]
[v128 v128] â†’ [v128]
[v128 v128] â†’ [v128]
[v128 v128] â†’ [v128]
[v128 v128] â†’ [v128]
[v128 v128] â†’ [v128]
[v128 v128] â†’ [v128]
[v128 v128] â†’ [v128]
[v128] â†’ [v128]
[v128 v128] â†’ [v128]
[v128 v128] â†’ [v128]
[v128 v128] â†’ [v128]
[v128 v128] â†’ [v128]
[v128 v128 v128] â†’ [v128]
[v128] â†’ [i32]
[at v128] â†’ [v128]
[at v128] â†’ [v128]
[at v128] â†’ [v128]
[at v128] â†’ [v128]
[at v128] â†’ []
[at v128] â†’ []
[at v128] â†’ []
[at v128] â†’ []
[at] â†’ [v128]
[at] â†’ [v128]
[v128] â†’ [v128]
[v128] â†’ [v128]
[v128] â†’ [v128]
[v128] â†’ [v128]
[v128] â†’ [v128]
[v128] â†’ [i32]
[v128] â†’ [i32]
[v128 v128] â†’ [v128]
[v128 v128] â†’ [v128]
[v128] â†’ [v128]
[v128] â†’ [v128]
[v128] â†’ [v128]
[v128] â†’ [v128]
[v128 i32] â†’ [v128]

validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
continues on

7.10. Index of Instructions

301

Executio

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

Table 2 â€“ continued from previous page
Instruction

Binary Opcode

Type

Validation

Executio

i8x16.shr_s
i8x16.shr_u
i8x16.add
i8x16.add_sat_s
i8x16.add_sat_u
i8x16.sub
i8x16.sub_sat_s
i8x16.sub_sat_u
f64x2.ceil
f64x2.floor
i8x16.min_s
i8x16.min_u
i8x16.max_s
i8x16.max_u
f64x2.trunc
i8x16.avgr_u
i16x8.extadd_pairwise_i8x16_s
i16x8.extadd_pairwise_i8x16_u
i32x4.extadd_pairwise_i16x8_s
i32x4.extadd_pairwise_i16x8_u
i16x8.abs
i16x8.neg
i16x8.q15mulr_sat_s
i16x8.all_true
i16x8.bitmask
i16x8.narrow_i32x4_s
i16x8.narrow_i32x4_u
i16x8.extend_low_i8x16_s
i16x8.extend_high_i8x16_s
i16x8.extend_low_i8x16_u
i16x8.extend_high_i8x16_u
i16x8.shl
i16x8.shr_s
i16x8.shr_u
i16x8.add
i16x8.add_sat_s
i16x8.add_sat_u
i16x8.sub
i16x8.sub_sat_s
i16x8.sub_sat_u
f64x2.nearest
i16x8.mul
i16x8.min_s
i16x8.min_u
i16x8.max_s
i16x8.max_u
(reserved)
i16x8.avgr_u
i16x8.extmul_low_i8x16_s
i16x8.extmul_high_i8x16_s
i16x8.extmul_low_i8x16_u
i16x8.extmul_high_i8x16_u
i32x4.abs
i32x4.neg
(reserved)

0xFD 0x6C
0xFD 0x6D
0xFD 0x6E
0xFD 0x6F
0xFD 0x70
0xFD 0x71
0xFD 0x72
0xFD 0x73
0xFD 0x74
0xFD 0x75
0xFD 0x76
0xFD 0x77
0xFD 0x78
0xFD 0x79
0xFD 0x7A
0xFD 0x7B
0xFD 0x7C
0xFD 0x7D
0xFD 0x7E
0xFD 0x7F
0xFD 0x80 0x01
0xFD 0x81 0x01
0xFD 0x82 0x01
0xFD 0x83 0x01
0xFD 0x84 0x01
0xFD 0x85 0x01
0xFD 0x86 0x01
0xFD 0x87 0x01
0xFD 0x88 0x01
0xFD 0x89 0x01
0xFD 0x8A 0x01
0xFD 0x8B 0x01
0xFD 0x8C 0x01
0xFD 0x8D 0x01
0xFD 0x8E 0x01
0xFD 0x8F 0x01
0xFD 0x90 0x01
0xFD 0x91 0x01
0xFD 0x92 0x01
0xFD 0x93 0x01
0xFD 0x94 0x01
0xFD 0x95 0x01
0xFD 0x96 0x01
0xFD 0x97 0x01
0xFD 0x98 0x01
0xFD 0x99 0x01
0xFD 0x9A 0x01
0xFD 0x9B 0x01
0xFD 0x9C 0x01
0xFD 0x9D 0x01
0xFD 0x9E 0x01
0xFD 0x9F 0x01
0xFD 0xA0 0x01
0xFD 0xA1 0x01
0xFD 0xA2 0x01

[v128 i32] â†’ [v128]
[v128 i32] â†’ [v128]
[v128 v128] â†’ [v128]
[v128 v128] â†’ [v128]
[v128 v128] â†’ [v128]
[v128 v128] â†’ [v128]
[v128 v128] â†’ [v128]
[v128 v128] â†’ [v128]
[v128] â†’ [v128]
[v128] â†’ [v128]
[v128 v128] â†’ [v128]
[v128 v128] â†’ [v128]
[v128 v128] â†’ [v128]
[v128 v128] â†’ [v128]
[v128] â†’ [v128]
[v128 v128] â†’ [v128]
[v128] â†’ [v128]
[v128] â†’ [v128]
[v128] â†’ [v128]
[v128] â†’ [v128]
[v128] â†’ [v128]
[v128] â†’ [v128]
[v128 v128] â†’ [v128]
[v128] â†’ [i32]
[v128] â†’ [i32]
[v128 v128] â†’ [v128]
[v128 v128] â†’ [v128]
[v128] â†’ [v128]
[v128] â†’ [v128]
[v128] â†’ [v128]
[v128] â†’ [v128]
[v128 i32] â†’ [v128]
[v128 i32] â†’ [v128]
[v128 i32] â†’ [v128]
[v128 v128] â†’ [v128]
[v128 v128] â†’ [v128]
[v128 v128] â†’ [v128]
[v128 v128] â†’ [v128]
[v128 v128] â†’ [v128]
[v128 v128] â†’ [v128]
[v128] â†’ [v128]
[v128 v128] â†’ [v128]
[v128 v128] â†’ [v128]
[v128 v128] â†’ [v128]
[v128 v128] â†’ [v128]
[v128 v128] â†’ [v128]

validation
validation
validation
validation
validation
validation
validation
validation
validation
validation
validation
validation
validation
validation
validation
validation
validation
validation
validation
validation
validation
validation
validation
validation
validation
validation
validation
validation
validation
validation
validation
validation
validation
validation
validation
validation
validation
validation
validation
validation
validation
validation
validation
validation
validation
validation

execution
execution
execution
execution
execution
execution
execution
execution
execution
execution
execution
execution
execution
execution
execution
execution
execution
execution
execution
execution
execution
execution
execution
execution
execution
execution
execution
execution
execution
execution
execution
execution
execution
execution
execution
execution
execution
execution
execution
execution
execution
execution
execution
execution
execution
execution

[v128 v128] â†’ [v128]
[v128 v128] â†’ [v128]
[v128 v128] â†’ [v128]
[v128 v128] â†’ [v128]
[v128 v128] â†’ [v128]
[v128] â†’ [v128]
[v128] â†’ [v128]

validation
validation
validation
validation
validation
validation
validation

execution
execution
execution
execution
execution
execution
execution

continues on
302

Chapter 7. Appendix

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

Table 2 â€“ continued from previous page
Instruction

Binary Opcode

Type

Validation

Executio

i32x4.all_true
i32x4.bitmask
(reserved)
(reserved)
i32x4.extend_low_i16x8_s
i32x4.extend_high_i16x8_s
i32x4.extend_low_i16x8_u
i32x4.extend_high_i16x8_u
i32x4.shl
i32x4.shr_s
i32x4.shr_u
i32x4.add
(reserved)
(reserved)
i32x4.sub
(reserved)
(reserved)
(reserved)
i32x4.mul
i32x4.min_s
i32x4.min_u
i32x4.max_s
i32x4.max_u
i32x4.dot_i16x8_s
i32x4.extmul_low_i16x8_s
i32x4.extmul_high_i16x8_s
i32x4.extmul_low_i16x8_u
i32x4.extmul_high_i16x8_u
i64x2.abs
i64x2.neg
(reserved)
i64x2.all_true
i64x2.bitmask
(reserved)
(reserved)
i64x2.extend_low_i32x4_s
i64x2.extend_high_i32x4_s
i64x2.extend_low_i32x4_u
i64x2.extend_high_i32x4_u
i64x2.shl
i64x2.shr_s
i64x2.shr_u
i64x2.add
(reserved)
(reserved)
i64x2.sub
(reserved)
(reserved)
(reserved)
i64x2.mul
i64x2.eq
i64x2.ne
i64x2.lt_s
i64x2.gt_s
i64x2.le_s

0xFD 0xA3 0x01
0xFD 0xA4 0x01
0xFD 0xA5 0x01
0xFD 0xA6 0x01
0xFD 0xA7 0x01
0xFD 0xA8 0x01
0xFD 0xA9 0x01
0xFD 0xAA 0x01
0xFD 0xAB 0x01
0xFD 0xAC 0x01
0xFD 0xAD 0x01
0xFD 0xAE 0x01
0xFD 0xAF 0x01
0xFD 0xB0 0x01
0xFD 0xB1 0x01
0xFD 0xB2 0x01
0xFD 0xB3 0x01
0xFD 0xB4 0x01
0xFD 0xB5 0x01
0xFD 0xB6 0x01
0xFD 0xB7 0x01
0xFD 0xB8 0x01
0xFD 0xB9 0x01
0xFD 0xBA 0x01
0xFD 0xBC 0x01
0xFD 0xBD 0x01
0xFD 0xBE 0x01
0xFD 0xBF 0x01
0xFD 0xC0 0x01
0xFD 0xC1 0x01
0xFD 0xC2 0x01
0xFD 0xC3 0x01
0xFD 0xC4 0x01
0xFD 0xC5 0x01
0xFD 0xC6 0x01
0xFD 0xC7 0x01
0xFD 0xC8 0x01
0xFD 0xC9 0x01
0xFD 0xCA 0x01
0xFD 0xCB 0x01
0xFD 0xCC 0x01
0xFD 0xCD 0x01
0xFD 0xCE 0x01
0xFD 0xCF 0x01
0xFD 0xD0 0x01
0xFD 0xD1 0x01
0xFD 0xD2 0x01
0xFD 0xD3 0x01
0xFD 0xD4 0x01
0xFD 0xD5 0x01
0xFD 0xD6 0x01
0xFD 0xD7 0x01
0xFD 0xD8 0x01
0xFD 0xD9 0x01
0xFD 0xDA 0x01

[v128] â†’ [i32]
[v128] â†’ [i32]

validation
validation

execution
execution

[v128] â†’ [v128]
[v128] â†’ [v128]
[v128] â†’ [v128]
[v128] â†’ [v128]
[v128 i32] â†’ [v128]
[v128 i32] â†’ [v128]
[v128 i32] â†’ [v128]
[v128 v128] â†’ [v128]

validation
validation
validation
validation
validation
validation
validation
validation

execution
execution
execution
execution
execution
execution
execution
execution

[v128 v128] â†’ [v128]

validation

execution

[v128 v128] â†’ [v128]
[v128 v128] â†’ [v128]
[v128 v128] â†’ [v128]
[v128 v128] â†’ [v128]
[v128 v128] â†’ [v128]
[v128 v128] â†’ [v128]
[v128 v128] â†’ [v128]
[v128 v128] â†’ [v128]
[v128 v128] â†’ [v128]
[v128 v128] â†’ [v128]
[v128] â†’ [v128]
[v128] â†’ [v128]

validation
validation
validation
validation
validation
validation
validation
validation
validation
validation
validation
validation

execution
execution
execution
execution
execution
execution
execution
execution
execution
execution
execution
execution

[v128] â†’ [i32]
[v128] â†’ [i32]

validation
validation

execution
execution

[v128] â†’ [v128]
[v128] â†’ [v128]
[v128] â†’ [v128]
[v128] â†’ [v128]
[v128 i32] â†’ [v128]
[v128 i32] â†’ [v128]
[v128 i32] â†’ [v128]
[v128 v128] â†’ [v128]

validation
validation
validation
validation
validation
validation
validation
validation

execution
execution
execution
execution
execution
execution
execution
execution

[v128 v128] â†’ [v128]

validation

execution

[v128 v128] â†’ [v128]
[v128 v128] â†’ [v128]
[v128 v128] â†’ [v128]
[v128 v128] â†’ [v128]
[v128 v128] â†’ [v128]
[v128 v128] â†’ [v128]

validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
continues on

7.10. Index of Instructions

303

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

Table 2 â€“ continued from previous page
Instruction

Binary Opcode

Type

Validation

Executio

i64x2.ge_s
i64x2.extmul_low_i32x4_s
i64x2.extmul_high_i32x4_s
i64x2.extmul_low_i32x4_u
i64x2.extmul_high_i32x4_u
f32x4.abs
f32x4.neg
(reserved)
f32x4.sqrt
f32x4.add
f32x4.sub
f32x4.mul
f32x4.div
f32x4.min
f32x4.max
f32x4.pmin
f32x4.pmax
f64x2.abs
f64x2.neg
f64x2.sqrt
f64x2.add
f64x2.sub
f64x2.mul
f64x2.div
f64x2.min
f64x2.max
f64x2.pmin
f64x2.pmax
i32x4.trunc_sat_f32x4_s
i32x4.trunc_sat_f32x4_u
f32x4.convert_i32x4_s
f32x4.convert_i32x4_u
i32x4.trunc_sat_f64x2_s_zero
i32x4.trunc_sat_f64x2_u_zero
f64x2.convert_low_i32x4_s
f64x2.convert_low_i32x4_u
i8x16.relaxed_swizzle
i32x4.relaxed_trunc_f32x4_s
i32x4.relaxed_trunc_f32x4_u
i32x4.relaxed_trunc_f64x2_s
i32x4.relaxed_trunc_f64x2_u
f32x4.relaxed_madd
f32x4.relaxed_nmadd
f64x2.relaxed_madd
f64x2.relaxed_nmadd
i8x16.relaxed_laneselect
i16x8.relaxed_laneselect
i32x4.relaxed_laneselect
i64x2.relaxed_laneselect
f32x4.relaxed_min
f32x4.relaxed_max
f64x2.relaxed_min
f64x2.relaxed_max
i16x8.relaxed_q15mulr_s
i16x8.relaxed_dot_i8x16_i7x16_s

0xFD 0xDB 0x01
0xFD 0xDC 0x01
0xFD 0xDD 0x01
0xFD 0xDE 0x01
0xFD 0xDF 0x01
0xFD 0xE0 0x01
0xFD 0xE1 0x01
0xFD 0xE2 0x01
0xFD 0xE3 0x01
0xFD 0xE4 0x01
0xFD 0xE5 0x01
0xFD 0xE6 0x01
0xFD 0xE7 0x01
0xFD 0xE8 0x01
0xFD 0xE9 0x01
0xFD 0xEA 0x01
0xFD 0xEB 0x01
0xFD 0xEC 0x01
0xFD 0xED 0x01
0xFD 0xEF 0x01
0xFD 0xF0 0x01
0xFD 0xF1 0x01
0xFD 0xF2 0x01
0xFD 0xF3 0x01
0xFD 0xF4 0x01
0xFD 0xF5 0x01
0xFD 0xF6 0x01
0xFD 0xF7 0x01
0xFD 0xF8 0x01
0xFD 0xF9 0x01
0xFD 0xFA 0x01
0xFD 0xFB 0x01
0xFD 0xFC 0x01
0xFD 0xFD 0x01
0xFD 0xFE 0x01
0xFD 0xFF 0x01
0xFD 0x80 0x02
0xFD 0x81 0x02
0xFD 0x82 0x02
0xFD 0x83 0x02
0xFD 0x84 0x02
0xFD 0x85 0x02
0xFD 0x86 0x02
0xFD 0x87 0x02
0xFD 0x88 0x02
0xFD 0x89 0x02
0xFD 0x8A 0x02
0xFD 0x8B 0x02
0xFD 0x8C 0x02
0xFD 0x8D 0x02
0xFD 0x8E 0x02
0xFD 0x8F 0x02
0xFD 0x90 0x02
0xFD 0x91 0x02
0xFD 0x92 0x02

[v128 v128] â†’ [v128]
[v128 v128] â†’ [v128]
[v128 v128] â†’ [v128]
[v128 v128] â†’ [v128]
[v128 v128] â†’ [v128]
[v128] â†’ [v128]
[v128] â†’ [v128]

validation
validation
validation
validation
validation
validation
validation

execution
execution
execution
execution
execution
execution
execution

[v128] â†’ [v128]
[v128 v128] â†’ [v128]
[v128 v128] â†’ [v128]
[v128 v128] â†’ [v128]
[v128 v128] â†’ [v128]
[v128 v128] â†’ [v128]
[v128 v128] â†’ [v128]
[v128 v128] â†’ [v128]
[v128 v128] â†’ [v128]
[v128] â†’ [v128]
[v128] â†’ [v128]
[v128] â†’ [v128]
[v128 v128] â†’ [v128]
[v128 v128] â†’ [v128]
[v128 v128] â†’ [v128]
[v128 v128] â†’ [v128]
[v128 v128] â†’ [v128]
[v128 v128] â†’ [v128]
[v128 v128] â†’ [v128]
[v128 v128] â†’ [v128]
[v128] â†’ [v128]
[v128] â†’ [v128]
[v128] â†’ [v128]
[v128] â†’ [v128]
[v128] â†’ [v128]
[v128] â†’ [v128]
[v128] â†’ [v128]
[v128] â†’ [v128]
[v128 v128] â†’ [v128]
[v128] â†’ [v128]
[v128] â†’ [v128]
[v128] â†’ [v128]
[v128] â†’ [v128]
[v128 v128 v128] â†’ [v128]
[v128 v128 v128] â†’ [v128]
[v128 v128 v128] â†’ [v128]
[v128 v128 v128] â†’ [v128]
[v128 v128 v128] â†’ [v128]
[v128 v128 v128] â†’ [v128]
[v128 v128 v128] â†’ [v128]
[v128 v128 v128] â†’ [v128]
[v128 v128] â†’ [v128]
[v128 v128] â†’ [v128]
[v128 v128] â†’ [v128]
[v128 v128] â†’ [v128]
[v128 v128] â†’ [v128]
[v128 v128] â†’ [v128]

validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
validation
execution
continues on

304

Chapter 7. Appendix

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

Table 2 â€“ continued from previous page
Instruction

Binary Opcode

Type

Validation

Executio

i32x4.relaxed_dot_i8x16_i7x16_add_s
(reserved)
(reserved)

0xFD 0x93 0x02
0xFE
0xFF

[v128 v128 v128] â†’ [v128]

validation

execution

Ã² Note
Multi-byte opcodes are given with the shortest possible encoding in the table. However, what is following the
first byte is actually a u32 with variable-length encoding and consequently has multiple possible representations.

7.11 Index of Semantic Rules
7.11.1 Well-formedness of Types
Construct

Judgement

Numeric type
Vector type
Heap type
Reference type
Value type
Packed type
Storage type
Field type
Result type
Instruction type
Function type
Structure type
Array type
Composite type
Sub type
Recursive type
Defined type
Block type
Table type
Memory type
Global type
Tag type
External type
Type definitions

ğ¶ âŠ¢ numtype ok
ğ¶ âŠ¢ vectype ok
ğ¶ âŠ¢ heaptype ok
ğ¶ âŠ¢ reftype ok
ğ¶ âŠ¢ valtype ok
ğ¶ âŠ¢ packedtype ok
ğ¶ âŠ¢ storagetype ok
ğ¶ âŠ¢ fieldtype ok
ğ¶ âŠ¢ resulttype ok
ğ¶ âŠ¢ instrtype ok
ğ¶ âŠ¢ functype ok
ğ¶ âŠ¢ structtype ok
ğ¶ âŠ¢ arraytype ok
ğ¶ âŠ¢ comptype ok
ğ¶ âŠ¢ subtype ok
ğ¶ âŠ¢ rectype ok
ğ¶ âŠ¢ deftype ok
ğ¶ âŠ¢ blocktype : instrtype
ğ¶ âŠ¢ tabletype ok
ğ¶ âŠ¢ memtype ok
ğ¶ âŠ¢ globaltype ok
ğ¶ âŠ¢ tagtype ok
ğ¶ âŠ¢ externtype ok
ğ¶ âŠ¢ type * ok

7.11. Index of Semantic Rules

305

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

7.11.2 Typing of Static Constructs
Construct

Judgement

Instruction
Instruction sequence
Catch clause
Expression
Function
Local
Table
Memory
Limits
Global
Tag
Element segment
Element mode
Data segment
Data mode
Start function
Export
Export description
Import
Import description
Module

ğ‘†; ğ¶ âŠ¢ instr : functype
ğ‘†; ğ¶ âŠ¢ instr * : functype
ğ¶ âŠ¢ catch ok
ğ¶ âŠ¢ expr : resulttype
ğ¶ âŠ¢ func : functype
ğ¶ âŠ¢ local : localtype
ğ¶ âŠ¢ table : tabletype
ğ¶ âŠ¢ mem : memtype
ğ¶ âŠ¢ limits : ğ‘˜
ğ¶ âŠ¢ global : globaltype
ğ¶ âŠ¢ tag : tagtype
ğ¶ âŠ¢ elem : reftype
ğ¶ âŠ¢ elemmode : reftype
ğ¶ âŠ¢ data ok
ğ¶ âŠ¢ datamode ok
ğ¶ âŠ¢ start ok
ğ¶ âŠ¢ export : externtype
ğ¶ âŠ¢ exportdesc : externtype
ğ¶ âŠ¢ import : externtype
ğ¶ âŠ¢ importdesc : externtype
âŠ¢ module : externtype * â†’ externtype *

7.11.3 Typing of Runtime Constructs
Construct

Judgement

Value
Result
Packed value
Field value
External value
Function instance
Table instance
Memory instance
Global instance
Tag instance
Element instance
Data instance
Structure instance
Array instance
Export instance
Module instance
Store
Configuration
Thread
Frame

ğ‘† âŠ¢ val : valtype
ğ‘† âŠ¢ result : resulttype
ğ‘† âŠ¢ packedval : packedtype
ğ‘† âŠ¢ fieldval : storagetype
ğ‘† âŠ¢ externval : externtype
ğ‘† âŠ¢ funcinst : functype
ğ‘† âŠ¢ tableinst : tabletype
ğ‘† âŠ¢ meminst : memtype
ğ‘† âŠ¢ globalinst : globaltype
ğ‘† âŠ¢ taginst : tagtype
ğ‘† âŠ¢ eleminst : ğ‘¡
ğ‘† âŠ¢ datainst ok
ğ‘† âŠ¢ structinst ok
ğ‘† âŠ¢ arrayinst ok
ğ‘† âŠ¢ exportinst ok
ğ‘† âŠ¢ moduleinst : ğ¶
âŠ¢ store ok
âŠ¢ config ok
ğ‘†; resulttype ? âŠ¢ thread : resulttype
ğ‘† âŠ¢ frame : ğ¶

7.11.4 Defaultability

306

Construct

Judgement

Defaultable value type

ğ¶ âŠ¢ valtype defaultable

Chapter 7. Appendix

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

7.11.5 Constantness
Construct

Judgement

Constant expression
Constant instruction

ğ¶ âŠ¢ expr const
ğ¶ âŠ¢ instr const

7.11.6 Matching
Construct

Judgement

Number type
Vector type
Heap type
Reference type
Value type
Packed type
Storage type
Field type
Result type
Instruction type
Function type
Structure type
Array type
Composite type
Defined type
Table type
Memory type
Global type
Tag type
External type
Limits

ğ¶ âŠ¢ numtype 1 â‰¤ numtype 2
ğ¶ âŠ¢ vectype 1 â‰¤ vectype 2
ğ¶ âŠ¢ heaptype 1 â‰¤ heaptype 2
ğ¶ âŠ¢ reftype 1 â‰¤ reftype 2
ğ¶ âŠ¢ valtype 1 â‰¤ valtype 2
ğ¶ âŠ¢ packedtype 1 â‰¤ packedtype 2
ğ¶ âŠ¢ storagetype 1 â‰¤ storagetype 2
ğ¶ âŠ¢ fieldtype 1 â‰¤ fieldtype 2
ğ¶ âŠ¢ resulttype 1 â‰¤ resulttype 2
ğ¶ âŠ¢ instrtype 1 â‰¤ instrtype 2
ğ¶ âŠ¢ functype 1 â‰¤ functype 2
ğ¶ âŠ¢ structtype 1 â‰¤ structtype 2
ğ¶ âŠ¢ arraytype 1 â‰¤ arraytype 2
ğ¶ âŠ¢ comptype 1 â‰¤ comptype 2
ğ¶ âŠ¢ deftype 1 â‰¤ deftype 2
ğ¶ âŠ¢ tabletype 1 â‰¤ tabletype 2
ğ¶ âŠ¢ memtype 1 â‰¤ memtype 2
ğ¶ âŠ¢ globaltype 1 â‰¤ globaltype 2
ğ¶ âŠ¢ tagtype 1 â‰¤ tagtype 2
ğ¶ âŠ¢ externtype 1 â‰¤ externtype 2
ğ¶ âŠ¢ limits 1 â‰¤ limits 2

7.11.7 Store Extension
Construct

Judgement

Function instance
Table instance
Memory instance
Global instance
Tag instance
Element instance
Data instance
Structure instance
Array instance
Store

âŠ¢ funcinst 1 âª¯ funcinst 2
âŠ¢ tableinst 1 âª¯ tableinst 2
âŠ¢ meminst 1 âª¯ meminst 2
âŠ¢ globalinst 1 âª¯ globalinst 2
âŠ¢ taginst 1 âª¯ taginst 2
âŠ¢ eleminst 1 âª¯ eleminst 2
âŠ¢ datainst 1 âª¯ datainst 2
âŠ¢ structinst 1 âª¯ structinst 2
âŠ¢ arrayinst 1 âª¯ arrayinst 2
âŠ¢ store 1 âª¯ store 2

7.11.8 Execution
Construct

Judgement

Instruction
Expression

ğ‘†; ğ¹ ; instr * Ë“â†’ ğ‘† â€² ; ğ¹ â€² ; instr â€²
ğ‘†; ğ¹ ; expr Ë“â†’ ğ‘† â€² ; ğ¹ â€² ; expr â€²

7.11. Index of Semantic Rules

*

307

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

308

Chapter 7. Appendix

Index

Symbols
:

abstract syntax
administrative instruction, 87

A
abbreviations, 210
abstract syntax, 5, 181, 209, 249, 251
array address, 82
array instance, 85
array type, 11, 34
block type, 20, 33
byte, 6
composite type, 11, 34
data, 25, 73
data address, 82
data index, 22
data instance, 85
defined type, 28, 36, 42
element, 24, 72
element address, 82
element index, 22
element instance, 84
element mode, 24
exception address, 82
exception instance, 86
export, 25, 74
export instance, 85
expression, 22, 68, 170
external type, 13, 37
external value, 85
field index, 22
field type, 11, 34, 35
field value, 85
floating-point number, 7
frame, 86
function, 23, 70
function address, 82
function index, 22
function instance, 83
function type, 11, 34
global, 24, 71
global address, 82
global index, 22

global instance, 84
global type, 12, 37
grammar, 5
handler, 86
heap type, 9, 27, 32
host address, 82
import, 26, 75
instruction, 13, 14, 17â€“20, 45, 46, 51, 54â€“57,
61, 118, 120, 134, 143, 145, 150, 159
instruction type, 29, 34
integer, 7
label, 86
label index, 22
limits, 12, 36
local, 23, 70
local index, 22
local type, 29
memory, 24, 71
memory address, 82
memory index, 22
memory instance, 84
memory type, 12, 36
module, 22, 76
module instance, 83
mutability, 12
name, 8
notation, 5
number type, 8, 9, 32
packed type, 11, 35
packed value, 85
recursive type, 11, 35
recursive type index, 27
reference type, 10, 33
result, 82
result type, 11, 33
signed integer, 7
start function, 25, 74
storage type, 11, 35
store, 82
structure address, 82
structure instance, 85
structure type, 11, 34
sub type, 11, 27, 35
table, 24, 71
309

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

table address, 82
binary format, 185
table index, 22
text format, 217
table instance, 84
validation, 34
table type, 12, 36
ASCII, 211, 212, 214
tag, 12, 24, 72
B
tag address, 82
tag index, 22
binary format, 8, 181, 242, 249, 252, 270, 277
tag instance, 84
aggregate type, 185
tag type, 37
array type, 185
type, 8, 69
block type, 187
type definition, 23
byte, 183
type index, 22
composite type, 186
uninterpreted integer, 7
custom section, 202
unsigned integer, 7
data, 205
value, 6, 81
data count, 205
value type, 10, 27, 33, 35
data index, 200
vector, 6, 8
element, 203
vector type, 32
element index, 200
abstract type, 9, 27
export, 203
activation, 86
expression, 200
active, 24, 25
field index, 200
address, 82, 143, 145, 150, 159, 171
field type, 185
array, 82
floating-point number, 183
data, 82
function, 202, 204
element, 82
function index, 200
exception, 82
function type, 185
function, 82
global, 203
global, 82
global index, 200
host, 82
global type, 186
memory, 82
grammar, 181
structure, 82
heap type, 184
table, 82
import, 202
tag, 82
instruction, 187â€“191, 194
address type, 217, 289
integer, 183
text format, 217
label index, 200
administrative instruction, 262, 263
limits, 186
: abstract syntax, 87
local, 204
administrative instructions, 87
local index, 200
aggreagate type, 11
memory, 203
aggregate reference, 47
memory index, 200
aggregate type, 11, 23, 34, 41, 185, 217
memory type, 186
binary format, 185
module, 205
text format, 217
mutability, 186
validation, 34
name, 183
algorithm, 270
notation, 181
allocation, 82, 171, 242, 253
number type, 184
annotation, 212, 277, 293
packed type, 185
arithmetic NaN, 7
recursive type, 186
array, 81, 115
reference type, 185
address, 82
result type, 185
instance, 85
section, 201
array address
signed integer, 183
abstract syntax, 82
start function, 203
array instance, 82, 85, 115, 257, 260, 266
storage type, 185
abstract syntax, 85
structure type, 185
array type, 11, 11, 34, 39, 41, 85, 115, 185, 186, 217,
sub type, 186
257, 270, 290
table, 202
abstract syntax, 11
table index, 200
310

Index

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

table type, 186
tag, 205
tag index, 200
tag type, 187
type, 184
type index, 200
type section, 202
uninterpreted integer, 183
unsigned integer, 183
value, 182
value type, 185
vector, 182
vector type, 184
bit, 91
bit width, 7â€“9, 11, 90, 150
block, 20, 61, 159, 167, 187, 218, 283
type, 20
block context, 88
block type, 20, 33, 61, 187
abstract syntax, 20
binary format, 187
validation, 33
Boolean, 3, 91, 92
bottom type, 27, 254
branch, 20, 61, 88, 159, 187, 218
byte, 6, 8, 25, 73, 84, 85, 92, 172, 181, 183, 205, 214,
235, 237, 246, 259
abstract syntax, 6
binary format, 183
text format, 214

C
call, 86, 87, 168, 288
canonical NaN, 7
cast, 17
catch clause, 89
catching try block, 20
caught, 87
caught exception, 87
changes, 282
character, 2, 8, 211, 211, 212, 214, 251, 253
text format, 211
closed type, 27
closure, 83
code, 13, 252
section, 204
code section, 204
comment, 211, 212
composite type, 11, 11, 34, 35, 186, 217, 270, 290
abstract syntax, 11
binary format, 186
text format, 217
validation, 34
composite types, 41
compositionality, 269
concepts, 3
concrete type, 9, 27
configuration, 80, 89, 262, 267
Index

constant, 22, 24, 25, 68, 71â€“73, 81, 288
context, 30, 44, 55â€“57, 61, 76, 205, 254, 261â€“263
control instruction, 20
control instructions, 61, 159, 187, 218
custom annotation, 281
custom section, 202, 277, 281, 293
binary format, 202

D
data, 22, 24, 25, 73, 76, 87, 173, 205, 235, 237, 238,
251
abstract syntax, 25
address, 82
binary format, 205
index, 22
instance, 85
section, 205
segment, 25, 73, 205, 235, 237
text format, 235, 237
validation, 73
data address, 83, 173
abstract syntax, 82
data count, 205
binary format, 205
section, 205
data count section, 205
data index, 22, 25, 200, 232
abstract syntax, 22
binary format, 200
text format, 232
data instance, 82, 83, 85, 173, 259, 266
abstract syntax, 85
data section, 205
data segment, 84, 85, 205, 285, 288
declarative, 24
decoding, 4
default value, 81
defaultable, 38, 71
defined type, 13, 28, 29, 36, 39, 42, 69, 85, 115, 257,
259, 260, 270
abstract syntax, 28, 36, 42
design goals, 1
determinism, 90, 100, 118, 146, 155, 251, 293
deterministic profile, 251
dynamic type, 114, 115

E
element, 12, 22, 24, 24, 72, 76, 87, 173, 203, 205, 234,
237, 238, 245, 251
abstract syntax, 24
address, 82
binary format, 203
index, 22
instance, 84
mode, 24
section, 203
segment, 24, 72, 203, 234, 237
text format, 234, 237
311

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

validation, 72
element address, 83, 145, 173
abstract syntax, 82
element expression, 84
element index, 22, 24, 200, 232
abstract syntax, 22
binary format, 200
text format, 232
element instance, 82, 83, 84, 145, 173, 259, 266
abstract syntax, 84
element mode, 24
abstract syntax, 24
element section, 203
element segment, 84, 284, 285
element type, 42
embedder, 2, 3, 82, 84, 85, 241
embedding, 241
evaluation context, 80, 89
exception, 20, 82, 86, 87, 89, 167, 168, 177, 179, 247,
256, 288
address, 82
instance, 86
exception address, 82, 247
abstract syntax, 82
exception handler, 86
exception handling, 187
exception instance, 82, 86, 247, 260, 267
abstract syntax, 86
exception tag, 12, 37, 72, 84, 118, 168, 187, 205,
236
tag, 12
exception type, 247
execution, 4, 8, 11, 79, 249, 253
expression, 170
instruction, 118, 120, 134, 143, 145, 150, 159
expand, 36
expansion, 29
exponent, 7, 91
export, 22, 25, 74, 76, 85, 174, 179, 203, 205, 234â€“
236, 238, 243, 244, 251, 284, 288
abstract syntax, 25
binary format, 203
instance, 85
section, 203
text format, 234â€“236
validation, 74
export instance, 83, 85, 174, 244, 261
abstract syntax, 85
export section, 203
expression, 22, 23â€“25, 68, 70â€“73, 170, 200, 203, 205,
232, 234, 235, 237, 288
abstract syntax, 22
binary format, 200
constant, 22, 68, 200, 232
execution, 170
text format, 232
validation, 68
extern type, 263

312

extern value, 263
external
type, 13
value, 85
external reference, 51, 81
external type, 13, 37, 43, 117, 174, 249, 261
abstract syntax, 13
validation, 37
external value, 13, 85, 85, 117, 174, 261
abstract syntax, 85

F
field, 22, 279, 280
index, 22
field index, 22, 200, 279
abstract syntax, 22
binary format, 200
field type, 11, 34, 35, 41, 185, 217, 259, 260, 266,
270, 290
abstract syntax, 11
binary format, 185
text format, 217
validation, 35
field value, 85, 259, 260, 266
abstract syntax, 85
file extension, 181, 209
final, 11, 35
floating point, 2
floating-point, 3, 7, 8, 9, 13, 81, 90, 91, 98, 283
floating-point number, 183, 213
abstract syntax, 7
binary format, 183
text format, 213
folded instruction, 231
frame, 86, 87, 89, 143, 145, 150, 159, 168, 253, 262,
264, 270
abstract syntax, 86
full profile, 251
function, 2, 3, 10, 11, 20, 22, 23, 25, 26, 30, 70, 76,
83, 85â€“87, 115, 168, 171, 174, 179, 202, 204,
205, 233, 238, 244, 251â€“253, 279, 280, 283,
288, 290, 293
abstract syntax, 23, 70
address, 82
binary format, 202, 204
export, 25
import, 26
index, 22
instance, 83
section, 202
text format, 233
type, 11
function address, 84, 85, 87, 117, 171, 174, 179,
244, 245, 258, 263
abstract syntax, 82
function index, 20, 22, 23â€“26, 61, 70, 72, 74, 159,
174, 187, 200, 203, 218, 232, 234, 236, 237,
279
Index

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

abstract syntax, 22
binary format, 200
text format, 232
function instance, 82, 83, 83, 87, 115, 168, 171,
174, 179, 244, 253, 257, 258, 264, 265
abstract syntax, 83
function section, 202
function type, 10, 11, 11â€“13, 20, 22, 23, 26, 27, 30,
34, 37, 39, 40, 43, 70, 72, 75, 76, 83, 115, 117,
118, 171, 179, 185â€“187, 202, 204, 205, 216,
217, 233, 236, 238, 244, 247, 257, 258, 263,
270, 290
abstract syntax, 11
binary format, 185
text format, 216
validation, 34
function type index, 205

heap type, 9, 10, 17, 27, 32, 33, 39, 184, 215, 234,
254, 256, 290
abstract syntax, 9, 27
binary format, 184
text format, 215
validation, 32
host, 2, 82, 241
address, 82
host address, 81
abstract syntax, 82
host function, 83, 170, 171, 244, 258

I

identifier, 209, 210, 233â€“236, 238, 253, 293
identifier context, 210, 238
identifiers, 215
text format, 215
IEEE 754, 2, 3, 7â€“9, 91, 98
G
implementation, 241, 251
global, 12, 19, 22, 24, 25, 26, 30, 71, 76, 84, 85, 172, implementation limitations, 251
import, 2, 13, 22â€“24, 26, 70, 75, 76, 117, 174, 202,
174, 203, 205, 235, 238, 247, 251
205, 233â€“236, 238, 243, 251, 284, 288
abstract syntax, 24
abstract syntax, 26
address, 82
binary format, 202
binary format, 203
section, 202
export, 25
text format, 233â€“236
import, 26
validation, 75
index, 22
import section, 202
instance, 84
index, 22, 25, 26, 74, 83, 200, 203, 210, 218, 232, 234â€“
mutability, 12
236, 278
section, 203
data, 22
text format, 235
element, 22
type, 12
field, 22
validation, 71
function, 22
global address, 83, 85, 117, 143, 172, 174, 247
global, 22
abstract syntax, 82
label, 22
global index, 19, 22, 24â€“26, 55, 74, 143, 174, 189,
local, 22
200, 203, 220, 232, 235, 236
memory, 22
abstract syntax, 22
table, 22
binary format, 200
tag, 22
text format, 232
type, 22
global instance, 82, 83, 84, 143, 172, 174, 247, 253,
index space, 22, 26, 27, 30, 210, 278
257, 259, 264, 265
instance, 83, 177
abstract syntax, 84
array, 85
global section, 203
data, 85
global type, 12, 13, 24, 26, 27, 30, 37, 43, 71, 75,
element, 84
117, 172, 186, 202, 203, 218, 233, 235, 247,
exception, 86
257, 259
export, 85
abstract syntax, 12
function, 83
binary format, 186
global, 84
text format, 218
memory, 84
validation, 37
module, 83
grammar notation, 5, 181, 209
structure, 85
greatest lower bound, 268
table, 84
grow, 173, 174
tag, 84
H
instantiation, 4, 8, 25, 26, 177, 243, 267
instantiation. module, 27
handler, 86, 87, 89, 168, 263, 288
abstract syntax, 86
Index

313

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

instruction, 3, 11, 13, 22, 29, 44, 67, 84, 86â€“89, 118,
167, 187, 218, 251, 262â€“264, 267, 270, 283â€“
285, 288â€“290, 292, 294
abstract syntax, 13, 14, 17â€“20
binary format, 187â€“191, 194
execution, 118, 120, 134, 143, 145, 150, 159
text format, 218, 220, 221, 223, 226
type, 29
validation, 45, 46, 51, 54â€“57, 61
instruction sequence, 67, 167
instruction type, 29, 33, 34, 40, 44, 85, 267â€“269,
290
abstract syntax, 29
validation, 34
instructions, 285
integer, 3, 7, 8, 9, 13, 81, 90â€“92, 145, 150, 183, 213,
283
abstract syntax, 7
binary format, 183
signed, 7
text format, 213
uninterpreted, 7
unsigned, 7
invocation, 4, 83, 179, 244, 267

validation, 70
local index, 19, 22, 23, 29, 55, 70, 143, 189, 200,
220, 232, 279
abstract syntax, 22
binary format, 200
text format, 232
local type, 29, 30, 67, 70, 290
abstract syntax, 29

M

magnitude, 7
matching, 38, 174, 290
memory, 3, 8, 9, 12, 19, 22, 24, 25, 26, 30, 71, 73, 76,
84, 85, 87, 92, 172, 174, 203, 205, 235, 237,
238, 246, 251, 285, 288, 289
abstract syntax, 24
address, 82
binary format, 203
data, 25, 73, 205, 235, 237
export, 25
import, 26
index, 22
instance, 84
limits, 12
section, 203
K
text format, 235
keyword, 211
type, 12
validation, 71
L
memory address, 83, 85, 117, 150, 172, 174, 246
abstract syntax, 82
label, 20, 61, 86, 87, 89, 159, 168, 187, 218, 253, 263,
memory
index, 19, 22, 24â€“26, 57, 73, 74, 150, 174,
270
190, 200, 203, 205, 221, 232, 235â€“237, 288
abstract syntax, 86
abstract
syntax, 22
index, 22
binary
format,
200
label index, 20, 22, 61, 159, 187, 200, 218, 232
text
format,
232
abstract syntax, 22
memory instance, 82, 83, 84, 87, 150, 172, 174, 246,
binary format, 200
253, 257, 259, 264, 265
text format, 218, 232
abstract
syntax, 84
lane, 8, 92
memory
instruction,
19, 57, 150, 190, 221
least upper bound, 268
memory
section,
203
LEB128, 183, 187
memory type, 12, 12, 13, 24, 26, 27, 30, 36, 37, 42, 43,
lexical format, 211
71, 75, 84, 117, 172, 186, 202, 203, 218, 233,
limits, 12, 12, 24, 36, 42, 145, 150, 172â€“174, 186,
235, 246, 257, 259
218, 258, 259
abstract
syntax, 12
abstract syntax, 12
binary
format,
186
binary format, 186
text
format,
218
memory, 12
validation, 36
table, 12
module, 2, 3, 22, 30, 76, 82, 83, 174, 177, 179, 181,
text format, 218
205, 238, 242, 244, 251, 252, 267, 270, 279,
validation, 36
280, 293
linear memory, 3
abstract syntax, 22
little endian, 19, 92, 183
binary format, 205
local, 19, 22, 23, 29, 70, 86, 204, 233, 251, 262, 279,
instance, 83
280, 290, 293
text format, 238
abstract syntax, 23
validation, 76
binary format, 204
module instance, 83, 86, 115, 171, 174, 179, 243,
index, 22
244, 253, 261, 262
text format, 233
abstract syntax, 83
type, 29
314

Index

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

module instruction, 89
mutability, 12, 12, 24, 35, 37, 41, 43, 84, 117, 172,
185, 186, 217, 218, 259, 265
abstract syntax, 12
binary format, 186
global, 12
text format, 218

N
name, 2, 8, 25, 26, 74, 75, 83, 85, 183, 202, 203, 214,
233â€“236, 251, 261, 278, 279
abstract syntax, 8
binary format, 183
text format, 214
name annotation, 279
name map, 278
name section, 238, 278
NaN, 7, 90, 100, 118
arithmetic, 7
canonical, 7
payload, 7
non-determinism, 90, 100, 118, 146, 155, 251, 293
notation, 5, 181, 209
abstract syntax, 5
binary format, 181
text format, 209
null, 10, 17
null reference, 115
number, 14, 81
type, 8, 9
number type, 8, 10, 32, 33, 38, 40, 81, 184, 185, 215,
216, 270, 289
abstract syntax, 8, 9
binary format, 184
text format, 215
validation, 32
numeric instruction, 13, 45, 118, 191, 223
numeric vector, 8, 14, 91, 92

O
offset, 22
opcode, 187, 270, 274
operand, 13
operand stack, 13, 44

P
packed type, 11, 35, 41, 91, 185, 217, 260, 270
abstract syntax, 11
binary format, 185
text format, 217
validation, 35
packed value, 85, 260
abstract syntax, 85
page size, 12, 19, 24, 84, 186, 218, 235
parameter, 11, 22, 251, 280
parametric instruction, 18, 189, 220
parametric instructions, 54, 143
passive, 24, 25
Index

payload, 7
phases, 4
polymorphism, 44, 54, 61, 187, 189, 218, 220, 267
portability, 1
preservation, 267
principal types, 267
profile, 249
deterministic, 251
full, 251
profiles, 293
progress, 267

R
reachability, 257
recursive type, 11, 28, 29, 35, 36, 42, 69, 186, 202,
217, 254, 256, 270, 290
abstract syntax, 11, 35
binary format, 186
text format, 217
recursive type index, 11, 27, 254, 256
abstract syntax, 27
reduction rules, 80
reference, 10, 17, 81, 120, 145, 218, 248, 259, 284,
290
type, 10
reference instruction, 17, 17, 188, 220
reference instructions, 46, 120
reference type, 10, 10, 12, 17, 33, 36, 38â€“40, 46, 71,
81, 145, 185, 186, 216, 218, 234, 248, 254,
270, 284, 288, 290
abstract syntax, 10
binary format, 185
text format, 216
validation, 33
reftype, 87
result, 11, 82, 244, 251, 256
abstract syntax, 82
type, 11
result type, 11, 11, 20, 27, 29, 30, 33, 40, 61, 68,
159, 185, 187, 216, 218, 256, 262â€“264, 283
abstract syntax, 11
binary format, 185
validation, 33
rewrite rule, 210
roll, 11
rolling, 27, 29
rounding, 99
runtime, 81, 306

S
S-expression, 209, 231
scalar reference, 51, 115
section, 201, 205, 252, 277
binary format, 201
code, 204
custom, 202
data, 205
data count, 205
315

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

element, 203
export, 203
function, 202
global, 203
import, 202
memory, 203
name, 238
start, 203
table, 202
tag, 205
type, 202
security, 2
segment, 87
shape, 92
sign, 92
signed integer, 7, 92, 183, 213
abstract syntax, 7
binary format, 183
text format, 213
significand, 7, 91
SIMD, 8, 9, 14, 285, 292
soundness, 254, 267
source text, 211, 211, 253
stack, 79, 86, 179, 270
stack machine, 13
start function, 22, 25, 74, 76, 203, 205, 236, 238
abstract syntax, 25
binary format, 203
section, 203
text format, 236
validation, 74
start section, 203
storage type, 11, 35, 41, 185, 217, 259, 260, 290
abstract syntax, 11
binary format, 185
text format, 217
validation, 35
store, 9, 79, 82, 82, 85, 86, 89, 115, 117, 118, 143, 145,
150, 159, 170, 171, 177, 179, 242, 244â€“247,
257, 260, 262â€“264
abstract syntax, 82
store extension, 264
string, 214
text format, 214
structure, 81, 115
address, 82
instance, 85
structure address
abstract syntax, 82
structure field, 293
structure instance, 82, 85, 115, 257, 259, 266
abstract syntax, 85
structure type, 11, 11, 34, 39, 41, 85, 115, 185, 186,
217, 257, 270, 280, 290
abstract syntax, 11
binary format, 185
text format, 217
validation, 34

316

structured control, 20, 61, 159, 187, 218
structured control instruction, 251
sub type, 11, 27, 29, 35, 186, 217, 254, 270, 290
abstract syntax, 11, 27, 35
binary format, 186
text format, 217
substitution, 28
subtyping, 11, 27, 35, 38, 249, 267â€“269, 290
syntax, 267

T
table, 3, 10, 12, 19, 20, 22, 24, 24â€“26, 30, 71, 72, 76,
84, 85, 87, 172â€“174, 202, 205, 234, 238, 245,
251, 284, 285, 289, 290
abstract syntax, 24
address, 82
binary format, 202
element, 24, 72, 203, 234, 237
export, 25
import, 26
index, 22
instance, 84
limits, 12
section, 202
text format, 234
type, 12
validation, 71
table address, 83, 85, 117, 145, 159, 172â€“174, 245
abstract syntax, 82
table index, 19, 22, 24â€“26, 56, 72, 74, 145, 174, 190,
200, 203, 221, 232, 234, 236, 237, 284
abstract syntax, 22
binary format, 200
text format, 232
table instance, 82, 83, 84, 87, 145, 159, 172â€“174,
245, 253, 257, 258, 264, 265
abstract syntax, 84
table instruction, 19, 56, 145, 190, 221
table section, 202
table type, 12, 12, 13, 24, 26, 27, 30, 36â€“38, 42, 43,
71, 75, 84, 117, 172, 186, 202, 218, 233, 234,
245, 257, 258, 284
abstract syntax, 12
binary format, 186
text format, 218
validation, 36
tag, 12, 20, 22, 24, 25, 26, 30, 72, 76, 84â€“87, 89, 168,
172, 174, 205, 236, 238, 247, 251, 260, 279,
281, 288
abstract syntax, 12, 24
address, 82
binary format, 205
exception tag, 12
export, 25
import, 26
index, 22
instance, 84
section, 205
Index

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

text format, 236
type; exception, 12
validation, 72
tag address, 83, 85â€“87, 118, 172, 174, 247, 260
abstract syntax, 82
tag index, 20, 22, 25, 26, 61, 74, 174, 187, 200, 203,
218, 232, 236, 279
abstract syntax, 22
binary format, 200
text format, 232
tag instance, 82, 83, 84, 87, 172, 174, 247, 257, 259,
266
abstract syntax, 84
tag section, 205
tag type, 12, 13, 20, 22, 24, 26, 27, 30, 37, 43, 72, 75,
84, 118, 172, 187, 202, 205, 233, 236, 247,
257, 259, 288
binary format, 187
validation, 37
terminal configuration, 267
text format, 2, 209, 242, 249, 253, 277, 293
address type, 217
aggregate type, 217
annotation, 212
array type, 217
byte, 214
character, 211
comment, 212
composite type, 217
data, 235, 237
data index, 232
element, 234, 237
element index, 232
export, 234â€“236
expression, 232
field type, 217
floating-point number, 213
function, 233
function index, 232
function type, 216
global, 235
global index, 232
global type, 218
grammar, 209
heap type, 215
identifiers, 215
import, 233â€“236
instruction, 218, 220, 221, 223, 226
integer, 213
label index, 218, 232
limits, 218
local, 233
local index, 232
memory, 235
memory index, 232
memory type, 218
module, 238
mutability, 218

Index

name, 214
notation, 209
number type, 215
packed type, 217
recursive type, 217
reference type, 216
signed integer, 213
start function, 236
storage type, 217
string, 214
structure type, 217
sub type, 217
table, 234
table index, 232
table type, 218
tag, 236
tag index, 232
token, 211
type, 215
type index, 232
type use, 232
uninterpreted integer, 213
unsigned integer, 213
value, 213
value type, 216
vector, 211
vector type, 215
white space, 212
thread, 89, 262, 267
throw, 256
throw address, 89
throw context, 89, 168, 263
token, 211, 253
trap, 3, 19, 20, 82, 87, 89, 118, 167, 177, 179, 256,
263, 283
try block, 20
two's complement, 3, 7, 13, 92, 183
type, 8, 69, 114, 174, 184, 215, 251, 279, 280, 293, 305
abstract syntax, 8, 69
binary format, 184
block, 20
external, 13
function, 11
global, 12
index, 22
instruction, 29
local, 29
memory, 12
number, 8, 9
reference, 10
result, 11
section, 202
table, 12
text format, 215
value, 10
type closure, 31
type definition, 22, 23, 76, 202, 205, 238
abstract syntax, 23

317

WebAssembly Specification, Release 3.0 (Draft 2025-09-16)

type equivalence, 29, 42
memory type, 36
type identifier, 32
module, 76
type index, 9, 20, 22, 23, 24, 26, 27, 61, 69, 70, 115,
number type, 32
159, 187, 200, 202, 204, 218, 232, 233, 279
packed type, 35
abstract syntax, 22
reference type, 33
binary format, 200
result type, 33
text format, 232
start function, 74
type instance, 82, 83
storage type, 35
type instantiation, 115
structure type, 34
type lattice, 268
table, 71
type section, 202
table type, 36
binary format, 202
tag, 72
type system, 27, 254, 267
tag type, 37
type use, 232
value type, 33
text format, 232
vector type, 32
typing rules, 31
validity, 267
value, 3, 6, 13, 14, 24, 44, 81, 82, 84, 89, 90, 115, 118,
U
143, 145, 150, 172, 179, 182, 213, 244, 247,
248, 253, 256, 259, 262, 263, 265
unboxed scalar, 9, 81
abstract syntax, 6, 81
unboxed scalar type, 39
binary format, 182
Unicode, 2, 8, 183, 209, 211, 214, 251
external, 85
unicode, 253
text format, 213
Unicode UTF-8, 278, 279
type, 10
uninterpreted integer, 7, 92, 183, 213
value type, 10, 11â€“14, 18, 20, 23, 27, 29, 30, 33, 35,
abstract syntax, 7
37, 38, 40, 41, 43, 54, 70, 81, 91, 115, 117,
binary format, 183
118, 150, 172, 185â€“187, 189, 216â€“218, 220,
text format, 213
248, 249, 254, 256, 262, 263, 270, 283â€“285,
unroll, 11, 36, 42
290
unrolling, 27, 29
abstract syntax, 10, 27
unsigned integer, 7, 92, 183, 213
binary format, 185
abstract syntax, 7
text format, 216
binary format, 183
validation, 33
text format, 213
variable instruction, 19
UTF-8, 2, 8, 183, 209, 214
variable instructions, 55, 143, 189, 220
vector, 6, 11, 20, 24, 25, 61, 159, 182, 187, 211, 218
V
abstract syntax, 6, 8
validation, 4, 8, 27, 115, 117, 118, 242, 249, 253,
binary format, 182
260, 270, 305
text format, 211
aggregate type, 34
vector
instruction, 14, 51, 134, 194, 226, 292
array type, 34
vector
number, 81
block type, 33
vector
type, 9, 10, 32, 33, 38, 81, 184, 215, 216, 270,
composite type, 34
285
data, 73
binary
format, 184
element, 72
text
format,
215
export, 74
validation,
32
expression, 68
version, 205
external type, 37
field type, 35
function type, 34
global, 71
global type, 37
heap type, 32
import, 75
instruction, 45, 46, 51, 54â€“57, 61
instruction type, 34
limits, 36
local, 70
memory, 71

318

W
white space, 211, 212

Index

