//! JS glue generator for browser async interop.
//!
//! When compiling with `--target=wasm32` (not WASI), generates a `.js` file
//! alongside the `.wasm` that provides:
//! - Wasm module loading (`init(path)`)
//! - Automatic detection of async functions via `_poll` naming convention
//! - Promise wrapping of async exports
//! - Pass-through of sync exports

const std = @import("std");

/// Generate JS glue code for a given Wasm filename.
/// Returns owned slice that caller must free.
pub fn generate(allocator: std.mem.Allocator, wasm_filename: []const u8) ![]u8 {
    var out = std.ArrayListUnmanaged(u8){};
    errdefer out.deinit(allocator);

    try out.appendSlice(allocator, "// Generated by cot --target=wasm32\n");
    try out.appendSlice(allocator, "// ");
    try out.appendSlice(allocator, wasm_filename);
    try out.appendSlice(allocator, "\n");
    try out.appendSlice(allocator, js_template);

    return out.toOwnedSlice(allocator);
}

const js_template =
    \\let wasm;
    \\
    \\export async function init(wasmPath) {
    \\  const importObject = { env: {} };
    \\  if (typeof fetch === 'function') {
    \\    const resp = await fetch(wasmPath);
    \\    const bytes = await resp.arrayBuffer();
    \\    wasm = (await WebAssembly.instantiate(bytes, importObject)).instance;
    \\  } else {
    \\    const fs = await import('fs');
    \\    const bytes = fs.readFileSync(wasmPath);
    \\    wasm = (await WebAssembly.instantiate(bytes, importObject)).instance;
    \\  }
    \\  return getExports();
    \\}
    \\
    \\function wrapAsync(ctor, poll) {
    \\  return (...args) => new Promise(resolve => {
    \\    const state = ctor(...args);
    \\    (function loop() {
    \\      if (poll(state) === 1) {
    \\        const mem = new DataView(wasm.exports.memory.buffer);
    \\        resolve(Number(mem.getBigInt64(state + 8, true)));
    \\      } else {
    \\        setTimeout(loop, 0);
    \\      }
    \\    })();
    \\  });
    \\}
    \\
    \\export function getExports() {
    \\  if (!wasm) throw new Error('Call init() first');
    \\  const ex = wasm.exports;
    \\  const result = {};
    \\  const asyncSet = new Set();
    \\  for (const k of Object.keys(ex)) {
    \\    if (k.endsWith('_poll') && typeof ex[k] === 'function') {
    \\      asyncSet.add(k.slice(0, -5));
    \\    }
    \\  }
    \\  for (const k of Object.keys(ex)) {
    \\    if (typeof ex[k] !== 'function') continue;
    \\    if (k.endsWith('_poll') || k.startsWith('cot_') || k.startsWith('__')) continue;
    \\    result[k] = asyncSet.has(k) ? wrapAsync(ex[k], ex[k + '_poll']) : ex[k];
    \\  }
    \\  return result;
    \\}
    \\
;

// ============================================================================
// Tests
// ============================================================================

test "generate produces valid JS glue" {
    const allocator = std.testing.allocator;
    const result = try generate(allocator, "app.wasm");
    defer allocator.free(result);

    // Must contain key patterns
    try std.testing.expect(std.mem.indexOf(u8, result, "WebAssembly.instantiate") != null);
    try std.testing.expect(std.mem.indexOf(u8, result, "wrapAsync") != null);
    try std.testing.expect(std.mem.indexOf(u8, result, "_poll") != null);
    try std.testing.expect(std.mem.indexOf(u8, result, "export async function init") != null);
    try std.testing.expect(std.mem.indexOf(u8, result, "export function getExports") != null);
    try std.testing.expect(std.mem.indexOf(u8, result, "app.wasm") != null);
}

test "generate filters internal exports" {
    const allocator = std.testing.allocator;
    const result = try generate(allocator, "test.wasm");
    defer allocator.free(result);

    // JS code filters cot_ and __ prefixed exports
    try std.testing.expect(std.mem.indexOf(u8, result, "startsWith('cot_')") != null);
    try std.testing.expect(std.mem.indexOf(u8, result, "startsWith('__')") != null);
}
