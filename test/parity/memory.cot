// Parity tests for memory - ported from bootstrap-0.2/test/parity/memory/
// Skipped: 003-008,011-013,017-019,025-027,030,032,033,036-053 (extern/malloc)

// === Struct definitions ===

struct MemData { a: i64, b: i64 }
struct MemRecord { id: i64, value: i64, flags: i64 }
struct MemData4 { a: i64, b: i64, c: i64, d: i64 }
struct MemData3 { a: i64, b: i64, c: i64 }

// === Helper functions ===

fn mem_swap(a: *i64, b: *i64) void {
    var t: i64 = a.*;
    a.* = b.*;
    b.* = t;
}

fn mem_indirect_add(ptr: *i64, val: i64) void {
    ptr.* = ptr.* + val;
}

fn mem_inc_ptr(p: *i64) void { p.* = p.* + 1; }

fn mem_get_addr(p: **i64, x: *i64) void { p.* = x; }

fn mem_copy_struct(src: *MemData, dst: *MemData) void {
    dst.a = src.a;
    dst.b = src.b;
}

fn mem_init_data(d: *MemData4, v: i64) void {
    d.a = v;
    d.b = v * 2;
    d.c = v * 3;
    d.d = v * 4;
}

fn mem_clear_data(d: *MemData3) void {
    d.a = 0;
    d.b = 0;
    d.c = 0;
}

// === Test functions ===

// mem_001: stack local
fn test_mem_001() i64 {
    var a: i64 = 1;
    var b: i64 = 2;
    var c: i64 = 3;
    var d: i64 = 4;
    var e: i64 = 5;
    if a + b + c + d + e != 15 { return 1; }
    return 0;
}

// mem_002: many locals
fn test_mem_002() i64 {
    var v1: i64 = 1;
    var v2: i64 = 2;
    var v3: i64 = 3;
    var v4: i64 = 4;
    var v5: i64 = 5;
    var v6: i64 = 6;
    var v7: i64 = 7;
    var v8: i64 = 8;
    if v1 + v2 + v3 + v4 + v5 + v6 + v7 + v8 != 36 { return 1; }
    return 0;
}

// mem_009: swap
fn test_mem_009() i64 {
    var x: i64 = 10;
    var y: i64 = 20;
    mem_swap(&x, &y);
    if x != 20 { return 1; }
    return 0;
}

// mem_010: indirect
fn test_mem_010() i64 {
    var x: i64 = 10;
    mem_indirect_add(&x, 5);
    mem_indirect_add(&x, 5);
    if x != 20 { return 1; }
    return 0;
}

// mem_014: ptr param
fn test_mem_014() i64 {
    var x: i64 = 41;
    mem_inc_ptr(&x);
    if x != 42 { return 1; }
    return 0;
}

// mem_015: double deref
fn test_mem_015() i64 {
    var x: i64 = 42;
    var p1: *i64 = &x;
    var p2: **i64 = &p1;
    if p2.*.* != 42 { return 1; }
    return 0;
}

// mem_016: addr of local
fn test_mem_016() i64 {
    var val: i64 = 100;
    var ptr: *i64 = &val;
    if ptr.* != 100 { return 1; }
    return 0;
}

// mem_020: struct copy
fn test_mem_020() i64 {
    var s1: MemData = undefined;
    var s2: MemData = undefined;
    s1.a = 100;
    s1.b = 200;
    mem_copy_struct(&s1, &s2);
    if s2.a + s2.b != 300 { return 1; }
    return 0;
}

// mem_021: ptr chain
fn test_mem_021() i64 {
    var a: i64 = 42;
    var p1: *i64 = &a;
    var p2: *i64 = p1;
    var p3: *i64 = p2;
    if p3.* != 42 { return 1; }
    return 0;
}

// mem_022: modify via ptr
fn test_mem_022() i64 {
    var x: i64 = 10;
    var p: *i64 = &x;
    p.* = p.* + 5;
    p.* = p.* * 2;
    if x != 30 { return 1; }
    return 0;
}

// mem_023: multi ptr mod
fn test_mem_023() i64 {
    var a: i64 = 1;
    var b: i64 = 2;
    var pa: *i64 = &a;
    var pb: *i64 = &b;
    pa.* = pa.* + pb.*;
    pb.* = pa.* + pb.*;
    if a + b != 8 { return 1; }
    return 0;
}

// mem_024: ptr reassign
fn test_mem_024() i64 {
    var a: i64 = 10;
    var b: i64 = 20;
    var p: *i64 = &a;
    var sum: i64 = p.*;
    p = &b;
    sum = sum + p.*;
    if sum != 30 { return 1; }
    return 0;
}

// mem_028: nested ptr deref
fn test_mem_028() i64 {
    var a: i64 = 100;
    var b: i64 = 200;
    var pa: *i64 = &a;
    var pb: *i64 = &b;
    var ppa: **i64 = &pa;
    var ppb: **i64 = &pb;
    var sum: i64 = ppa.*.* + ppb.*.*;
    if sum != 300 { return 1; }
    return 0;
}

// mem_029: ptr swap
fn test_mem_029() i64 {
    var a: i64 = 10;
    var b: i64 = 20;
    var pa: *i64 = &a;
    var pb: *i64 = &b;
    var tmp: *i64 = pa;
    pa = pb;
    pb = tmp;
    if pa.* != 20 { return 1; }
    if pb.* != 10 { return 1; }
    return 0;
}

// mem_031: struct offset
fn test_mem_031() i64 {
    var r: MemRecord = undefined;
    r.id = 1;
    r.value = 100;
    r.flags = 7;
    var ptr: *MemRecord = &r;
    var sum: i64 = ptr.id + ptr.value + ptr.flags;
    if sum != 108 { return 1; }
    return 0;
}

// mem_034: struct init all
fn test_mem_034() i64 {
    var d: MemData4 = undefined;
    mem_init_data(&d, 10);
    if d.a != 10 { return 1; }
    if d.b != 20 { return 1; }
    if d.c != 30 { return 1; }
    if d.d != 40 { return 1; }
    return 0;
}

// mem_035: struct clear
fn test_mem_035() i64 {
    var d: MemData3 = undefined;
    d.a = 100;
    d.b = 200;
    d.c = 300;
    mem_clear_data(&d);
    if d.a != 0 { return 1; }
    if d.b != 0 { return 1; }
    if d.c != 0 { return 1; }
    return 0;
}

// === Main ===

fn main() i64 {
    var failures: i64 = 0;
    failures = failures + test_mem_001();
    failures = failures + test_mem_002();
    failures = failures + test_mem_009();
    failures = failures + test_mem_010();
    failures = failures + test_mem_014();
    failures = failures + test_mem_015();
    failures = failures + test_mem_016();
    failures = failures + test_mem_020();
    failures = failures + test_mem_021();
    failures = failures + test_mem_022();
    failures = failures + test_mem_023();
    failures = failures + test_mem_024();
    failures = failures + test_mem_028();
    failures = failures + test_mem_029();
    failures = failures + test_mem_031();
    failures = failures + test_mem_034();
    failures = failures + test_mem_035();
    return failures;
}
