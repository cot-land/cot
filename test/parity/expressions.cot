// Parity tests: Expressions
// Ported from bootstrap-0.2/test/parity/expressions/ (160 tests)
// Each test function returns 0 on pass, 1 on fail.
// main() returns total number of failures (0 = all pass).

// === Helper functions (unique names to avoid collisions) ===

fn expr_add(a: i64, b: i64) i64 { return a + b; }
fn expr_sub(a: i64, b: i64) i64 { return a - b; }
fn expr_mul(a: i64, b: i64) i64 { return a * b; }
fn expr_div(a: i64, b: i64) i64 { return a / b; }
fn expr_calc(a: i64, b: i64, c: i64) i64 { return (a + b) * c; }
fn expr_inner(x: i64) i64 { return x * 2; }
fn expr_outer(x: i64) i64 { return expr_inner(x) + 1; }
fn expr_mod(a: i64, b: i64) i64 { return a % b; }
fn expr_neg(x: i64) i64 { return -x; }
fn expr_bitand(a: i64, b: i64) i64 { return a & b; }
fn expr_bitor(a: i64, b: i64) i64 { return a | b; }
fn expr_bitxor(a: i64, b: i64) i64 { return a ^ b; }
fn expr_shl(a: i64, b: i64) i64 { return a << b; }
fn expr_shr(a: i64, b: i64) i64 { return a >> b; }
fn expr_lt(a: i64, b: i64) i64 { if a < b { return 1; } return 0; }
fn expr_le(a: i64, b: i64) i64 { if a <= b { return 1; } return 0; }
fn expr_gt(a: i64, b: i64) i64 { if a > b { return 1; } return 0; }
fn expr_ge(a: i64, b: i64) i64 { if a >= b { return 1; } return 0; }
fn expr_eq(a: i64, b: i64) i64 { if a == b { return 1; } return 0; }
fn expr_ne(a: i64, b: i64) i64 { if a != b { return 1; } return 0; }
fn expr_chain(a: i64, b: i64, c: i64) i64 { return a + b + c + a + b + c; }
fn expr_prec() i64 { return 2 + 3 * 4; }
fn expr_left_assoc() i64 { return 100 - 30 - 20; }
fn expr_mixed() i64 { return 10 + 20 * 3 - 5; }
fn expr_div_mod(a: i64, b: i64) i64 { return (a / b) + (a % b); }
fn expr_chain4(a: i64, b: i64, c: i64, d: i64) i64 {
    return a + b - c + d - a + b - c + d;
}
fn expr_bitnot(x: i64) i64 { return ~x; }
fn expr_shift_chain(x: i64) i64 { return ((x << 2) >> 1) << 1; }
fn expr_bitcombo(a: i64, b: i64) i64 { return (a & b) | (a ^ b); }
fn expr_max(a: i64, b: i64) i64 { if a > b { return a; } return b; }
fn expr_min(a: i64, b: i64) i64 { if a < b { return a; } return b; }
fn expr_abs(x: i64) i64 { if x < 0 { return -x; } return x; }
fn expr_sign(x: i64) i64 {
    if x < 0 { return -1; }
    if x > 0 { return 1; }
    return 0;
}
fn expr_clamp(x: i64, lo: i64, hi: i64) i64 {
    if x < lo { return lo; }
    if x > hi { return hi; }
    return x;
}
fn expr_power(base: i64, exp: i64) i64 {
    var result: i64 = 1;
    var i: i64 = 0;
    while i < exp {
        result = result * base;
        i = i + 1;
    }
    return result;
}
fn expr_square(x: i64) i64 { return x * x; }
fn expr_cube(x: i64) i64 { return x * x * x; }
fn expr_sum_squares(n: i64) i64 {
    var sum: i64 = 0;
    var i: i64 = 1;
    while i <= n {
        sum = sum + i * i;
        i = i + 1;
    }
    return sum;
}
fn expr_avg(a: i64, b: i64, c: i64) i64 { return (a + b + c) / 3; }
fn expr_tri_area(base: i64, height: i64) i64 { return (base * height) / 2; }
fn expr_rect_area(w: i64, h: i64) i64 { return w * h; }
fn expr_distance(x1: i64, y1: i64, x2: i64, y2: i64) i64 {
    return expr_abs(x2 - x1) + expr_abs(y2 - y1);
}
fn expr_dot(x1: i64, y1: i64, x2: i64, y2: i64) i64 {
    return x1 * x2 + y1 * y2;
}
fn expr_cross(x1: i64, y1: i64, x2: i64, y2: i64) i64 {
    return x1 * y2 - y1 * x2;
}
fn expr_lerp(a: i64, b: i64, t: i64) i64 {
    return a + (b - a) * t / 100;
}
fn expr_popcount(n: i64) i64 {
    var count: i64 = 0;
    var x: i64 = n;
    while x != 0 {
        count = count + (x & 1);
        x = x >> 1;
    }
    return count;
}
fn expr_reverse8(n: i64) i64 {
    var result: i64 = 0;
    var x: i64 = n;
    var i: i64 = 0;
    while i < 8 {
        result = result << 1;
        result = result | (x & 1);
        x = x >> 1;
        i = i + 1;
    }
    return result;
}
fn expr_is_pow2(n: i64) i64 {
    if n <= 0 { return 0; }
    if (n & (n - 1)) == 0 { return 1; }
    return 0;
}
fn expr_neg_div(a: i64, b: i64) i64 { return (-a) / b; }
fn expr_div_neg(a: i64, b: i64) i64 { return a / (-b); }
fn expr_neg_mod(a: i64, b: i64) i64 { return (-a) % b; }
fn expr_double_neg(x: i64) i64 { return -(-x); }
fn expr_triple_neg(x: i64) i64 { return -(-(-x)); }
fn expr_in_range(x: i64, lo: i64, hi: i64) i64 {
    if x >= lo {
        if x <= hi { return 1; }
    }
    return 0;
}
fn expr_is_zero(x: i64) i64 { if x == 0 { return 1; } return 0; }
fn expr_is_neg(x: i64) i64 { if x < 0 { return 1; } return 0; }
fn expr_align_up(n: i64, align: i64) i64 {
    return (n + align - 1) & (0 - align);
}
fn expr_extract_byte(x: i64, pos: i64) i64 {
    return (x >> (pos * 8)) & 0xFF;
}
fn expr_count_bits(n: i64) i64 {
    var count: i64 = 0;
    var x: i64 = n;
    while x > 0 {
        count = count + (x & 1);
        x = x >> 1;
    }
    return count;
}
fn expr_clz_byte(x: i64) i64 {
    var count: i64 = 0;
    var mask: i64 = 0x80;
    while mask > 0 {
        if (x & mask) != 0 {
            return count;
        }
        count = count + 1;
        mask = mask >> 1;
    }
    return 8;
}

// === Test functions ===

// 001: Simple addition
fn test_expr_001() i64 {
    if expr_add(40, 2) != 42 { return 1; }
    return 0;
}

// 002: Simple subtraction
fn test_expr_002() i64 {
    if expr_sub(50, 8) != 42 { return 1; }
    return 0;
}

// 003: Multiplication
fn test_expr_003() i64 {
    if expr_mul(6, 7) != 42 { return 1; }
    return 0;
}

// 004: Division
fn test_expr_004() i64 {
    if expr_div(84, 2) != 42 { return 1; }
    return 0;
}

// 005: Complex expression
fn test_expr_005() i64 {
    if expr_calc(3, 4, 6) != 42 { return 1; }
    return 0;
}

// 006: Nested function calls
fn test_expr_006() i64 {
    if expr_outer(20) != 41 { return 1; }
    return 0;
}

// 007: Modulo
fn test_expr_007() i64 {
    if expr_mod(17, 5) != 2 { return 1; }
    return 0;
}

// 008: Negation
fn test_expr_008() i64 {
    if expr_neg(42) != -42 { return 1; }
    return 0;
}

// 009: Bitwise AND
fn test_expr_009() i64 {
    if expr_bitand(0xFF, 0x0F) != 0x0F { return 1; }
    return 0;
}

// 010: Bitwise OR
fn test_expr_010() i64 {
    if expr_bitor(0xF0, 0x0F) != 0xFF { return 1; }
    return 0;
}

// 011: Bitwise XOR
fn test_expr_011() i64 {
    if expr_bitxor(0xFF, 0x0F) != 0xF0 { return 1; }
    return 0;
}

// 012: Shift left
fn test_expr_012() i64 {
    if expr_shl(1, 4) != 16 { return 1; }
    return 0;
}

// 013: Shift right
fn test_expr_013() i64 {
    if expr_shr(256, 4) != 16 { return 1; }
    return 0;
}

// 014: Compare less than
fn test_expr_014() i64 {
    if expr_lt(5, 10) != 1 { return 1; }
    return 0;
}

// 015: Compare less equal
fn test_expr_015() i64 {
    if expr_le(5, 5) != 1 { return 1; }
    return 0;
}

// 016: Compare greater than
fn test_expr_016() i64 {
    if expr_gt(10, 5) != 1 { return 1; }
    return 0;
}

// 017: Compare greater equal
fn test_expr_017() i64 {
    if expr_ge(5, 5) != 1 { return 1; }
    return 0;
}

// 018: Compare equal
fn test_expr_018() i64 {
    if expr_eq(42, 42) != 1 { return 1; }
    return 0;
}

// 019: Compare not equal
fn test_expr_019() i64 {
    if expr_ne(1, 2) != 1 { return 1; }
    return 0;
}

// 020: Chained addition
fn test_expr_020() i64 {
    if expr_chain(1, 2, 3) != 12 { return 1; }
    return 0;
}

// 021: Parenthesized expression
fn test_expr_021() i64 {
    if expr_calc(2, 3, 4) != 20 { return 1; }
    return 0;
}

// 022: Operator precedence
fn test_expr_022() i64 {
    if expr_prec() != 14 { return 1; }
    return 0;
}

// 023: Left associativity
fn test_expr_023() i64 {
    if expr_left_assoc() != 50 { return 1; }
    return 0;
}

// 024: Mixed operators
fn test_expr_024() i64 {
    if expr_mixed() != 65 { return 1; }
    return 0;
}

// 025: Div and mod combined
fn test_expr_025() i64 {
    if expr_div_mod(17, 5) != 5 { return 1; }
    return 0;
}

// 026: Long chain
fn test_expr_026() i64 {
    if expr_chain4(1, 2, 3, 4) != 6 { return 1; }
    return 0;
}

// 027: Bitwise NOT
fn test_expr_027() i64 {
    if (expr_bitnot(0) & 0xFF) != 0xFF { return 1; }
    return 0;
}

// 028: Shift chain
fn test_expr_028() i64 {
    if expr_shift_chain(1) != 4 { return 1; }
    return 0;
}

// 029: Bit combo
fn test_expr_029() i64 {
    if expr_bitcombo(0xF0, 0x0F) != 0xFF { return 1; }
    return 0;
}

// 030: Arithmetic with assignment
fn test_expr_030() i64 {
    var x: i64 = 10;
    x = x + 5;
    x = x * 2;
    x = x - 10;
    if x != 20 { return 1; }
    return 0;
}

// 031: Negation arithmetic
fn test_expr_031() i64 {
    if -10 + 20 != 10 { return 1; }
    return 0;
}

// 032: Zero comparison
fn test_expr_032() i64 {
    if expr_is_zero(0) != 1 { return 1; }
    return 0;
}

// 033: Negative comparison
fn test_expr_033() i64 {
    if expr_is_neg(-5) != 1 { return 1; }
    return 0;
}

// 034: Multi comparison (in range)
fn test_expr_034() i64 {
    if expr_in_range(5, 1, 10) != 1 { return 1; }
    return 0;
}

// 035: Max
fn test_expr_035() i64 {
    if expr_max(3, 7) != 7 { return 1; }
    return 0;
}

// 036: Min
fn test_expr_036() i64 {
    if expr_min(3, 7) != 3 { return 1; }
    return 0;
}

// 037: Abs
fn test_expr_037() i64 {
    if expr_abs(-42) != 42 { return 1; }
    return 0;
}

// 038: Sign
fn test_expr_038() i64 {
    if expr_sign(-10) != -1 { return 1; }
    return 0;
}

// 039: Clamp
fn test_expr_039() i64 {
    if expr_clamp(50, 0, 10) != 10 { return 1; }
    return 0;
}

// 040: Power
fn test_expr_040() i64 {
    if expr_power(2, 10) != 1024 { return 1; }
    return 0;
}

// 041: Square
fn test_expr_041() i64 {
    if expr_square(7) != 49 { return 1; }
    return 0;
}

// 042: Cube
fn test_expr_042() i64 {
    if expr_cube(4) != 64 { return 1; }
    return 0;
}

// 043: Sum of squares
fn test_expr_043() i64 {
    if expr_sum_squares(5) != 55 { return 1; }
    return 0;
}

// 044: Average
fn test_expr_044() i64 {
    if expr_avg(10, 20, 30) != 20 { return 1; }
    return 0;
}

// 045: Triangle area
fn test_expr_045() i64 {
    if expr_tri_area(10, 8) != 40 { return 1; }
    return 0;
}

// 046: Rectangle area
fn test_expr_046() i64 {
    if expr_rect_area(5, 7) != 35 { return 1; }
    return 0;
}

// 047: Manhattan distance
fn test_expr_047() i64 {
    if expr_distance(1, 2, 4, 6) != 7 { return 1; }
    return 0;
}

// 048: Dot product
fn test_expr_048() i64 {
    if expr_dot(2, 3, 4, 5) != 23 { return 1; }
    return 0;
}

// 049: Cross product
fn test_expr_049() i64 {
    if expr_cross(2, 3, 4, 5) != -2 { return 1; }
    return 0;
}

// 050: Lerp
fn test_expr_050() i64 {
    if expr_lerp(0, 100, 50) != 50 { return 1; }
    return 0;
}

// 051: Large constant
fn test_expr_051() i64 {
    if 1000000000 != 1000000000 { return 1; }
    return 0;
}

// 052: Negative constant
fn test_expr_052() i64 {
    if -123456 != -123456 { return 1; }
    return 0;
}

// 053: Hex constant
fn test_expr_053() i64 {
    var x: i64 = 0xDEADBEEF;
    if x != 0xDEADBEEF { return 1; }
    return 0;
}

// 054: Zero
fn test_expr_054() i64 {
    if 0 != 0 { return 1; }
    return 0;
}

// 055: One
fn test_expr_055() i64 {
    if 1 != 1 { return 1; }
    return 0;
}

// 056: Multiply then add
fn test_expr_056() i64 {
    if 3 * 4 + 5 != 17 { return 1; }
    return 0;
}

// 057: Divide then subtract
fn test_expr_057() i64 {
    if 100 / 10 - 5 != 5 { return 1; }
    return 0;
}

// 058: Nested parentheses
fn test_expr_058() i64 {
    if ((1 + 2) * (3 + 4)) != 21 { return 1; }
    return 0;
}

// 059: Sum of squares (direct)
fn test_expr_059() i64 {
    if (3 * 3) + (4 * 4) + (5 * 5) != 50 { return 1; }
    return 0;
}

// 060: All arithmetic ops
fn test_expr_060() i64 {
    var sum: i64 = 20 + 4;
    var diff: i64 = 20 - 4;
    var prod: i64 = 20 * 4;
    var quot: i64 = 20 / 4;
    if sum + diff + prod + quot != 125 { return 1; }
    return 0;
}

// 061: Bitwise combo
fn test_expr_061() i64 {
    if ((0xAA & 0x55) ^ (0xAA | 0x55)) != 0xFF { return 1; }
    return 0;
}

// 062: Mask extract byte
fn test_expr_062() i64 {
    if expr_extract_byte(0x12345678, 1) != 0x56 { return 1; }
    return 0;
}

// 063: Population count
fn test_expr_063() i64 {
    if expr_popcount(0xFF) != 8 { return 1; }
    return 0;
}

// 064: Reverse bits
fn test_expr_064() i64 {
    if expr_reverse8(0xB0) != 0x0D { return 1; }
    return 0;
}

// 065: Is power of 2
fn test_expr_065() i64 {
    if expr_is_pow2(64) != 1 { return 1; }
    return 0;
}

// 066: Negative division
fn test_expr_066() i64 {
    if expr_neg_div(20, 4) != -5 { return 1; }
    return 0;
}

// 067: Division by negative
fn test_expr_067() i64 {
    if expr_div_neg(20, 4) != -5 { return 1; }
    return 0;
}

// 068: Negative modulo
fn test_expr_068() i64 {
    if expr_neg_mod(17, 5) != -2 { return 1; }
    return 0;
}

// 069: Double negation
fn test_expr_069() i64 {
    if expr_double_neg(42) != 42 { return 1; }
    return 0;
}

// 070: Triple negation
fn test_expr_070() i64 {
    if expr_triple_neg(42) != -42 { return 1; }
    return 0;
}

// 071: Bitwise NOT twice
fn test_expr_071() i64 {
    var x: i64 = 42;
    if ~(~x) != 42 { return 1; }
    return 0;
}

// 072: Large shift
fn test_expr_072() i64 {
    if (1 << 32) != 0x100000000 { return 1; }
    return 0;
}

// 073: Shift by zero
fn test_expr_073() i64 {
    if (42 << 0) != 42 { return 1; }
    return 0;
}

// 074: Complex shift
fn test_expr_074() i64 {
    if (((0x0A << 4) | (0xB0 >> 4)) & 0xFF) != 0xAB { return 1; }
    return 0;
}

// 075: Overflow add (wraps to negative)
fn test_expr_075() i64 {
    var big: i64 = 0x7FFFFFFFFFFFFFFF;
    var result: i64 = big + 1;
    if result >= 0 { return 1; }
    return 0;
}

// 076: Division edge case
fn test_expr_076() i64 {
    var x: i64 = 100;
    var y: i64 = 7;
    var q: i64 = x / y;
    var r: i64 = x % y;
    if q != 14 { return 1; }
    if r != 2 { return 1; }
    return 0;
}

// 077: Negative division
fn test_expr_077() i64 {
    var x: i64 = 0 - 100;
    var y: i64 = 7;
    var q: i64 = x / y;
    if q != 0 - 14 { return 1; }
    return 0;
}

// 078: Chain add
fn test_expr_078() i64 {
    var r: i64 = 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10;
    if r != 55 { return 1; }
    return 0;
}

// 079: Chain multiply
fn test_expr_079() i64 {
    var r: i64 = 1 * 2 * 3 * 4 * 5;
    if r != 120 { return 1; }
    return 0;
}

// 080: Mixed chain
fn test_expr_080() i64 {
    var r: i64 = 10 + 20 * 2 - 30 / 3;
    if r != 40 { return 1; }
    return 0;
}

// 081: Parentheses
fn test_expr_081() i64 {
    var r: i64 = (10 + 20) * 2;
    if r != 60 { return 1; }
    return 0;
}

// 082: Nested parentheses
fn test_expr_082() i64 {
    var r: i64 = ((1 + 2) * (3 + 4)) * 2;
    if r != 42 { return 1; }
    return 0;
}

// 083: Bit AND
fn test_expr_083() i64 {
    var a: i64 = 0x0F;
    var b: i64 = 0x0A;
    if (a & b) != 0x0A { return 1; }
    return 0;
}

// 084: Bit OR
fn test_expr_084() i64 {
    var a: i64 = 0x0C;
    var b: i64 = 0x03;
    if (a | b) != 0x0F { return 1; }
    return 0;
}

// 085: Bit XOR
fn test_expr_085() i64 {
    var a: i64 = 0x0F;
    var b: i64 = 0x0A;
    if (a ^ b) != 0x05 { return 1; }
    return 0;
}

// 086: Large numbers
fn test_expr_086() i64 {
    var x: i64 = 1000000000;
    var y: i64 = 2000000000;
    if x + y != 3000000000 { return 1; }
    return 0;
}

// 087: Very large numbers
fn test_expr_087() i64 {
    var x: i64 = 4000000000000;
    var y: i64 = 5000000000000;
    if x + y != 9000000000000 { return 1; }
    return 0;
}

// 088: Max i64
fn test_expr_088() i64 {
    var max: i64 = 9223372036854775807;
    var one: i64 = 1;
    if max <= max - one { return 1; }
    return 0;
}

// 089: Min i64
fn test_expr_089() i64 {
    var min: i64 = 0 - 9223372036854775807 - 1;
    var one: i64 = 1;
    if min >= min + one { return 1; }
    return 0;
}

// 090: Hex literals
fn test_expr_090() i64 {
    var x: i64 = 0xFF;
    var y: i64 = 0x100;
    if x + 1 != y { return 1; }
    return 0;
}

// 091: Shift left
fn test_expr_091() i64 {
    var x: i64 = 1;
    if (x << 4) != 16 { return 1; }
    return 0;
}

// 092: Shift right
fn test_expr_092() i64 {
    var x: i64 = 256;
    if (x >> 4) != 16 { return 1; }
    return 0;
}

// 093: Shift both
fn test_expr_093() i64 {
    var x: i64 = 8;
    if (x << 2) != 32 { return 1; }
    if (x >> 2) != 2 { return 1; }
    return 0;
}

// 094: Bit ops combined
fn test_expr_094() i64 {
    var a: i64 = 0x0C;
    var b: i64 = 0x0A;
    var c: i64 = (a & b) | (a ^ b);
    if c != 0x0E { return 1; }
    return 0;
}

// 095: Power of two check (fixed from broken original)
fn test_expr_095() i64 {
    var n: i64 = 32;
    if (n & (n - 1)) != 0 { return 1; }
    return 0;
}

// 096: Mask low bits
fn test_expr_096() i64 {
    var x: i64 = 0xFF;
    var mask: i64 = 0x0F;
    if (x & mask) != 0x0F { return 1; }
    return 0;
}

// 097: Set bit
fn test_expr_097() i64 {
    var x: i64 = 0;
    var bit: i64 = 3;
    x = x | (1 << bit);
    if x != 8 { return 1; }
    return 0;
}

// 098: Clear bit
fn test_expr_098() i64 {
    var x: i64 = 0x0F;
    var bit: i64 = 2;
    x = x & (0 - 1 - (1 << bit));
    if x != 0x0B { return 1; }
    return 0;
}

// 099: Toggle bit
fn test_expr_099() i64 {
    var x: i64 = 0x0A;
    var bit: i64 = 1;
    x = x ^ (1 << bit);
    if x != 0x08 { return 1; }
    return 0;
}

// 100: Count bits
fn test_expr_100() i64 {
    if expr_count_bits(0xEA) != 5 { return 1; }
    return 0;
}

// 101: Precedence
fn test_expr_101() i64 {
    var r: i64 = 2 + 3 * 4;
    if r != 14 { return 1; }
    return 0;
}

// 102: Precedence 2
fn test_expr_102() i64 {
    var r: i64 = 20 / 4 + 3 * 2;
    if r != 11 { return 1; }
    return 0;
}

// 103: Compare chain (fixed from broken original)
fn test_expr_103() i64 {
    var a: i64 = 5;
    var b: i64 = 10;
    var c: i64 = 15;
    var r1: i64 = 0;
    var r2: i64 = 0;
    var r3: i64 = 0;
    if a < b { r1 = 1; }
    if b < c { r2 = 1; }
    if a < c { r3 = 1; }
    if r1 != 1 { return 1; }
    if r2 != 1 { return 1; }
    if r3 != 1 { return 1; }
    return 0;
}

// 104: Complex condition (fixed from broken original)
fn test_expr_104() i64 {
    var x: i64 = 50;
    if x < 0 { return 1; }
    if x > 100 { return 1; }
    return 0;
}

// 105: Zero compare (fixed from broken original)
fn test_expr_105() i64 {
    var x: i64 = 0;
    if x != 0 { return 1; }
    if x < 0 { return 1; }
    if x > 0 { return 1; }
    return 0;
}

// 106: Unary minus
fn test_expr_106() i64 {
    var x: i64 = 42;
    var y: i64 = 0 - x;
    if y != 0 - 42 { return 1; }
    return 0;
}

// 107: Double negation (via subtraction)
fn test_expr_107() i64 {
    var x: i64 = 42;
    var y: i64 = 0 - (0 - x);
    if y != 42 { return 1; }
    return 0;
}

// 108: Triple multiply
fn test_expr_108() i64 {
    var a: i64 = 2;
    var b: i64 = 3;
    var c: i64 = 4;
    if a * b * c != 24 { return 1; }
    return 0;
}

// 109: Quad add
fn test_expr_109() i64 {
    if 10 + 20 + 30 + 40 != 100 { return 1; }
    return 0;
}

// 110: Mixed ops
fn test_expr_110() i64 {
    if 100 - 50 + 25 - 10 + 5 != 70 { return 1; }
    return 0;
}

// 111: Shift as multiply
fn test_expr_111() i64 {
    var x: i64 = 5;
    if (x << 3) != 40 { return 1; }
    return 0;
}

// 112: Shift as divide
fn test_expr_112() i64 {
    var x: i64 = 64;
    if (x >> 3) != 8 { return 1; }
    return 0;
}

// 113: Align up
fn test_expr_113() i64 {
    if expr_align_up(13, 8) != 16 { return 1; }
    return 0;
}

// 114: Complex shift
fn test_expr_114() i64 {
    var x: i64 = 1;
    var y: i64 = x << 10;
    var z: i64 = y >> 5;
    if z != 32 { return 1; }
    return 0;
}

// 115: Bit extract
fn test_expr_115() i64 {
    if expr_extract_byte(0x12345678, 0) != 0x78 { return 1; }
    return 0;
}

// 116: Rotate bits
fn test_expr_116() i64 {
    var x: i64 = 0xF0;
    var left: i64 = (x << 4) & 0xFF;
    var right: i64 = (x >> 4) & 0xFF;
    if left != 0 { return 1; }
    if right != 0x0F { return 1; }
    return 0;
}

// 117: Swap bytes
fn test_expr_117() i64 {
    var x: i64 = 0x1234;
    var lo: i64 = x & 0xFF;
    var hi: i64 = (x >> 8) & 0xFF;
    var swapped: i64 = (lo << 8) | hi;
    if swapped != 0x3412 { return 1; }
    return 0;
}

// 118: Count leading zeros (byte)
fn test_expr_118() i64 {
    if expr_clz_byte(0x20) != 2 { return 1; }
    return 0;
}

// 119: Zero checks (fixed from broken original)
fn test_expr_119() i64 {
    var x: i64 = 0;
    if x != 0 { return 1; }
    return 0;
}

// 120: Negative compare (fixed from broken original)
fn test_expr_120() i64 {
    var neg: i64 = 0 - 10;
    var pos: i64 = 10;
    if neg >= 0 { return 1; }
    if neg >= pos { return 1; }
    if pos <= 0 { return 1; }
    return 0;
}

// 121: Power of three
fn test_expr_121() i64 {
    if 3 * 3 * 3 * 3 != 81 { return 1; }
    return 0;
}

// 122: Sum of products
fn test_expr_122() i64 {
    if 2 * 3 + 4 * 5 + 6 * 7 != 68 { return 1; }
    return 0;
}

// 123: Nested mod
fn test_expr_123() i64 {
    if 100 % 30 % 7 != 3 { return 1; }
    return 0;
}

// 124: Division chain
fn test_expr_124() i64 {
    if 1000 / 10 / 5 / 2 != 10 { return 1; }
    return 0;
}

// 125: Mixed arithmetic
fn test_expr_125() i64 {
    if (10 + 5) * 3 - 20 / 4 != 40 { return 1; }
    return 0;
}

// 126: Compare chain (fixed from broken original)
fn test_expr_126() i64 {
    var a: i64 = 5;
    var b: i64 = 10;
    var c: i64 = 15;
    var result: i64 = 0;
    if a < b {
        if b < c {
            result = 1;
        }
    }
    if result != 1 { return 1; }
    return 0;
}

// 127: Equality chain (fixed from broken original)
fn test_expr_127() i64 {
    var a: i64 = 5;
    var b: i64 = 5;
    var c: i64 = 5;
    var result: i64 = 0;
    if a == b {
        if b == c {
            result = 1;
        }
    }
    if result != 1 { return 1; }
    return 0;
}

// 128: Negative division
fn test_expr_128() i64 {
    if (0 - 20) / 4 != 0 - 5 { return 1; }
    return 0;
}

// 129: Negative modulo
fn test_expr_129() i64 {
    if (0 - 17) % 5 != 0 - 2 { return 1; }
    return 0;
}

// 130: Abs (both positive and negative)
fn test_expr_130() i64 {
    if expr_abs(0 - 42) != 42 { return 1; }
    if expr_abs(42) != 42 { return 1; }
    return 0;
}

// 131: Bitwise AND
fn test_expr_131() i64 {
    if (15 & 9) != 9 { return 1; }
    return 0;
}

// 132: Bitwise OR
fn test_expr_132() i64 {
    if (12 | 10) != 14 { return 1; }
    return 0;
}

// 133: Bitwise XOR
fn test_expr_133() i64 {
    if (12 ^ 10) != 6 { return 1; }
    return 0;
}

// 134: Left shift
fn test_expr_134() i64 {
    if (5 << 3) != 40 { return 1; }
    return 0;
}

// 135: Right shift
fn test_expr_135() i64 {
    if (64 >> 3) != 8 { return 1; }
    return 0;
}

// 136: Combined shift
fn test_expr_136() i64 {
    var x: i64 = 1;
    if (x << 4) + (x << 2) + (x << 1) != 22 { return 1; }
    return 0;
}

// 137: Mask
fn test_expr_137() i64 {
    if (255 & 15) != 15 { return 1; }
    return 0;
}

// 138: Set multiple bits
fn test_expr_138() i64 {
    var x: i64 = 0;
    x = x | (1 << 3);
    x = x | (1 << 5);
    if x != 40 { return 1; }
    return 0;
}

// 139: Clear bit
fn test_expr_139() i64 {
    var x: i64 = 255;
    x = x & (255 - 8);
    if x != 247 { return 1; }
    return 0;
}

// 140: Toggle bit
fn test_expr_140() i64 {
    var x: i64 = 5;
    x = x ^ 4;
    if x != 1 { return 1; }
    return 0;
}

// 141: Chained compare
fn test_expr_141() i64 {
    var a: i64 = 5;
    var b: i64 = 10;
    var c: i64 = 15;
    var r1: i64 = 0;
    var r2: i64 = 0;
    if a < b { r1 = 1; }
    if b < c { r2 = 1; }
    if r1 != 1 { return 1; }
    if r2 != 1 { return 1; }
    return 0;
}

// 142: Compound expression
fn test_expr_142() i64 {
    if (2 + 3) * (3 + 4) != 35 { return 1; }
    return 0;
}

// 143: Division by power
fn test_expr_143() i64 {
    if 256 / 4 / 4 / 4 != 4 { return 1; }
    return 0;
}

// 144: Mod chain
fn test_expr_144() i64 {
    var r1: i64 = 100 % 17;
    var r2: i64 = r1 % 5;
    if r2 != 0 { return 1; }
    return 0;
}

// 145: Arithmetic mix
fn test_expr_145() i64 {
    var a: i64 = 10;
    var b: i64 = 3;
    var sum: i64 = a + b;
    var diff: i64 = a - b;
    var prod: i64 = a * b;
    var quot: i64 = a / b;
    var rem: i64 = a % b;
    if sum + diff + prod + quot + rem != 54 { return 1; }
    return 0;
}

// 146: Nested paren
fn test_expr_146() i64 {
    var x: i64 = ((2 + 3) * (4 + 5)) - ((1 + 2) * (3 + 4));
    if x != 24 { return 1; }
    return 0;
}

// 147: Multi multiply
fn test_expr_147() i64 {
    if 2 * 3 * 4 * 5 != 120 { return 1; }
    return 0;
}

// 148: Multi add
fn test_expr_148() i64 {
    if 10 + 20 + 30 + 40 + 50 != 150 { return 1; }
    return 0;
}

// 149: Multi subtract
fn test_expr_149() i64 {
    if 100 - 10 - 20 - 30 != 40 { return 1; }
    return 0;
}

// 150: Associativity test
fn test_expr_150() i64 {
    var a: i64 = 100 - 50 - 25;
    var b: i64 = 100 - (50 - 25);
    if a != 25 { return 1; }
    if b != 75 { return 1; }
    return 0;
}

// 151: Square expression
fn test_expr_151() i64 {
    var x: i64 = 7;
    if x * x != 49 { return 1; }
    return 0;
}

// 152: Cube expression
fn test_expr_152() i64 {
    var x: i64 = 4;
    if x * x * x != 64 { return 1; }
    return 0;
}

// 153: Fourth power
fn test_expr_153() i64 {
    var x: i64 = 3;
    if x * x * x * x != 81 { return 1; }
    return 0;
}

// 154: Difference of squares
fn test_expr_154() i64 {
    var a: i64 = 10;
    var b: i64 = 6;
    if a * a - b * b != 64 { return 1; }
    return 0;
}

// 155: Sum of squares
fn test_expr_155() i64 {
    if 3 * 3 + 4 * 4 != 25 { return 1; }
    return 0;
}

// 156: Product
fn test_expr_156() i64 {
    if 2 * 3 * 7 != 42 { return 1; }
    return 0;
}

// 157: Quotient
fn test_expr_157() i64 {
    if 84 / 2 != 42 { return 1; }
    return 0;
}

// 158: Remainder
fn test_expr_158() i64 {
    if 47 % 5 != 2 { return 1; }
    return 0;
}

// 159: Complex arithmetic
fn test_expr_159() i64 {
    if 2 + 3 * 4 - 6 / 2 != 11 { return 1; }
    return 0;
}

// 160: Parenthesized priority
fn test_expr_160() i64 {
    var a: i64 = 2 + 3 * 4;
    var b: i64 = (2 + 3) * 4;
    if a != 14 { return 1; }
    if b != 20 { return 1; }
    return 0;
}

// === Main: run all tests, return failure count ===

fn main() i64 {
    var fails: i64 = 0;
    fails = fails + test_expr_001();
    fails = fails + test_expr_002();
    fails = fails + test_expr_003();
    fails = fails + test_expr_004();
    fails = fails + test_expr_005();
    fails = fails + test_expr_006();
    fails = fails + test_expr_007();
    fails = fails + test_expr_008();
    fails = fails + test_expr_009();
    fails = fails + test_expr_010();
    fails = fails + test_expr_011();
    fails = fails + test_expr_012();
    fails = fails + test_expr_013();
    fails = fails + test_expr_014();
    fails = fails + test_expr_015();
    fails = fails + test_expr_016();
    fails = fails + test_expr_017();
    fails = fails + test_expr_018();
    fails = fails + test_expr_019();
    fails = fails + test_expr_020();
    fails = fails + test_expr_021();
    fails = fails + test_expr_022();
    fails = fails + test_expr_023();
    fails = fails + test_expr_024();
    fails = fails + test_expr_025();
    fails = fails + test_expr_026();
    fails = fails + test_expr_027();
    fails = fails + test_expr_028();
    fails = fails + test_expr_029();
    fails = fails + test_expr_030();
    fails = fails + test_expr_031();
    fails = fails + test_expr_032();
    fails = fails + test_expr_033();
    fails = fails + test_expr_034();
    fails = fails + test_expr_035();
    fails = fails + test_expr_036();
    fails = fails + test_expr_037();
    fails = fails + test_expr_038();
    fails = fails + test_expr_039();
    fails = fails + test_expr_040();
    fails = fails + test_expr_041();
    fails = fails + test_expr_042();
    fails = fails + test_expr_043();
    fails = fails + test_expr_044();
    fails = fails + test_expr_045();
    fails = fails + test_expr_046();
    fails = fails + test_expr_047();
    fails = fails + test_expr_048();
    fails = fails + test_expr_049();
    fails = fails + test_expr_050();
    fails = fails + test_expr_051();
    fails = fails + test_expr_052();
    fails = fails + test_expr_053();
    fails = fails + test_expr_054();
    fails = fails + test_expr_055();
    fails = fails + test_expr_056();
    fails = fails + test_expr_057();
    fails = fails + test_expr_058();
    fails = fails + test_expr_059();
    fails = fails + test_expr_060();
    fails = fails + test_expr_061();
    fails = fails + test_expr_062();
    fails = fails + test_expr_063();
    fails = fails + test_expr_064();
    fails = fails + test_expr_065();
    fails = fails + test_expr_066();
    fails = fails + test_expr_067();
    fails = fails + test_expr_068();
    fails = fails + test_expr_069();
    fails = fails + test_expr_070();
    fails = fails + test_expr_071();
    fails = fails + test_expr_072();
    fails = fails + test_expr_073();
    fails = fails + test_expr_074();
    fails = fails + test_expr_075();
    fails = fails + test_expr_076();
    fails = fails + test_expr_077();
    fails = fails + test_expr_078();
    fails = fails + test_expr_079();
    fails = fails + test_expr_080();
    fails = fails + test_expr_081();
    fails = fails + test_expr_082();
    fails = fails + test_expr_083();
    fails = fails + test_expr_084();
    fails = fails + test_expr_085();
    fails = fails + test_expr_086();
    fails = fails + test_expr_087();
    fails = fails + test_expr_088();
    fails = fails + test_expr_089();
    fails = fails + test_expr_090();
    fails = fails + test_expr_091();
    fails = fails + test_expr_092();
    fails = fails + test_expr_093();
    fails = fails + test_expr_094();
    fails = fails + test_expr_095();
    fails = fails + test_expr_096();
    fails = fails + test_expr_097();
    fails = fails + test_expr_098();
    fails = fails + test_expr_099();
    fails = fails + test_expr_100();
    fails = fails + test_expr_101();
    fails = fails + test_expr_102();
    fails = fails + test_expr_103();
    fails = fails + test_expr_104();
    fails = fails + test_expr_105();
    fails = fails + test_expr_106();
    fails = fails + test_expr_107();
    fails = fails + test_expr_108();
    fails = fails + test_expr_109();
    fails = fails + test_expr_110();
    fails = fails + test_expr_111();
    fails = fails + test_expr_112();
    fails = fails + test_expr_113();
    fails = fails + test_expr_114();
    fails = fails + test_expr_115();
    fails = fails + test_expr_116();
    fails = fails + test_expr_117();
    fails = fails + test_expr_118();
    fails = fails + test_expr_119();
    fails = fails + test_expr_120();
    fails = fails + test_expr_121();
    fails = fails + test_expr_122();
    fails = fails + test_expr_123();
    fails = fails + test_expr_124();
    fails = fails + test_expr_125();
    fails = fails + test_expr_126();
    fails = fails + test_expr_127();
    fails = fails + test_expr_128();
    fails = fails + test_expr_129();
    fails = fails + test_expr_130();
    fails = fails + test_expr_131();
    fails = fails + test_expr_132();
    fails = fails + test_expr_133();
    fails = fails + test_expr_134();
    fails = fails + test_expr_135();
    fails = fails + test_expr_136();
    fails = fails + test_expr_137();
    fails = fails + test_expr_138();
    fails = fails + test_expr_139();
    fails = fails + test_expr_140();
    fails = fails + test_expr_141();
    fails = fails + test_expr_142();
    fails = fails + test_expr_143();
    fails = fails + test_expr_144();
    fails = fails + test_expr_145();
    fails = fails + test_expr_146();
    fails = fails + test_expr_147();
    fails = fails + test_expr_148();
    fails = fails + test_expr_149();
    fails = fails + test_expr_150();
    fails = fails + test_expr_151();
    fails = fails + test_expr_152();
    fails = fails + test_expr_153();
    fails = fails + test_expr_154();
    fails = fails + test_expr_155();
    fails = fails + test_expr_156();
    fails = fails + test_expr_157();
    fails = fails + test_expr_158();
    fails = fails + test_expr_159();
    fails = fails + test_expr_160();
    return fails;
}
