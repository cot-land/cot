// Parity tests for types - ported from bootstrap-0.2/test/parity/types/
// Skipped: 009,010,012,019,034,036,040,042,043,049,050,051,052,053,054,055,065 (extern/malloc)
// Skipped: 015,016 (global mutation in test format)

// === Struct definitions ===

struct Point { x: i64, y: i64 }
struct Pair { a: i64, b: i64 }
struct Inner { val: i64 }
struct Outer { inner: Inner, extra: i64 }
struct Triple { a: i64, b: i64, c: i64 }
struct Quad { a: i64, b: i64, c: i64, d: i64 }
struct Data5 { a: i64, b: i64, c: i64, d: i64, e: i64 }
struct Vec2 { x: i64, y: i64 }
struct Vec3 { x: i64, y: i64, z: i64 }
struct Rect { x: i64, y: i64, w: i64, h: i64 }
struct Line { start: Point, end: Point }
struct DataAB { a: i64, b: i64 }

const MAGIC: i64 = 42;
const WIDTH: i64 = 80;
const HEIGHT: i64 = 25;
const AREA: i64 = 2000;

// === Helper functions ===

fn ty01_test_locals() i64 {
    var a: i64 = 10;
    var b: i64 = 20;
    var c: i64 = a + b;
    return c;
}

fn ty02_test_reassign() i64 {
    var x: i64 = 5;
    x = x + 10;
    x = x * 2;
    return x;
}

fn ty03_to_bool(x: i64) i64 {
    if x != 0 { return 1; }
    return 0;
}

fn ty06_sum_pair(p: *Pair) i64 { return p.a + p.b; }
fn ty08_set_value(ptr: *i64, val: i64) void { ptr.* = val; }
fn ty11_make_pair(a: i64, b: i64, out: *Pair) void { out.a = a; out.b = b; }
fn ty18_get_value(p: *DataAB) i64 { return p.a; }
fn ty18_set_value(p: *DataAB, v: i64) void { p.a = v; }
fn ty20_make_vec(x: i64, y: i64, out: *Vec2) void { out.x = x; out.y = y; }
fn ty23_add_points(a: *Point, b: *Point, out: *Point) void { out.x = a.x + b.x; out.y = a.y + b.y; }
fn ty27_distance_sq(p: *Point) i64 { return p.x * p.x + p.y * p.y; }
fn ty28_translate(p: *Point, dx: i64, dy: i64) void { p.x = p.x + dx; p.y = p.y + dy; }
fn ty30_area(r: *Rect) i64 { return r.w * r.h; }
fn ty37_copy_point(src: *Point, dst: *Point) void { dst.x = src.x; dst.y = src.y; }
fn ty38_points_equal(a: *Point, b: *Point) i64 {
    if a.x == b.x and a.y == b.y { return 1; }
    return 0;
}
fn ty41_sum_triple(t: *Triple) i64 { return t.a + t.b + t.c; }
fn ty44_make_pair2(a: i64, b: i64, p: *Pair) void { p.a = a; p.b = b; }

// === Test functions ===

// ty_001: local vars
fn test_ty_001() i64 {
    if ty01_test_locals() != 30 { return 1; }
    return 0;
}

// ty_002: var reassign
fn test_ty_002() i64 {
    if ty02_test_reassign() != 30 { return 1; }
    return 0;
}

// ty_003: bool like
fn test_ty_003() i64 {
    if ty03_to_bool(42) != 1 { return 1; }
    return 0;
}

// ty_004: const
fn test_ty_004() i64 {
    if MAGIC != 42 { return 1; }
    return 0;
}

// ty_005: struct basic
fn test_ty_005() i64 {
    var p: Point = undefined;
    p.x = 10;
    p.y = 20;
    if p.x + p.y != 30 { return 1; }
    return 0;
}

// ty_006: struct pass
fn test_ty_006() i64 {
    var p: Pair = undefined;
    p.a = 5;
    p.b = 7;
    if ty06_sum_pair(&p) != 12 { return 1; }
    return 0;
}

// ty_007: nested struct
fn test_ty_007() i64 {
    var o: Outer = undefined;
    o.inner.val = 100;
    o.extra = 5;
    if o.inner.val + o.extra != 105 { return 1; }
    return 0;
}

// ty_008: ptr deref
fn test_ty_008() i64 {
    var x: i64 = 0;
    ty08_set_value(&x, 42);
    if x != 42 { return 1; }
    return 0;
}

// ty_011: struct return via out param
fn test_ty_011() i64 {
    var p: Pair = undefined;
    ty11_make_pair(10, 20, &p);
    if p.a + p.b != 30 { return 1; }
    return 0;
}

// ty_013: struct in struct (Rect with two Points)
fn test_ty_013() i64 {
    var r: Line = undefined;
    r.start.x = 10;
    r.start.y = 20;
    r.end.x = 100;
    r.end.y = 50;
    if r.start.x + r.end.x != 110 { return 1; }
    return 0;
}

// ty_014: multi field struct (5 fields)
fn test_ty_014() i64 {
    var d: Data5 = undefined;
    d.a = 1;
    d.b = 2;
    d.c = 3;
    d.d = 4;
    d.e = 5;
    if d.a + d.b + d.c + d.d + d.e != 15 { return 1; }
    return 0;
}

// ty_017: const expressions
fn test_ty_017() i64 {
    if WIDTH * HEIGHT != AREA { return 1; }
    return 0;
}

// ty_018: ptr to struct
fn test_ty_018() i64 {
    var d: DataAB = undefined;
    ty18_set_value(&d, 42);
    if ty18_get_value(&d) != 42 { return 1; }
    return 0;
}

// ty_020: struct init pattern
fn test_ty_020() i64 {
    var v: Vec2 = undefined;
    ty20_make_vec(3, 4, &v);
    var len_sq: i64 = v.x * v.x + v.y * v.y;
    if len_sq != 25 { return 1; }
    return 0;
}

// ty_021: three field struct
fn test_ty_021() i64 {
    var t: Triple = undefined;
    t.a = 1;
    t.b = 2;
    t.c = 3;
    if t.a + t.b + t.c != 6 { return 1; }
    return 0;
}

// ty_022: four field struct
fn test_ty_022() i64 {
    var q: Quad = undefined;
    q.a = 1;
    q.b = 2;
    q.c = 3;
    q.d = 4;
    if q.a * q.b * q.c * q.d != 24 { return 1; }
    return 0;
}

// ty_023: struct param (add two Points)
fn test_ty_023() i64 {
    var p1: Point = undefined;
    var p2: Point = undefined;
    var p3: Point = undefined;
    p1.x = 1;
    p1.y = 2;
    p2.x = 3;
    p2.y = 4;
    ty23_add_points(&p1, &p2, &p3);
    if p3.x + p3.y != 10 { return 1; }
    return 0;
}

// ty_024: struct init (basic)
fn test_ty_024() i64 {
    var p: Point = undefined;
    p.x = 10;
    p.y = 20;
    if p.x + p.y != 30 { return 1; }
    return 0;
}

// ty_025: struct ptr
fn test_ty_025() i64 {
    var p: Point = undefined;
    p.x = 5;
    p.y = 10;
    var ptr: *Point = &p;
    if ptr.x != 5 { return 1; }
    if ptr.y != 10 { return 1; }
    return 0;
}

// ty_026: struct modify via ptr
fn test_ty_026() i64 {
    var p: Point = undefined;
    p.x = 1;
    p.y = 2;
    var ptr: *Point = &p;
    ptr.x = 100;
    ptr.y = 200;
    if p.x != 100 { return 1; }
    if p.y != 200 { return 1; }
    return 0;
}

// ty_027: struct fn param (distance squared)
fn test_ty_027() i64 {
    var p: Point = undefined;
    p.x = 3;
    p.y = 4;
    if ty27_distance_sq(&p) != 25 { return 1; }
    return 0;
}

// ty_028: struct fn modify (translate)
fn test_ty_028() i64 {
    var p: Point = undefined;
    p.x = 10;
    p.y = 20;
    ty28_translate(&p, 5, 10);
    if p.x != 15 { return 1; }
    if p.y != 30 { return 1; }
    return 0;
}

// ty_029: struct 3 fields (Vec3)
fn test_ty_029() i64 {
    var v: Vec3 = undefined;
    v.x = 1;
    v.y = 2;
    v.z = 3;
    if v.x + v.y + v.z != 6 { return 1; }
    return 0;
}

// ty_030: struct 4 fields (Rect area)
fn test_ty_030() i64 {
    var r: Rect = undefined;
    r.x = 0;
    r.y = 0;
    r.w = 10;
    r.h = 5;
    if ty30_area(&r) != 50 { return 1; }
    return 0;
}

// ty_031: ptr to ptr
fn test_ty_031() i64 {
    var x: i64 = 42;
    var p: *i64 = &x;
    var pp: **i64 = &p;
    if pp.*.* != 42 { return 1; }
    return 0;
}

// ty_032: ptr to ptr modify
fn test_ty_032() i64 {
    var x: i64 = 10;
    var p: *i64 = &x;
    var pp: **i64 = &p;
    pp.*.* = 100;
    if x != 100 { return 1; }
    return 0;
}

// ty_033: multi struct (Line with two Points)
fn test_ty_033() i64 {
    var l: Line = undefined;
    l.start.x = 0;
    l.start.y = 0;
    l.end.x = 10;
    l.end.y = 10;
    var dx: i64 = l.end.x - l.start.x;
    var dy: i64 = l.end.y - l.start.y;
    if dx != 10 { return 1; }
    if dy != 10 { return 1; }
    return 0;
}

// ty_035: struct 5 fields
fn test_ty_035() i64 {
    var d: Data5 = undefined;
    d.a = 1;
    d.b = 2;
    d.c = 3;
    d.d = 4;
    d.e = 5;
    if d.a + d.b + d.c + d.d + d.e != 15 { return 1; }
    return 0;
}

// ty_037: struct copy
fn test_ty_037() i64 {
    var p1: Point = undefined;
    var p2: Point = undefined;
    p1.x = 10;
    p1.y = 20;
    ty37_copy_point(&p1, &p2);
    if p2.x != 10 { return 1; }
    if p2.y != 20 { return 1; }
    return 0;
}

// ty_038: struct compare
fn test_ty_038() i64 {
    var p1: Point = undefined;
    var p2: Point = undefined;
    p1.x = 5;
    p1.y = 10;
    p2.x = 5;
    p2.y = 10;
    if ty38_points_equal(&p1, &p2) != 1 { return 1; }
    return 0;
}

// ty_039: nested field access
fn test_ty_039() i64 {
    var o: Outer = undefined;
    o.inner.val = 42;
    o.extra = 10;
    if o.inner.val != 42 { return 1; }
    if o.extra != 10 { return 1; }
    return 0;
}

// ty_041: struct sum
fn test_ty_041() i64 {
    var t: Triple = undefined;
    t.a = 10;
    t.b = 20;
    t.c = 30;
    if ty41_sum_triple(&t) != 60 { return 1; }
    return 0;
}

// ty_044: tuple like
fn test_ty_044() i64 {
    var p: Pair = undefined;
    ty44_make_pair2(10, 20, &p);
    if p.a != 10 { return 1; }
    if p.b != 20 { return 1; }
    return 0;
}

// ty_045: triple struct ops
fn test_ty_045() i64 {
    var t: Triple = undefined;
    t.a = 1;
    t.b = 2;
    t.c = 3;
    var sum: i64 = t.a + t.b + t.c;
    var prod: i64 = t.a * t.b * t.c;
    if sum != 6 { return 1; }
    if prod != 6 { return 1; }
    return 0;
}

// ty_046: i64 max value
fn test_ty_046() i64 {
    var max: i64 = 9223372036854775807;
    if max <= 0 { return 1; }
    return 0;
}

// ty_047: i64 large multiply
fn test_ty_047() i64 {
    var big: i64 = 1000000000;
    var result: i64 = big * big;
    if result != 1000000000000000000 { return 1; }
    return 0;
}

// ty_048: bool as int
fn test_ty_048() i64 {
    var b: i64 = 5;
    if b <= 3 { return 1; }
    return 0;
}

// ty_056: compare neq
fn test_ty_056() i64 {
    var a: i64 = 5;
    var b: i64 = 10;
    if a == b { return 1; }
    return 0;
}

// ty_057: compare lt
fn test_ty_057() i64 {
    var a: i64 = 5;
    var b: i64 = 10;
    if a >= b { return 1; }
    return 0;
}

// ty_058: compare gt
fn test_ty_058() i64 {
    var a: i64 = 10;
    var b: i64 = 5;
    if a <= b { return 1; }
    return 0;
}

// ty_059: compare lte
fn test_ty_059() i64 {
    var a: i64 = 5;
    var b: i64 = 5;
    if a > b { return 1; }
    return 0;
}

// ty_060: compare gte
fn test_ty_060() i64 {
    var a: i64 = 5;
    var b: i64 = 5;
    if a < b { return 1; }
    return 0;
}

// ty_061: negative literal
fn test_ty_061() i64 {
    var x: i64 = 0 - 42;
    if x != 0 - 42 { return 1; }
    return 0;
}

// ty_062: zero compare
fn test_ty_062() i64 {
    var x: i64 = 0;
    if x != 0 { return 1; }
    return 0;
}

// ty_063: one compare
fn test_ty_063() i64 {
    var x: i64 = 1;
    if x != 1 { return 1; }
    return 0;
}

// ty_064: bool convert (comparison stores to var)
fn test_ty_064() i64 {
    var a: i64 = 5;
    var b: i64 = 3;
    if a <= b { return 1; }
    return 0;
}

// === Main ===

fn main() i64 {
    var failures: i64 = 0;
    failures = failures + test_ty_001();
    failures = failures + test_ty_002();
    failures = failures + test_ty_003();
    failures = failures + test_ty_004();
    failures = failures + test_ty_005();
    failures = failures + test_ty_006();
    failures = failures + test_ty_007();
    failures = failures + test_ty_008();
    failures = failures + test_ty_011();
    failures = failures + test_ty_013();
    failures = failures + test_ty_014();
    failures = failures + test_ty_017();
    failures = failures + test_ty_018();
    failures = failures + test_ty_020();
    failures = failures + test_ty_021();
    failures = failures + test_ty_022();
    failures = failures + test_ty_023();
    failures = failures + test_ty_024();
    failures = failures + test_ty_025();
    failures = failures + test_ty_026();
    failures = failures + test_ty_027();
    failures = failures + test_ty_028();
    failures = failures + test_ty_029();
    failures = failures + test_ty_030();
    failures = failures + test_ty_031();
    failures = failures + test_ty_032();
    failures = failures + test_ty_033();
    failures = failures + test_ty_035();
    failures = failures + test_ty_037();
    failures = failures + test_ty_038();
    failures = failures + test_ty_039();
    failures = failures + test_ty_041();
    failures = failures + test_ty_044();
    failures = failures + test_ty_045();
    failures = failures + test_ty_046();
    failures = failures + test_ty_047();
    failures = failures + test_ty_048();
    failures = failures + test_ty_056();
    failures = failures + test_ty_057();
    failures = failures + test_ty_058();
    failures = failures + test_ty_059();
    failures = failures + test_ty_060();
    failures = failures + test_ty_061();
    failures = failures + test_ty_062();
    failures = failures + test_ty_063();
    failures = failures + test_ty_064();
    return failures;
}
