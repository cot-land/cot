// E2E tests: Functions (107 tests)
// Ported from bootstrap-0.2
// Skipped: 011,012 (global mutation), 036,037,050,051,052,082 (extern/ptr)

// === Helper functions (prefixed to avoid collisions) ===

fn fn01_get42() i64 { return 42; }
fn fn02_sum5(a: i64, b: i64, c: i64, d: i64, e: i64) i64 { return a + b + c + d + e; }
fn fn03_fib(n: i64) i64 {
    if n <= 1 { return n; }
    return fn03_fib(n - 1) + fn03_fib(n - 2);
}
fn fn04_is_odd(n: i64) i64 {
    if n == 0 { return 0; }
    return fn04_is_even(n - 1);
}
fn fn04_is_even(n: i64) i64 {
    if n == 0 { return 1; }
    return fn04_is_odd(n - 1);
}
fn fn05_sum6(a: i64, b: i64, c: i64, d: i64, e: i64, f: i64) i64 {
    return a + b + c + d + e + f;
}
fn fn06_sum7(a: i64, b: i64, c: i64, d: i64, e: i64, f: i64, g: i64) i64 {
    return a + b + c + d + e + f + g;
}
fn fn07_sum8(a: i64, b: i64, c: i64, d: i64, e: i64, f: i64, g: i64, h: i64) i64 {
    return a + b + c + d + e + f + g + h;
}
fn fn08_double(x: i64) i64 { return x * 2; }
fn fn08_triple(x: i64) i64 { return x * 3; }
fn fn08_apply_both(x: i64) i64 { return fn08_double(fn08_triple(x)); }
fn fn09_factorial(n: i64) i64 {
    if n <= 1 { return 1; }
    return n * fn09_factorial(n - 1);
}
fn fn10_square(x: i64) i64 { return x * x; }
fn fn13_f1(x: i64) i64 { return x + 1; }
fn fn13_f2(x: i64) i64 { return fn13_f1(x) + 1; }
fn fn13_f3(x: i64) i64 { return fn13_f2(x) + 1; }
fn fn13_f4(x: i64) i64 { return fn13_f3(x) + 1; }
fn fn14_double(x: i64) i64 { return x * 2; }
fn fn15_add(a: i64, b: i64) i64 { return a + b; }
fn fn15_triple(x: i64) i64 { return x * 3; }
fn fn16_inc(x: i64) i64 { return x + 1; }
fn fn17_collatz_steps(n: i64) i64 {
    var steps: i64 = 0;
    var x: i64 = n;
    while x != 1 {
        if (x % 2) == 0 { x = x / 2; }
        else { x = x * 3 + 1; }
        steps = steps + 1;
    }
    return steps;
}
fn fn18_is_prime(n: i64) i64 {
    if n < 2 { return 0; }
    var i: i64 = 2;
    while i * i <= n {
        if (n % i) == 0 { return 0; }
        i = i + 1;
    }
    return 1;
}
fn fn19_count_primes(n: i64) i64 {
    var count: i64 = 0;
    var i: i64 = 2;
    while i <= n {
        if fn18_is_prime(i) != 0 { count = count + 1; }
        i = i + 1;
    }
    return count;
}
fn fn20_fib(n: i64) i64 {
    if n <= 1 { return n; }
    var a: i64 = 0;
    var b: i64 = 1;
    var i: i64 = 2;
    while i <= n {
        var t: i64 = a + b;
        a = b;
        b = t;
        i = i + 1;
    }
    return b;
}
fn fn21_triangle(n: i64) i64 { return n * (n + 1) / 2; }
fn fn22_double(x: i64) i64 { return x * 2; }
fn fn22_apply_twice(x: i64) i64 { return fn22_double(fn22_double(x)); }
fn fn23_add5(x: i64) i64 { return x + 5; }
fn fn23_mul2(x: i64) i64 { return x * 2; }
fn fn23_compose(x: i64) i64 { return fn23_mul2(fn23_add5(x)); }
fn fn24_ack(m: i64, n: i64) i64 {
    if m == 0 { return n + 1; }
    if n == 0 { return fn24_ack(m - 1, 1); }
    return fn24_ack(m - 1, fn24_ack(m, n - 1));
}
fn fn25_sum_range(a: i64, b: i64) i64 {
    var sum: i64 = 0;
    var i: i64 = a;
    while i <= b {
        sum = sum + i;
        i = i + 1;
    }
    return sum;
}
fn fn26_identity(x: i64) i64 { return x; }
fn fn27_swap_sub(a: i64, b: i64) i64 { return b - a; }
fn fn28_ignore_second(a: i64, b: i64) i64 { return a; }
fn fn29_use_all(a: i64, b: i64, c: i64, d: i64) i64 { return ((a - b) * c) + d; }
fn fn30_f1(x: i64) i64 { return x + 1; }
fn fn30_f2(x: i64) i64 { return fn30_f1(x) + 1; }
fn fn30_f3(x: i64) i64 { return fn30_f2(x) + 1; }
fn fn30_f4(x: i64) i64 { return fn30_f3(x) + 1; }
fn fn30_f5(x: i64) i64 { return fn30_f4(x) + 1; }
fn fn31_a(x: i64) i64 { return fn31_b(x + 1); }
fn fn31_b(x: i64) i64 { return fn31_c(x + 1); }
fn fn31_c(x: i64) i64 { return fn31_d(x + 1); }
fn fn31_d(x: i64) i64 { return fn31_e(x + 1); }
fn fn31_e(x: i64) i64 { return fn31_f(x + 1); }
fn fn31_f(x: i64) i64 { return x; }
fn fn32_sum9(a: i64, b: i64, c: i64, d: i64, e: i64, f: i64, g: i64, h: i64, i: i64) i64 {
    return a + b + c + d + e + f + g + h + i;
}
fn fn33_countdown(n: i64) i64 {
    if n <= 0 { return 0; }
    return fn33_countdown(n - 1);
}
fn fn34_sum_rec(n: i64) i64 {
    if n <= 0 { return 0; }
    return n + fn34_sum_rec(n - 1);
}
fn fn35_mult_rec(a: i64, b: i64) i64 {
    if b <= 0 { return 0; }
    return a + fn35_mult_rec(a, b - 1);
}
fn fn38_add1(x: i64) i64 { return x + 1; }
fn fn38_nested3(x: i64) i64 { return fn38_add1(fn38_add1(fn38_add1(x))); }
fn fn39_double(x: i64) i64 { return x * 2; }
fn fn39_call_in_binop(a: i64, b: i64) i64 { return fn39_double(a) + fn39_double(b); }
fn fn40_add(a: i64, b: i64) i64 { return a + b; }
fn fn40_mul(a: i64, b: i64) i64 { return a * b; }
fn fn40_call_in_call(x: i64) i64 { return fn40_add(fn40_mul(x, 2), fn40_mul(x, 3)); }
fn fn41_inc(x: i64) i64 { return x + 1; }
fn fn41_add(a: i64, b: i64) i64 { return a + b; }
fn fn41_both_args(x: i64, y: i64) i64 { return fn41_add(fn41_inc(x), fn41_inc(y)); }
fn fn42_rec_sum(a: i64, b: i64, c: i64) i64 {
    if a <= 0 { return c; }
    return fn42_rec_sum(a - 1, b, c + b);
}
fn fn43_ping(n: i64) i64 {
    if n <= 0 { return 0; }
    return fn43_pong(n - 1) + 1;
}
fn fn43_pong(n: i64) i64 {
    if n <= 0 { return 0; }
    return fn43_ping(n - 1) + 1;
}
fn fn46_double(x: i64) i64 { return x * 2; }
fn fn46_triple(x: i64) i64 { return x * 3; }
fn fn46_quadruple(x: i64) i64 { return x * 4; }
fn fn47_add(a: i64, b: i64) i64 { return a + b; }
fn fn47_mul(a: i64, b: i64) i64 { return a * b; }
fn fn48_is_even(x: i64) i64 { if x % 2 == 0 { return 1; } return 0; }
fn fn49_square(x: i64) i64 { return x * x; }
fn fn53_add(a: i64, b: i64) i64 { return a + b; }
fn fn54_adder(base: i64, x: i64) i64 { return base + x; }
fn fn55_double(x: i64) i64 { return x * 2; }
fn fn56_square(x: i64) i64 { return x * x; }
fn fn57_fib_iter(n: i64) i64 {
    if n <= 1 { return n; }
    var a: i64 = 0;
    var b: i64 = 1;
    var i: i64 = 2;
    while i <= n {
        var tmp: i64 = a + b;
        a = b;
        b = tmp;
        i = i + 1;
    }
    return b;
}
fn fn58_fact_iter(n: i64) i64 {
    var result: i64 = 1;
    var i: i64 = 2;
    while i <= n {
        result = result * i;
        i = i + 1;
    }
    return result;
}
fn fn59_power(base: i64, exp: i64) i64 {
    var result: i64 = 1;
    var i: i64 = 0;
    while i < exp { result = result * base; i = i + 1; }
    return result;
}
fn fn60_is_prime(n: i64) i64 {
    if n <= 1 { return 0; }
    if n <= 3 { return 1; }
    if n % 2 == 0 { return 0; }
    var i: i64 = 3;
    while i * i <= n { if n % i == 0 { return 0; } i = i + 2; }
    return 1;
}
fn fn61_collatz_steps(n: i64) i64 {
    var steps: i64 = 0;
    var x: i64 = n;
    while x > 1 {
        if x % 2 == 0 { x = x / 2; } else { x = 3 * x + 1; }
        steps = steps + 1;
    }
    return steps;
}
fn fn62_digit_sum(n: i64) i64 {
    var sum: i64 = 0;
    var x: i64 = n;
    while x > 0 { sum = sum + (x % 10); x = x / 10; }
    return sum;
}
fn fn63_reverse_num(n: i64) i64 {
    var rev: i64 = 0;
    var x: i64 = n;
    while x > 0 { rev = rev * 10 + (x % 10); x = x / 10; }
    return rev;
}
fn fn64_count_digits(n: i64) i64 {
    if n == 0 { return 1; }
    var count: i64 = 0;
    var x: i64 = n;
    while x > 0 { count = count + 1; x = x / 10; }
    return count;
}
fn fn65_min(a: i64, b: i64) i64 { if a < b { return a; } return b; }
fn fn65_max(a: i64, b: i64) i64 { if a > b { return a; } return b; }
fn fn66_clamp(x: i64, lo: i64, hi: i64) i64 {
    if x < lo { return lo; }
    if x > hi { return hi; }
    return x;
}
fn fn67_abs(x: i64) i64 { if x < 0 { return 0 - x; } return x; }
fn fn68_sign(x: i64) i64 {
    if x < 0 { return 0 - 1; }
    if x > 0 { return 1; }
    return 0;
}
fn fn69_gcd(a: i64, b: i64) i64 {
    var x: i64 = a;
    var y: i64 = b;
    while y > 0 { var t: i64 = y; y = x % y; x = t; }
    return x;
}
fn fn70_lcm(a: i64, b: i64) i64 { return (a / fn69_gcd(a, b)) * b; }
fn fn71_sum_of_squares(n: i64) i64 {
    var sum: i64 = 0;
    var i: i64 = 1;
    while i <= n { sum = sum + i * i; i = i + 1; }
    return sum;
}
fn fn72_sum_of_cubes(n: i64) i64 {
    var sum: i64 = 0;
    var i: i64 = 1;
    while i <= n { sum = sum + i * i * i; i = i + 1; }
    return sum;
}
fn fn73_nth_prime(n: i64) i64 {
    var count: i64 = 0;
    var num: i64 = 2;
    while count < n {
        if fn60_is_prime(num) == 1 {
            count = count + 1;
            if count == n { return num; }
        }
        num = num + 1;
    }
    return num;
}
fn fn74_triangular(n: i64) i64 { return n * (n + 1) / 2; }
fn fn75_is_perfect_square(n: i64) i64 {
    var i: i64 = 1;
    while i * i <= n { if i * i == n { return 1; } i = i + 1; }
    return 0;
}
fn fn76_isqrt(n: i64) i64 {
    var x: i64 = n;
    var y: i64 = (x + 1) / 2;
    while y < x { x = y; y = (x + n / x) / 2; }
    return x;
}
fn fn77_count_divisors(n: i64) i64 {
    var count: i64 = 0;
    var i: i64 = 1;
    while i <= n { if n % i == 0 { count = count + 1; } i = i + 1; }
    return count;
}
fn fn78_sum_divisors(n: i64) i64 {
    var sum: i64 = 0;
    var i: i64 = 1;
    while i <= n { if n % i == 0 { sum = sum + i; } i = i + 1; }
    return sum;
}
fn fn79_fast_pow(base: i64, exp: i64) i64 {
    var result: i64 = 1;
    var b: i64 = base;
    var e: i64 = exp;
    while e > 0 {
        if e % 2 == 1 { result = result * b; }
        e = e / 2;
        b = b * b;
    }
    return result;
}
fn fn80_mod_pow(base: i64, exp: i64, m: i64) i64 {
    var result: i64 = 1;
    var b: i64 = base % m;
    var e: i64 = exp;
    while e > 0 {
        if e % 2 == 1 { result = (result * b) % m; }
        e = e / 2;
        b = (b * b) % m;
    }
    return result;
}
fn fn83_count_down(n: i64) i64 {
    if n <= 0 { return 0; }
    return fn83_count_down(n - 1) + 1;
}
fn fn84_sum_to(n: i64) i64 {
    if n <= 0 { return 0; }
    return n + fn84_sum_to(n - 1);
}
fn fn85_factorial(n: i64) i64 {
    if n <= 1 { return 1; }
    return n * fn85_factorial(n - 1);
}
fn fn86_is_odd(n: i64) i64 {
    if n == 0 { return 0; }
    return fn86_is_even(n - 1);
}
fn fn86_is_even(n: i64) i64 {
    if n == 0 { return 1; }
    return fn86_is_odd(n - 1);
}
fn fn87_collatz_rec(n: i64) i64 {
    if n == 1 { return 0; }
    if n % 2 == 0 { return 1 + fn87_collatz_rec(n / 2); }
    return 1 + fn87_collatz_rec(3 * n + 1);
}
fn fn88_digit_sum(n: i64) i64 {
    var x: i64 = n;
    if x < 0 { x = 0 - x; }
    if x < 10 { return x; }
    return x % 10 + fn88_digit_sum(x / 10);
}
fn fn89_count_digits(n: i64) i64 {
    var x: i64 = n;
    if x < 0 { x = 0 - x; }
    if x < 10 { return 1; }
    return 1 + fn89_count_digits(x / 10);
}
fn fn90_reverse_helper(n: i64, acc: i64) i64 {
    if n == 0 { return acc; }
    return fn90_reverse_helper(n / 10, acc * 10 + n % 10);
}
fn fn91_is_palindrome(n: i64) i64 {
    if n < 0 { return 0; }
    if fn90_reverse_helper(n, 0) == n { return 1; }
    return 0;
}
fn fn92_is_power_of_two(n: i64) i64 {
    if n <= 0 { return 0; }
    if n == 1 { return 1; }
    if n % 2 != 0 { return 0; }
    return fn92_is_power_of_two(n / 2);
}
fn fn93_log2_floor(n: i64) i64 {
    if n < 1 { return 0 - 1; }
    if n == 1 { return 0; }
    return 1 + fn93_log2_floor(n / 2);
}
fn fn94_sum_to_n(n: i64) i64 {
    if n <= 0 { return 0; }
    return n + fn94_sum_to_n(n - 1);
}
fn fn95_sum_squares(n: i64) i64 {
    if n <= 0 { return 0; }
    return n * n + fn95_sum_squares(n - 1);
}
fn fn96_power(base: i64, exp: i64) i64 {
    if exp == 0 { return 1; }
    return base * fn96_power(base, exp - 1);
}
fn fn97_power_iter(base: i64, exp: i64) i64 {
    var result: i64 = 1;
    var i: i64 = 0;
    while i < exp { result = result * base; i = i + 1; }
    return result;
}
fn fn98_factorial_iter(n: i64) i64 {
    var result: i64 = 1;
    var i: i64 = 2;
    while i <= n { result = result * i; i = i + 1; }
    return result;
}
fn fn99_triangle(n: i64) i64 { return n * (n + 1) / 2; }
fn fn100_square(n: i64) i64 { return n * n; }
fn fn101_cube(n: i64) i64 { return n * n * n; }
fn fn102_sum_cubes(n: i64) i64 {
    var sum: i64 = 0;
    var i: i64 = 1;
    while i <= n { sum = sum + i * i * i; i = i + 1; }
    return sum;
}
fn fn103_double(n: i64) i64 { return n + n; }
fn fn104_half(n: i64) i64 { return n / 2; }
fn fn105_negate(n: i64) i64 { return 0 - n; }
fn fn106_inc(n: i64) i64 { return n + 1; }
fn fn107_dec(n: i64) i64 { return n - 1; }
fn fn108_is_zero(n: i64) i64 { if n == 0 { return 1; } return 0; }
fn fn109_is_positive(n: i64) i64 { if n > 0 { return 1; } return 0; }
fn fn110_is_negative(n: i64) i64 { if n < 0 { return 1; } return 0; }
fn fn111_clamp(x: i64, lo: i64, hi: i64) i64 {
    if x < lo { return lo; }
    if x > hi { return hi; }
    return x;
}
fn fn112_lerp(a: i64, b: i64, t: i64) i64 { return a + (b - a) * t / 100; }
fn fn113_avg(a: i64, b: i64) i64 { return (a + b) / 2; }
fn fn114_abs(x: i64) i64 { if x < 0 { return 0 - x; } return x; }
fn fn114_distance(a: i64, b: i64) i64 { return fn114_abs(a - b); }
fn fn115_inc(n: i64) i64 { return n + 1; }
fn fn115_double(n: i64) i64 { return n * 2; }
fn fn115_square(n: i64) i64 { return n * n; }

// === Tests ===

test "001: return constant" {
    @assert_eq(fn01_get42(), 42)
}

test "002: five param sum" {
    @assert_eq(fn02_sum5(1, 2, 3, 4, 5), 15)
}

test "003: recursive fibonacci" {
    @assert_eq(fn03_fib(10), 55)
}

test "004: mutual recursion even" {
    @assert_eq(fn04_is_even(10), 1)
}

test "005: six param sum" {
    @assert_eq(fn05_sum6(1, 2, 3, 4, 5, 6), 21)
}

test "006: seven param sum" {
    @assert_eq(fn06_sum7(1, 2, 3, 4, 5, 6, 7), 28)
}

test "007: eight param sum" {
    @assert_eq(fn07_sum8(1, 2, 3, 4, 5, 6, 7, 8), 36)
}

test "008: nested call composition" {
    @assert_eq(fn08_apply_both(5), 30)
}

test "009: recursive factorial" {
    @assert_eq(fn09_factorial(5), 120)
}

test "010: pythagorean sum squares" {
    @assert_eq(fn10_square(3) + fn10_square(4), 25)
}

// 011: skipped (global mutation)
// 012: skipped (global mutation)

test "013: four-deep chain" {
    @assert_eq(fn13_f4(0), 4)
}

test "014: double greater than" {
    @assert(fn14_double(5) > 8)
}

test "015: call in args" {
    @assert_eq(fn15_add(fn15_triple(2), fn15_triple(3)), 15)
}

test "016: sequential increment" {
    var a: i64 = fn16_inc(0);
    var b: i64 = fn16_inc(a);
    var c: i64 = fn16_inc(b);
    var d: i64 = fn16_inc(c);
    var e: i64 = fn16_inc(d);
    @assert_eq(e, 5)
}

test "017: collatz steps" {
    @assert_eq(fn17_collatz_steps(6), 8)
}

test "018: primality test" {
    @assert_eq(fn18_is_prime(17), 1)
}

test "019: count primes" {
    @assert_eq(fn19_count_primes(20), 8)
}

test "020: iterative fibonacci" {
    @assert_eq(fn20_fib(10), 55)
}

test "021: triangle number" {
    @assert_eq(fn21_triangle(10), 55)
}

test "022: double applied twice" {
    @assert_eq(fn22_apply_twice(5), 20)
}

test "023: function composition" {
    @assert_eq(fn23_compose(10), 30)
}

test "024: ackermann function" {
    @assert_eq(fn24_ack(2, 3), 9)
}

test "025: sum range" {
    @assert_eq(fn25_sum_range(5, 10), 45)
}

test "026: identity function" {
    @assert_eq(fn26_identity(42), 42)
}

test "027: swap subtraction" {
    @assert_eq(fn27_swap_sub(3, 10), 7)
}

test "028: ignore second arg" {
    @assert_eq(fn28_ignore_second(42, 999), 42)
}

test "029: use all four args" {
    @assert_eq(fn29_use_all(10, 3, 4, 5), 33)
}

test "030: five-deep chain" {
    @assert_eq(fn30_f5(0), 5)
}

test "031: six-call chain" {
    @assert_eq(fn31_a(0), 5)
}

test "032: nine param sum" {
    @assert_eq(fn32_sum9(1, 2, 3, 4, 5, 6, 7, 8, 9), 45)
}

test "033: recursive countdown" {
    @assert_eq(fn33_countdown(100), 0)
}

test "034: recursive sum" {
    @assert_eq(fn34_sum_rec(10), 55)
}

test "035: recursive multiply" {
    @assert_eq(fn35_mult_rec(7, 6), 42)
}

// 036: skipped (extern/ptr)
// 037: skipped (extern/ptr)

test "038: triple nested call" {
    @assert_eq(fn38_nested3(0), 3)
}

test "039: call in binop" {
    @assert_eq(fn39_call_in_binop(3, 4), 14)
}

test "040: call in call args" {
    @assert_eq(fn40_call_in_call(5), 25)
}

test "041: both args calls" {
    @assert_eq(fn41_both_args(5, 10), 17)
}

test "042: recursive accumulator" {
    @assert_eq(fn42_rec_sum(5, 3, 0), 15)
}

test "043: mutual ping pong" {
    @assert_eq(fn43_ping(10), 10)
}

test "044: six param sum again" {
    @assert_eq(fn05_sum6(1, 2, 3, 4, 5, 6), 21)
}

test "045: eight param sum again" {
    @assert_eq(fn07_sum8(1, 2, 3, 4, 5, 6, 7, 8), 36)
}

test "046: triple composition" {
    @assert_eq(fn46_quadruple(fn46_triple(fn46_double(5))), 120)
}

test "047: nested mul add" {
    @assert_eq(fn47_add(fn47_mul(2, 3), fn47_mul(4, 5)), 26)
}

test "048: is even check" {
    @assert_eq(fn48_is_even(4), 1)
    @assert_eq(fn48_is_even(7), 0)
}

test "049: loop with call" {
    var sum: i64 = 0;
    var i: i64 = 1;
    while i <= 5 { sum = sum + fn49_square(i); i = i + 1; }
    @assert_eq(sum, 55)
}

// 050: skipped (extern/ptr)
// 051: skipped (extern/ptr)
// 052: skipped (extern/ptr)

test "053: chained add calls" {
    @assert_eq(fn53_add(fn53_add(fn53_add(1, 2), 3), 4), 10)
}

test "054: adder with base" {
    var b: i64 = 100;
    @assert_eq(fn54_adder(b, 1), 101)
    @assert_eq(fn54_adder(b, 2), 102)
    @assert_eq(fn54_adder(b, 3), 103)
}

test "055: double sum" {
    @assert_eq(fn55_double(5) + fn55_double(10), 30)
}

test "056: square ordering" {
    @assert(fn56_square(3) < fn56_square(4))
}

test "057: fib iterative" {
    @assert_eq(fn57_fib_iter(10), 55)
}

test "058: factorial iterative" {
    @assert_eq(fn58_fact_iter(6), 720)
}

test "059: power function" {
    @assert_eq(fn59_power(2, 10), 1024)
}

test "060: is prime multi" {
    @assert_eq(fn60_is_prime(2), 1)
    @assert_eq(fn60_is_prime(17), 1)
    @assert_eq(fn60_is_prime(18), 0)
    @assert_eq(fn60_is_prime(97), 1)
}

test "061: collatz steps 27" {
    @assert_eq(fn61_collatz_steps(27), 111)
}

test "062: digit sum" {
    @assert_eq(fn62_digit_sum(12345), 15)
}

test "063: reverse number" {
    @assert_eq(fn63_reverse_num(12345), 54321)
}

test "064: count digits" {
    @assert_eq(fn64_count_digits(0), 1)
    @assert_eq(fn64_count_digits(12345), 5)
    @assert_eq(fn64_count_digits(1000000), 7)
}

test "065: min and max" {
    @assert_eq(fn65_min(5, 10), 5)
    @assert_eq(fn65_max(5, 10), 10)
}

test "066: clamp function" {
    @assert_eq(fn66_clamp(5, 0, 10), 5)
    @assert_eq(fn66_clamp(0 - 5, 0, 10), 0)
    @assert_eq(fn66_clamp(15, 0, 10), 10)
}

test "067: absolute value" {
    @assert_eq(fn67_abs(5), 5)
    @assert_eq(fn67_abs(0 - 5), 5)
    @assert_eq(fn67_abs(0), 0)
}

test "068: sign function" {
    @assert_eq(fn68_sign(42), 1)
    @assert_eq(fn68_sign(0 - 42), 0 - 1)
    @assert_eq(fn68_sign(0), 0)
}

test "069: gcd" {
    @assert_eq(fn69_gcd(48, 18), 6)
}

test "070: lcm" {
    @assert_eq(fn70_lcm(12, 18), 36)
}

test "071: sum of squares" {
    @assert_eq(fn71_sum_of_squares(10), 385)
}

test "072: sum of cubes" {
    @assert_eq(fn72_sum_of_cubes(10), 3025)
}

test "073: nth prime" {
    @assert_eq(fn73_nth_prime(10), 29)
}

test "074: triangular number" {
    @assert_eq(fn74_triangular(100), 5050)
}

test "075: perfect square check" {
    @assert_eq(fn75_is_perfect_square(16), 1)
    @assert_eq(fn75_is_perfect_square(17), 0)
    @assert_eq(fn75_is_perfect_square(100), 1)
}

test "076: integer sqrt" {
    @assert_eq(fn76_isqrt(100), 10)
}

test "077: count divisors" {
    @assert_eq(fn77_count_divisors(12), 6)
}

test "078: sum divisors" {
    @assert_eq(fn78_sum_divisors(12), 28)
}

test "079: fast power" {
    @assert_eq(fn79_fast_pow(2, 10), 1024)
}

test "080: modular power" {
    @assert_eq(fn80_mod_pow(2, 10, 1000), 24)
}

test "081: gcd larger values" {
    @assert_eq(fn69_gcd(252, 105), 21)
    @assert_eq(fn69_gcd(1071, 462), 21)
}

// 082: skipped (extern/ptr)

test "083: recursive countdown" {
    @assert_eq(fn83_count_down(100), 100)
}

test "084: recursive sum to" {
    @assert_eq(fn84_sum_to(10), 55)
}

test "085: recursive factorial 10" {
    @assert_eq(fn85_factorial(10), 3628800)
}

test "086: mutual even odd" {
    @assert_eq(fn86_is_even(10), 1)
    @assert_eq(fn86_is_odd(7), 1)
}

test "087: collatz recursive" {
    @assert_eq(fn87_collatz_rec(6), 8)
}

test "088: recursive digit sum" {
    @assert_eq(fn88_digit_sum(12345), 15)
}

test "089: recursive count digits" {
    @assert_eq(fn89_count_digits(12345), 5)
    @assert_eq(fn89_count_digits(7), 1)
}

test "090: reverse helper" {
    @assert_eq(fn90_reverse_helper(12345, 0), 54321)
}

test "091: palindrome check" {
    @assert_eq(fn91_is_palindrome(12321), 1)
    @assert_eq(fn91_is_palindrome(12345), 0)
}

test "092: power of two" {
    @assert_eq(fn92_is_power_of_two(16), 1)
    @assert_eq(fn92_is_power_of_two(15), 0)
}

test "093: log2 floor" {
    @assert_eq(fn93_log2_floor(16), 4)
    @assert_eq(fn93_log2_floor(15), 3)
}

test "094: recursive sum to n" {
    @assert_eq(fn94_sum_to_n(10), 55)
}

test "095: recursive sum squares" {
    @assert_eq(fn95_sum_squares(5), 55)
}

test "096: recursive power" {
    @assert_eq(fn96_power(2, 10), 1024)
}

test "097: iterative power" {
    @assert_eq(fn97_power_iter(3, 5), 243)
}

test "098: iterative factorial" {
    @assert_eq(fn98_factorial_iter(6), 720)
}

test "099: triangle number" {
    @assert_eq(fn99_triangle(10), 55)
}

test "100: square function" {
    @assert_eq(fn100_square(12), 144)
}

test "101: cube function" {
    @assert_eq(fn101_cube(5), 125)
}

test "102: sum cubes iter" {
    @assert_eq(fn102_sum_cubes(4), 100)
}

test "103: double by addition" {
    @assert_eq(fn103_double(21), 42)
}

test "104: half by division" {
    @assert_eq(fn104_half(84), 42)
}

test "105: negate value" {
    @assert_eq(fn105_negate(42), 0 - 42)
}

test "106: increment" {
    @assert_eq(fn106_inc(41), 42)
}

test "107: decrement" {
    @assert_eq(fn107_dec(43), 42)
}

test "108: is zero check" {
    @assert_eq(fn108_is_zero(0), 1)
    @assert_eq(fn108_is_zero(5), 0)
}

test "109: is positive check" {
    @assert_eq(fn109_is_positive(5), 1)
    @assert_eq(fn109_is_positive(0 - 5), 0)
}

test "110: is negative check" {
    @assert_eq(fn110_is_negative(0 - 5), 1)
    @assert_eq(fn110_is_negative(5), 0)
}

test "111: clamp function" {
    @assert_eq(fn111_clamp(5, 0, 10), 5)
    @assert_eq(fn111_clamp(0 - 5, 0, 10), 0)
    @assert_eq(fn111_clamp(15, 0, 10), 10)
}

test "112: linear interpolation" {
    @assert_eq(fn112_lerp(0, 100, 50), 50)
}

test "113: average" {
    @assert_eq(fn113_avg(40, 44), 42)
}

test "114: distance function" {
    @assert_eq(fn114_distance(10, 52), 42)
}

test "115: chained transforms" {
    var x: i64 = fn115_inc(3);
    x = fn115_double(x);
    x = fn115_square(x);
    @assert_eq(x, 64)
}
