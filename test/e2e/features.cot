// Combined native E2E test program — inline test format.
// Each `test "name" { ... }` block runs independently.

// ============================================================================
// Shared type declarations
// ============================================================================

struct Foo { x: i64 }
struct Bar { y: i64 }
struct Point { x: i64, y: i64 }
type Coord = Point;

enum Color { Red, Green, Blue }
enum Status { Ok = 0, Warning = 50, Error = 100 }
enum Level { Low = 10, Medium = 50, High = 100 }

union State { Init, Running, Done }
union Result { Ok: i64, Err: i32 }
union Event { Click: i64, Hover, KeyPress: i64 }

const MyError = error { Fail, NotFound }

// DFoo: Foo variant with deinit (deinit tests need Foo_deinit but ARC tests must NOT have it)
struct DFoo { x: i64 }
fn DFoo_deinit(self: *DFoo) void { return }

// ============================================================================
// Shared helper functions
// ============================================================================

fn double(x: i64) i64 { return x + x }

fn createFoo(val: i64) *Foo {
    return new Foo { x: val }
}

fn makeFoo(v: i64) *Foo {
    return new Foo { x: v }
}

fn add(a: i64, b: i64) i64 { return a + b }

fn dbl(x: i64) i64 { return x * 2 }

fn apply_fn(f: fn(i64) -> i64, x: i64) i64 {
    return f(x)
}

fn inc(x: i64) i64 { return x + 1 }
fn dec(x: i64) i64 { return x - 1 }

fn mayFail(x: i64) MyError!i64 {
    if x < 0 { return error.Fail }
    return x * 2
}

fn inner() MyError!i64 {
    return error.Fail
}

fn outer() MyError!i64 {
    let x = try inner()
    return x + 1
}

fn createDFoo(val: i64) *DFoo {
    return new DFoo { x: val }
}

// ============================================================================
// Generic type declarations
// ============================================================================

struct Pair(T, U) { first: T, second: U }
struct Box(T) { value: T }
struct BoxC(T) { value: T, count: i64 }
struct Counter(T) { value: T }
struct CounterM(T) { value: T, count: i64 }

struct List(T) {
    items: i64,
    count: i64,
    capacity: i64,
}

// ============================================================================
// Generic helper functions (free function pattern)
// ============================================================================

fn max(T)(a: T, b: T) T {
    if a > b { return a }
    return b
}

fn generic_add(T)(a: T, b: T) T {
    return a + b
}

fn Box_getValue(T)(self: *Box(T)) T {
    return self.value
}

fn getSize(T)() i64 {
    return @sizeOf(T)
}

fn allocOne(T)(value: T) *T {
    let ptr = @intToPtr(*T, @alloc(@sizeOf(T)))
    ptr.* = value
    return ptr
}

fn CounterM_increment(T)(self: *CounterM(T)) void {
    self.count = self.count + 1
}

// List free functions
fn List_ensureCapacity(T)(self: *List(T), needed: i64) void {
    if self.capacity >= needed { return }
    var new_cap: i64 = 8
    if self.capacity > 0 { new_cap = self.capacity * 2 }
    let bytes = new_cap * @sizeOf(T)
    if self.capacity == 0 {
        self.items = @alloc(bytes)
    } else {
        self.items = @realloc(self.items, bytes)
    }
    self.capacity = new_cap
}

fn List_append(T)(self: *List(T), value: T) void {
    List_ensureCapacity(T)(self, self.count + 1)
    let ptr = @intToPtr(*T, self.items + self.count * @sizeOf(T))
    ptr.* = value
    self.count = self.count + 1
}

fn List_get(T)(self: *List(T), index: i64) T {
    let ptr = @intToPtr(*T, self.items + index * @sizeOf(T))
    return ptr.*
}

fn List_set(T)(self: *List(T), index: i64, value: T) void {
    let ptr = @intToPtr(*T, self.items + index * @sizeOf(T))
    ptr.* = value
}

fn List_pop(T)(self: *List(T)) T {
    self.count = self.count - 1
    let ptr = @intToPtr(*T, self.items + self.count * @sizeOf(T))
    return ptr.*
}

// ============================================================================
// Generic impl blocks
// ============================================================================

impl Counter(T) {
    fn get(self: *Counter(T)) T {
        return self.value
    }
}

impl BoxC(T) {
    fn getCount(self: *BoxC(T)) i64 {
        return self.count
    }
    fn increment(self: *BoxC(T)) void {
        self.count = self.getCount() + 1
    }
}

impl Box(T) {
    fn get(self: *Box(T)) T {
        return self.value
    }
}

impl Pair(T, U) {
    fn sum(self: *Pair(T, U)) i64 {
        return self.first + self.second
    }
}

impl List(T) {
    // Go's nextslicecap: 2x for small, ~1.25x for large
    fn ensureCapacity(self: *List(T), needed: i64) void {
        if self.capacity >= needed { return }
        var new_cap = self.capacity
        var double_cap = new_cap + new_cap
        if needed > double_cap {
            new_cap = needed
        } else if self.capacity < 256 {
            new_cap = double_cap
        } else {
            while new_cap < needed {
                new_cap = new_cap + (new_cap + 768) / 4
            }
        }
        if new_cap < 8 { new_cap = 8 }
        let bytes = new_cap * @sizeOf(T)
        if self.capacity == 0 {
            self.items = @alloc(bytes)
        } else {
            self.items = @realloc(self.items, bytes)
        }
        self.capacity = new_cap
    }

    fn append(self: *List(T), value: T) void {
        self.ensureCapacity(self.count + 1)
        let ptr = @intToPtr(*T, self.items + self.count * @sizeOf(T))
        ptr.* = value
        self.count = self.count + 1
    }

    fn get(self: *List(T), index: i64) T {
        if index < 0 { @trap() }
        if index >= self.count { @trap() }
        let ptr = @intToPtr(*T, self.items + index * @sizeOf(T))
        return ptr.*
    }

    fn set(self: *List(T), index: i64, value: T) void {
        if index < 0 { @trap() }
        if index >= self.count { @trap() }
        let ptr = @intToPtr(*T, self.items + index * @sizeOf(T))
        ptr.* = value
    }

    fn pop(self: *List(T)) T {
        if self.count == 0 { @trap() }
        self.count = self.count - 1
        let ptr = @intToPtr(*T, self.items + self.count * @sizeOf(T))
        return ptr.*
    }

    fn len(self: *List(T)) i64 { return self.count }
    fn cap(self: *List(T)) i64 { return self.capacity }

    fn last(self: *List(T)) T {
        if self.count == 0 { @trap() }
        let ptr = @intToPtr(*T, self.items + (self.count - 1) * @sizeOf(T))
        return ptr.*
    }

    fn free(self: *List(T)) void {
        if self.capacity > 0 {
            @dealloc(self.items)
        }
        self.items = 0
        self.count = 0
        self.capacity = 0
    }

    fn clear(self: *List(T)) void {
        self.count = 0
    }

    fn clearAndFree(self: *List(T)) void {
        self.free()
    }

    fn insert(self: *List(T), index: i64, value: T) void {
        if index < 0 { @trap() }
        if index > self.count { @trap() }
        self.ensureCapacity(self.count + 1)
        if index < self.count {
            let src = self.items + index * @sizeOf(T)
            let dst = src + @sizeOf(T)
            let bytes = (self.count - index) * @sizeOf(T)
            @memcpy(dst, src, bytes)
        }
        let ptr = @intToPtr(*T, self.items + index * @sizeOf(T))
        ptr.* = value
        self.count = self.count + 1
    }

    fn orderedRemove(self: *List(T), index: i64) T {
        if index < 0 { @trap() }
        if index >= self.count { @trap() }
        let ptr = @intToPtr(*T, self.items + index * @sizeOf(T))
        let value = ptr.*
        if index < self.count - 1 {
            let dst = self.items + index * @sizeOf(T)
            let src = dst + @sizeOf(T)
            let bytes = (self.count - index - 1) * @sizeOf(T)
            @memcpy(dst, src, bytes)
        }
        self.count = self.count - 1
        return value
    }

    fn swapRemove(self: *List(T), index: i64) T {
        if index < 0 { @trap() }
        if index >= self.count { @trap() }
        let ptr = @intToPtr(*T, self.items + index * @sizeOf(T))
        let value = ptr.*
        self.count = self.count - 1
        if index < self.count {
            let last_ptr = @intToPtr(*T, self.items + self.count * @sizeOf(T))
            ptr.* = last_ptr.*
        }
        return value
    }

    fn appendSlice(self: *List(T), source: i64, num: i64) void {
        self.ensureCapacity(self.count + num)
        let dst = self.items + self.count * @sizeOf(T)
        @memcpy(dst, source, num * @sizeOf(T))
        self.count = self.count + num
    }

    fn reverse(self: *List(T)) void {
        var i: i64 = 0
        var j: i64 = self.count - 1
        while i < j {
            let pi = @intToPtr(*T, self.items + i * @sizeOf(T))
            let pj = @intToPtr(*T, self.items + j * @sizeOf(T))
            let tmp = pi.*
            pi.* = pj.*
            pj.* = tmp
            i = i + 1
            j = j - 1
        }
    }

    fn clone(self: *List(T)) List(T) {
        var new_list: List(T) = .{}
        if self.count > 0 {
            let bytes = self.count * @sizeOf(T)
            new_list.items = @alloc(bytes)
            @memcpy(new_list.items, self.items, bytes)
            new_list.count = self.count
            new_list.capacity = self.count
        }
        return new_list
    }

    // --- Tier 1: Search / comparison ---

    // Go: slices.Index — linear scan, return first matching index or -1
    fn indexOf(self: *List(T), value: T) i64 {
        var i: i64 = 0
        while i < self.count {
            let ptr = @intToPtr(*T, self.items + i * @sizeOf(T))
            if ptr.* == value { return i }
            i = i + 1
        }
        return 0 - 1
    }

    // Go: slices.Contains — linear scan (inlined, not delegating to indexOf)
    fn contains(self: *List(T), value: T) i64 {
        var i: i64 = 0
        while i < self.count {
            let ptr = @intToPtr(*T, self.items + i * @sizeOf(T))
            if ptr.* == value { return 1 }
            i = i + 1
        }
        return 0
    }

    // Go: slices.Equal — element-wise comparison
    fn equal(self: *List(T), other: *List(T)) i64 {
        if self.count != other.count { return 0 }
        var i: i64 = 0
        while i < self.count {
            let pa = @intToPtr(*T, self.items + i * @sizeOf(T))
            let pb = @intToPtr(*T, other.items + i * @sizeOf(T))
            if pa.* != pb.* { return 0 }
            i = i + 1
        }
        return 1
    }

    // Go: s[0] — get first element, trap if empty
    fn first(self: *List(T)) T {
        if self.count == 0 { @trap() }
        let ptr = @intToPtr(*T, self.items)
        return ptr.*
    }

    // --- Tier 1: Resize / capacity ---

    // Zig: resize — set length, ensure capacity if growing. New elements are undefined.
    fn resize(self: *List(T), new_len: i64) void {
        if new_len < 0 { @trap() }
        if new_len > self.count {
            self.ensureCapacity(new_len)
        }
        self.count = new_len
    }

    // Zig: shrinkAndFree — reduce length and realloc to release excess memory
    fn shrinkAndFree(self: *List(T), new_len: i64) void {
        if new_len < 0 { @trap() }
        if new_len > self.count { @trap() }
        self.count = new_len
        if new_len == 0 {
            self.free()
        } else {
            let bytes = new_len * @sizeOf(T)
            self.items = @realloc(self.items, bytes)
            self.capacity = new_len
        }
    }

    // Zig: ensureUnusedCapacity — ensure N more elements fit
    fn ensureUnusedCapacity(self: *List(T), n: i64) void {
        self.ensureCapacity(self.count + n)
    }

    // --- Tier 1: Bulk write ---

    // Zig: appendNTimes — append value n times
    fn appendNTimes(self: *List(T), value: T, n: i64) void {
        self.ensureCapacity(self.count + n)
        var i: i64 = 0
        while i < n {
            let ptr = @intToPtr(*T, self.items + self.count * @sizeOf(T))
            ptr.* = value
            self.count = self.count + 1
            i = i + 1
        }
    }

    // Zig: insertSlice — shift right then copy block in
    fn insertSlice(self: *List(T), index: i64, source: i64, num: i64) void {
        if index < 0 { @trap() }
        if index > self.count { @trap() }
        if num <= 0 { return }
        self.ensureCapacity(self.count + num)
        if index < self.count {
            let src = self.items + index * @sizeOf(T)
            let dst = src + num * @sizeOf(T)
            let bytes = (self.count - index) * @sizeOf(T)
            @memcpy(dst, src, bytes)
        }
        let dst = self.items + index * @sizeOf(T)
        @memcpy(dst, source, num * @sizeOf(T))
        self.count = self.count + num
    }

    // Zig: replaceRange / Go: slices.Replace
    fn replaceRange(self: *List(T), start: i64, range_len: i64, source: i64, num: i64) void {
        if start < 0 { @trap() }
        if range_len < 0 { @trap() }
        if start + range_len > self.count { @trap() }
        let tail_start = start + range_len
        let tail_len = self.count - tail_start
        let new_count = self.count - range_len + num
        if num > range_len {
            // Growing: need more space, shift tail right
            self.ensureCapacity(new_count)
            if tail_len > 0 {
                let src = self.items + tail_start * @sizeOf(T)
                let dst = self.items + (start + num) * @sizeOf(T)
                let bytes = tail_len * @sizeOf(T)
                @memcpy(dst, src, bytes)
            }
        } else if num < range_len {
            // Shrinking: shift tail left
            if tail_len > 0 {
                let src = self.items + tail_start * @sizeOf(T)
                let dst = self.items + (start + num) * @sizeOf(T)
                let bytes = tail_len * @sizeOf(T)
                @memcpy(dst, src, bytes)
            }
        }
        // Copy new elements into place
        if num > 0 {
            let dst = self.items + start * @sizeOf(T)
            @memcpy(dst, source, num * @sizeOf(T))
        }
        self.count = new_count
    }

    // --- Tier 2 ---

    // Go: slices.Delete(s, i, j) — remove range [start, end), preserve order
    fn deleteRange(self: *List(T), start: i64, end: i64) void {
        if start < 0 { @trap() }
        if end > self.count { @trap() }
        if start > end { @trap() }
        let removed = end - start
        if removed == 0 { return }
        if end < self.count {
            let src = self.items + end * @sizeOf(T)
            let dst = self.items + start * @sizeOf(T)
            let bytes = (self.count - end) * @sizeOf(T)
            @memcpy(dst, src, bytes)
        }
        self.count = self.count - removed
    }

    fn isEmpty(self: *List(T)) i64 {
        if self.count == 0 { return 1 }
        return 0
    }

    // Go: slices.Compact — remove consecutive duplicate elements in-place
    fn compact(self: *List(T)) void {
        if self.count < 2 { return }
        var write: i64 = 1
        var read: i64 = 1
        while read < self.count {
            let curr = @intToPtr(*T, self.items + read * @sizeOf(T))
            let prev = @intToPtr(*T, self.items + (write - 1) * @sizeOf(T))
            if curr.* != prev.* {
                if write != read {
                    let dst = @intToPtr(*T, self.items + write * @sizeOf(T))
                    dst.* = curr.*
                }
                write = write + 1
            }
            read = read + 1
        }
        self.count = write
    }
}

// ============================================================================
// Tests: Baseline
// ============================================================================

test "baseline" {
    // Constants
    @assert_eq(42, 42)
    @assert_eq(10 + 5, 15)
    @assert_eq(20 - 8, 12)
    @assert_eq(6 * 7, 42)
    @assert_eq(2 + 3 * 4, 14)

    // Variables
    let x = 10
    let y = 5
    @assert_eq(x + y, 15)

    // If/else
    if 10 > 5 {
        let ok = 1
        @assert_eq(ok, 1)
    } else {
        @assert(1 == 0)
    }

    // While loop
    var sum: i64 = 0
    var i: i64 = 1
    while i <= 10 {
        sum = sum + i
        i = i + 1
    }
    @assert_eq(sum, 55)
}

// ============================================================================
// Tests: Phase 3 language features
// ============================================================================

test "phase3" {
    // Char literals
    let c1 = 'A'
    @assert_eq(c1, 65)
    let c2 = '\n'
    @assert_eq(c2, 10)

    // Type alias + struct
    let coord: Coord = Coord { .x = 10, .y = 20 }
    @assert_eq(coord.x + coord.y, 30)

    // Builtins
    @assert_eq(@sizeOf(i64), 8)
    @assert_eq(@sizeOf(Point), 16)
    @assert_eq(@alignOf(i64), 8)
    let big: i64 = 42
    let small = @intCast(i32, big)
    @assert_eq(small, 42)

    // Enums
    let color: i64 = Color.Green
    @assert_eq(color, 1)
    let status: i64 = Status.Error
    @assert_eq(status, 100)

    // Union
    let state: i64 = State.Running
    @assert_eq(state, 1)

    // Bitwise ops
    let a = 255
    let b = 15
    @assert_eq(a & b, 15)
    @assert_eq((240 | 15) - 200, 55)
    @assert_eq((a ^ b) & 255, 240)
    @assert_eq((~0) & 255, 255)
    @assert_eq(1 << 4, 16)
    @assert_eq(64 >> 2, 16)

    // Compound assignment
    var x = 10
    x += 5
    @assert_eq(x, 15)
    x -= 3
    @assert_eq(x, 12)
    x *= 2
    @assert_eq(x, 24)
    var y = 255
    y &= 15
    @assert_eq(y, 15)

    // Optional types
    let opt1: ?i64 = 42
    @assert_eq(opt1.?, 42)
    let opt2: ?i64 = null
    @assert_eq(opt2 ?? 99, 99)
    let opt3: ?i64 = 42
    @assert_eq(opt3 ?? 99, 42)

    // Switch
    let sw1 = switch 2 {
        1 => 10,
        2 => 20,
        3 => 30,
        else => 0,
    }
    @assert_eq(sw1, 20)

    let level = Level.Medium
    let sw2 = switch level {
        Level.Low => 1,
        Level.Medium => 50,
        Level.High => 99,
        else => 0,
    }
    @assert_eq(sw2, 50)
}

// ============================================================================
// Tests: Function call + float
// ============================================================================

test "func_call" {
    @assert_eq(double(10), 20)
}

test "float_locals" {
    let x: f64 = 3.14
    let y: f64 = 0.0
}

// ============================================================================
// Tests: Union payloads
// ============================================================================

test "union_payload" {
    let r: Result = Result.Ok(42)
    @assert_eq(r.tag, 0)
    let val = r.Ok
    @assert_eq(val, 42)
    let e: Result = Result.Err(99)
    @assert_eq(e.tag, 1)
}

test "union_mixed" {
    let e1: Event = Event.Hover
    @assert_eq(e1.tag, 1)
    let e2: Event = Event.Click(100)
    @assert_eq(e2.tag, 0)
    let clicks = e2.Click
    @assert_eq(clicks, 100)
}

test "union_switch_no_capture" {
    let r: Result = Result.Ok(42)
    var matched: i64 = 0
    switch r {
        Result.Ok => { matched = 1 },
        Result.Err => { matched = 2 },
    }
    @assert_eq(matched, 1)
}

test "union_switch_capture" {
    let r: Result = Result.Ok(42)
    var matched: i64 = 0
    var captured: i64 = 0
    switch r {
        Result.Ok |val| => {
            matched = 1
            captured = val
        },
        Result.Err |e| => { matched = 2 },
    }
    @assert_eq(matched, 1)
    @assert_eq(captured, 42)
}

// ============================================================================
// Tests: Error unions
// ============================================================================

test "error_union_catch" {
    let result = mayFail(-1) catch 99
    @assert_eq(result, 99)
    let success = mayFail(5) catch 99
    @assert_eq(success, 10)
}

test "error_union_try" {
    let result = outer() catch 42
    @assert_eq(result, 42)
}

// ============================================================================
// Tests: Defer
// ============================================================================

test "defer_basic" {
    var x: i64 = 10
    defer x = 99
    @assert_eq(x, 10)
}

test "defer_loop_break" {
    var sum: i64 = 0
    var i: i64 = 0
    while i < 5 {
        defer sum = sum + 1
        i = i + 1
        if i == 3 { break }
    }
    @assert_eq(sum, 3)
}

test "defer_lifo" {
    var x: i64 = 2
    defer x = x + 1
    defer x = x * 10
    @assert_eq(x, 2)
}

// ============================================================================
// Tests: ARC
// ============================================================================

test "arc_func_return_new" {
    let p = createFoo(42)
    @assert_eq(p.x, 42)
}

test "arc_copy_local" {
    let p = new Foo { x: 10 }
    let q = p
    @assert_eq(q.x, 10)
}

test "arc_reassignment" {
    var p = new Foo { x: 1 }
    let q = new Foo { x: 2 }
    p = q
    @assert_eq(p.x, 2)
}

test "arc_return_forward" {
    let f = makeFoo(77)
    @assert_eq(f.x, 77)
}

test "arc_dealloc_basic" {
    let p = new Foo { x: 42 }
    @assert_eq(p.x, 42)
}

test "arc_dealloc_multi" {
    let a = makeFoo(10)
    let b = makeFoo(20)
    let c = makeFoo(12)
    @assert_eq(a.x + b.x + c.x, 42)
}

// ============================================================================
// Tests: Builtins (@alloc, @dealloc, @realloc)
// ============================================================================

test "builtin_alloc_dealloc" {
    let ptr = @alloc(8)
    @dealloc(ptr)
}

test "builtin_realloc" {
    let ptr = @alloc(8)
    let ptr2 = @realloc(ptr, 16)
    @dealloc(ptr2)
}

test "freelist_reuse" {
    let p1 = @alloc(8)
    @dealloc(p1)
    let p2 = @alloc(8)
    @dealloc(p2)
    let p3 = @alloc(8)
    @dealloc(p3)
}

// ============================================================================
// Tests: Deinit (uses DFoo with DFoo_deinit)
// ============================================================================

test "deinit_basic" {
    let p = new DFoo { x: 42 }
    @assert_eq(p.x, 42)
}

test "deinit_no_use" {
    let p = new DFoo { x: 42 }
}

test "deinit_mixed" {
    let f = new DFoo { x: 10 }
    let b = new Bar { y: 20 }
    @assert_eq(f.x + b.y, 30)
}

test "deinit_alloc_reuse" {
    let p1 = createDFoo(10)
    let v1 = p1.x
    let p2 = createDFoo(20)
    @assert_eq(v1 + p2.x, 30)
}

// ============================================================================
// Tests: Function pointers
// ============================================================================

test "fnptr_basic" {
    let f = add
    @assert_eq(f(3, 4), 7)
}

test "fnptr_param" {
    @assert_eq(apply_fn(dbl, 5), 10)
}

test "fnptr_reassign" {
    var f = inc
    let a = f(10)
    f = dec
    let b = f(10)
    @assert_eq(a + b, 20)
}

// ============================================================================
// Tests: Closures
// ============================================================================

test "closure_no_capture" {
    let f = fn(x: i64) i64 { return x * 2 }
    @assert_eq(f(21), 42)
}

test "closure_capture" {
    let x: i64 = 10
    let f = fn(y: i64) i64 { return x + y }
    @assert_eq(f(5), 15)
}

test "closure_multi_capture" {
    let a: i64 = 3
    let b: i64 = 7
    let f = fn(x: i64) i64 { return a + b + x }
    @assert_eq(f(10), 20)
}

test "closure_passed" {
    let offset: i64 = 100
    let g = fn(x: i64) i64 { return x + offset }
    @assert_eq(apply_fn(g, 5), 105)
}

// ============================================================================
// Tests: Generics (plain functions)
// ============================================================================

test "generic_fn_basic" {
    @assert_eq(max(i64)(3, 7), 7)
}

test "generic_struct_basic" {
    var p: Pair(i64, i64) = undefined
    p.first = 10
    p.second = 20
    @assert_eq(p.first + p.second, 30)
}

test "generic_fn_multi_inst" {
    let x: i64 = generic_add(i64)(10, 20)
    let y: i32 = generic_add(i32)(3, 4)
    @assert_eq(x + y, 37)
}

test "generic_struct_param" {
    var b: Box(i64) = undefined
    b.value = 42
    @assert_eq(Box_getValue(i64)(&b), 42)
}

test "sizeof_generic" {
    @assert_eq(getSize(i64)(), 8)
}

test "alloc_inttoptr_generic" {
    let p = allocOne(i64)(42)
    let result = p.*
    @dealloc(@ptrToInt(p))
    @assert_eq(result, 42)
}

test "generic_field_mutation" {
    var c: CounterM(i64) = undefined
    c.value = 10
    c.count = 0
    CounterM_increment(i64)(&c)
    CounterM_increment(i64)(&c)
    @assert_eq(c.count, 2)
}

// ============================================================================
// Tests: List(T) free function pattern
// ============================================================================

test "list_basic" {
    var list: List(i64) = undefined
    list.items = 0
    list.count = 0
    list.capacity = 0
    List_append(i64)(&list, 10)
    List_append(i64)(&list, 20)
    List_append(i64)(&list, 30)
    let a = List_get(i64)(&list, 0)
    let b = List_get(i64)(&list, 1)
    let c = List_get(i64)(&list, 2)
    @assert_eq(a + b + c, 60)
}

test "list_growth" {
    var list: List(i64) = undefined
    list.items = 0
    list.count = 0
    list.capacity = 0
    var i: i64 = 0
    while i < 20 {
        List_append(i64)(&list, i)
        i = i + 1
    }
    let first = List_get(i64)(&list, 0)
    let last = List_get(i64)(&list, 19)
    @assert_eq(first + last + list.count, 39)
}

test "list_pop" {
    var list: List(i64) = undefined
    list.items = 0
    list.count = 0
    list.capacity = 0
    List_append(i64)(&list, 10)
    List_append(i64)(&list, 20)
    List_append(i64)(&list, 30)
    let popped = List_pop(i64)(&list)
    @assert_eq(popped + list.count, 32)
}

test "list_set" {
    var list: List(i64) = undefined
    list.items = 0
    list.count = 0
    list.capacity = 0
    List_append(i64)(&list, 10)
    List_append(i64)(&list, 20)
    List_append(i64)(&list, 30)
    List_set(i64)(&list, 1, 50)
    @assert_eq(List_get(i64)(&list, 0) + List_get(i64)(&list, 1) + List_get(i64)(&list, 2), 90)
}

test "list_multi_type" {
    var a: List(i64) = undefined
    a.items = 0
    a.count = 0
    a.capacity = 0
    var b: List(i32) = undefined
    b.items = 0
    b.count = 0
    b.capacity = 0
    List_append(i64)(&a, 100)
    List_append(i32)(&b, 5)
    let x = List_get(i64)(&a, 0)
    let y: i64 = List_get(i32)(&b, 0)
    @assert_eq(x + y, 105)
}

// ============================================================================
// Tests: List(T) impl pattern (dot-call syntax)
// ============================================================================

test "list_impl_basic" {
    var list: List(i64) = undefined
    list.items = 0
    list.count = 0
    list.capacity = 0
    list.append(10)
    list.append(20)
    list.append(30)
    let a = list.get(0)
    let b = list.get(1)
    let c = list.get(2)
    @assert_eq(a + b + c, 60)
}

test "list_impl_growth" {
    var list: List(i64) = undefined
    list.items = 0
    list.count = 0
    list.capacity = 0
    var i: i64 = 0
    while i < 20 {
        list.append(i)
        i = i + 1
    }
    let first = list.get(0)
    let last = list.get(19)
    @assert_eq(first + last + list.count, 39)
}

test "list_impl_pop" {
    var list: List(i64) = undefined
    list.items = 0
    list.count = 0
    list.capacity = 0
    list.append(10)
    list.append(20)
    list.append(30)
    let popped = list.pop()
    @assert_eq(popped + list.count, 32)
}

test "list_impl_set" {
    var list: List(i64) = undefined
    list.items = 0
    list.count = 0
    list.capacity = 0
    list.append(10)
    list.append(20)
    list.append(30)
    list.set(1, 50)
    @assert_eq(list.get(0) + list.get(1) + list.get(2), 90)
}

test "list_impl_multi_type" {
    var a: List(i64) = undefined
    a.items = 0
    a.count = 0
    a.capacity = 0
    var b: List(i32) = undefined
    b.items = 0
    b.count = 0
    b.capacity = 0
    a.append(100)
    b.append(5)
    let x = a.get(0)
    let y: i64 = b.get(0)
    @assert_eq(x + y, 105)
}

// ============================================================================
// Tests: Generic impl blocks
// ============================================================================

test "generic_impl_basic" {
    var c: Counter(i64) = undefined
    c.value = 42
    @assert_eq(c.get(), 42)
}

test "generic_impl_self_call" {
    var b: BoxC(i64) = undefined
    b.value = 10
    b.count = 0
    b.increment()
    b.increment()
    b.increment()
    @assert_eq(b.count + b.value, 13)
}

test "generic_impl_multi_inst" {
    var a: Box(i64) = undefined
    a.value = 30
    var b: Box(i32) = undefined
    b.value = 12
    let x: i64 = a.get()
    let y: i64 = b.get()
    @assert_eq(x + y, 42)
}

test "generic_impl_forward_ref" {
    var b: BoxC(i64) = undefined
    b.value = 10
    b.count = 0
    b.increment()
    b.increment()
    @assert_eq(b.count + b.value, 12)
}

test "generic_impl_two_params" {
    var p: Pair(i64, i64) = undefined
    p.first = 30
    p.second = 12
    @assert_eq(p.sum(), 42)
}

// ============================================================================
// Tests: Struct literals, zero init, new for generics
// ============================================================================

test "generic_struct_literal" {
    var p = Pair(i64, i64) { .first = 10, .second = 32 }
    @assert_eq(p.first + p.second, 42)
}

test "generic_struct_literal_methods" {
    var p = Pair(i64, i64) { .first = 30, .second = 12 }
    @assert_eq(p.sum(), 42)
}

test "zero_init_basic" {
    var p: Point = .{}
    @assert_eq(p.x + p.y, 0)
}

test "zero_init_generic" {
    var p: Pair(i64, i64) = .{}
    @assert_eq(p.first + p.second, 0)
}

test "new_generic" {
    let p = new Pair(i64, i64) { first: 30, second: 12 }
    @assert_eq(p.first + p.second, 42)
}

// ============================================================================
// @memcpy builtin
// ============================================================================

test "memcpy_basic" {
    let src = @alloc(24)
    let dst = @alloc(24)
    let p0 = @intToPtr(*i64, src)
    p0.* = 10
    let p1 = @intToPtr(*i64, src + 8)
    p1.* = 20
    let p2 = @intToPtr(*i64, src + 16)
    p2.* = 30
    @memcpy(dst, src, 24)
    let d0 = @intToPtr(*i64, dst)
    let d1 = @intToPtr(*i64, dst + 8)
    let d2 = @intToPtr(*i64, dst + 16)
    @assert_eq(d0.*, 10)
    @assert_eq(d1.*, 20)
    @assert_eq(d2.*, 30)
    @dealloc(src)
    @dealloc(dst)
}

test "memcpy_zero_length" {
    let buf = @alloc(8)
    @intToPtr(*i64, buf).* = 42
    @memcpy(buf, buf, 0)
    @assert_eq(@intToPtr(*i64, buf).*, 42)
    @dealloc(buf)
}

// ============================================================================
// @trap builtin
// ============================================================================

test "trap_not_reached" {
    let x: i64 = 42
    if x == 0 { @trap() }
}

// ============================================================================
// Slice parameter passing
// ============================================================================

fn get_slice_len(items: []i64) i64 {
    return items.len
}

fn slice_sum(items: []i64) i64 {
    var total: i64 = 0
    var i: i64 = 0
    while i < items.len {
        total = total + items[i]
        i = i + 1
    }
    return total
}

test "slice_param_basic" {
    var arr = [10, 20, 30]
    let s = arr[0:3]
    @assert_eq(get_slice_len(s), 3)
}

test "slice_param_iteration" {
    var arr = [10, 20, 30, 40, 50]
    let s = arr[1:4]
    @assert_eq(slice_sum(s), 90)
}

// ============================================================================
// Traits
// ============================================================================

trait Greetable {
    fn greet(self: *Self) i64
}

struct TraitDog { age: i64 }

impl Greetable for TraitDog {
    fn greet(self: *TraitDog) i64 {
        return self.age
    }
}

test "trait_basic" {
    var d = TraitDog { .age = 42 }
    @assert_eq(d.greet(), 42)
}

trait Doubled {
    fn doubled(self: *Self) i64
}

impl Doubled for i64 {
    fn doubled(self: *i64) i64 {
        return self.* * 2
    }
}

test "trait_primitive" {
    var x: i64 = 21
    @assert_eq(x.doubled(), 42)
}

trait HasValue {
    fn value(self: *Self) i64
}

struct TraitCat { lives: i64 }

impl HasValue for TraitCat {
    fn value(self: *TraitCat) i64 {
        return self.lives
    }
}

impl HasValue for TraitDog {
    fn value(self: *TraitDog) i64 {
        return self.age
    }
}

test "trait_multi_impl" {
    var c = TraitCat { .lives = 9 }
    var d = TraitDog { .age = 3 }
    @assert_eq(c.value() + d.value(), 12)
}

fn extractValue(T)(item: *T) i64 {
    return item.value()
}

test "trait_generic_usage" {
    var b = TraitCat { .lives = 99 }
    @assert_eq(extractValue(TraitCat)(&b), 99)
}

trait TraitEq {
    fn eq(self: *Self, other: *Self) i64
}

struct TraitPoint { x: i64, y: i64 }

impl TraitEq for TraitPoint {
    fn eq(self: *TraitPoint, other: *TraitPoint) i64 {
        if self.x == other.x {
            if self.y == other.y {
                return 1
            }
        }
        return 0
    }
}

test "trait_self_type" {
    var a = TraitPoint { .x = 3, .y = 4 }
    var b = TraitPoint { .x = 3, .y = 4 }
    var c = TraitPoint { .x = 1, .y = 2 }
    @assert_eq(a.eq(&b), 1)
    @assert_eq(a.eq(&c), 0)
}

// ============================================================================
// Wave 2: Const evaluation
// ============================================================================

const CE_SIZE: i64 = 8
const CE_DOUBLE: i64 = CE_SIZE * 2
const CE_TRIPLE: i64 = CE_SIZE + CE_SIZE + CE_SIZE

test "const_eval_arithmetic" {
    // Go: cmd/compile/internal/ir/const.go — const folding chains
    @assert_eq(CE_DOUBLE, 16)
    @assert_eq(CE_TRIPLE, 24)
    @assert_eq(CE_DOUBLE + CE_TRIPLE, 40)
}

struct CEPoint { x: i64, y: i64 }
const CE_POINT_SIZE: i64 = @sizeOf(CEPoint)
const CE_I64_SIZE: i64 = @sizeOf(i64)

test "const_eval_sizeof" {
    // Zig: @sizeOf resolved at comptime. Go: unsafe.Sizeof is const-foldable.
    @assert_eq(CE_I64_SIZE, 8)
    @assert_eq(CE_POINT_SIZE, 16)
    @assert_eq(CE_POINT_SIZE + CE_I64_SIZE, 24)
}

// ============================================================================
// Wave 2: Trait bounds
// ============================================================================

trait BComparable {
    fn bcmp(self: *Self, other: *Self) i64
}

impl BComparable for i64 {
    fn bcmp(self: *i64, other: *i64) i64 {
        if self.* > other.* { return 1 }
        if self.* < other.* { return 0 - 1 }
        return 0
    }
}

fn bounded_max(T)(a: T, b: T) T where T: BComparable {
    var x = a
    var y = b
    if x.bcmp(&y) > 0 { return a }
    return b
}

test "trait_bound_basic" {
    // Rust: fn max<T: Ord>(a: T, b: T) -> T
    // Go 1.18: func Max[T constraints.Ordered](a, b T) T
    @assert_eq(bounded_max(i64)(10, 20), 20)
    @assert_eq(bounded_max(i64)(30, 5), 30)
}

trait BAddable {
    fn bval(self: *Self) i64
}

impl BAddable for i64 {
    fn bval(self: *i64) i64 { return self.* }
}

fn bounded_sum(T)(a: T, b: T) i64 where T: BAddable {
    var x = a
    var y = b
    return x.bval() + y.bval()
}

test "trait_bound_multi" {
    @assert_eq(bounded_sum(i64)(10, 32), 42)
}

// ============================================================================
// Wave 2: Match expressions (wildcards, guards, ranges)
// ============================================================================

fn match_classify_wildcard(x: i64) i64 {
    return switch x {
        1 => 10,
        2 => 20,
        _ => 99,
    }
}

test "match_wildcard" {
    // Zig: _ in switch covers all remaining values. Rust: _ in match is catch-all.
    @assert_eq(match_classify_wildcard(1), 10)
    @assert_eq(match_classify_wildcard(2), 20)
    @assert_eq(match_classify_wildcard(42), 99)
    @assert_eq(match_classify_wildcard(0), 99)
}

fn match_classify_guard(x: i64) i64 {
    return switch x {
        1 if x > 0 => 10,
        2 => 20,
        _ => 0,
    }
}

test "match_guard" {
    // Rust: match x { n if n > 10 => "big", _ => "small" }
    @assert_eq(match_classify_guard(1), 10)
    @assert_eq(match_classify_guard(2), 20)
    @assert_eq(match_classify_guard(99), 0)
}

fn match_classify_range(x: i64) i64 {
    return switch x {
        1..5 => 1,
        6..10 => 2,
        _ => 3,
    }
}

test "match_range" {
    // Zig: 1...10 (inclusive). Rust: 1..=10. Cot: 1..10 (inclusive).
    @assert_eq(match_classify_range(1), 1)
    @assert_eq(match_classify_range(3), 1)
    @assert_eq(match_classify_range(5), 1)
    @assert_eq(match_classify_range(6), 2)
    @assert_eq(match_classify_range(10), 2)
    @assert_eq(match_classify_range(0), 3)
    @assert_eq(match_classify_range(11), 3)
}

// ============================================================================
// Wave 2: Tuple types
// ============================================================================

test "tuple_basic" {
    var t = (10, 20)
    @assert_eq(t.0, 10)
    @assert_eq(t.1, 20)
    @assert_eq(t.0 + t.1, 30)
}

test "tuple_nested" {
    var a = (1, 2)
    var b = (3, 4)
    @assert_eq(a.0 + a.1 + b.0 + b.1, 10)
}

test "tuple_three" {
    var t = (100, 200, 300)
    @assert_eq(t.0 + t.1 + t.2, 600)
}

// ============================================================================
// SRET: Function returns for multi-word types
// ============================================================================

fn make_pair() (i64, i64) {
    return (10, 20)
}

test "sret_tuple_return" {
    let p = make_pair()
    @assert_eq(p.0, 10)
    @assert_eq(p.1, 20)
    @assert_eq(p.0 + p.1, 30)
}

fn make_point() Point {
    return Point { .x = 10, .y = 20 }
}

test "sret_struct_return" {
    let p = make_point()
    @assert_eq(p.x, 10)
    @assert_eq(p.y, 20)
    @assert_eq(p.x + p.y, 30)
}

fn double_pair() (i64, i64) {
    let p = make_pair()
    return (p.0 * 2, p.1 * 2)
}

test "sret_chain" {
    let d = double_pair()
    @assert_eq(d.0, 20)
    @assert_eq(d.1, 40)
    @assert_eq(d.0 + d.1, 60)
}

// ============================================================================
// Tests: Production List(T) — bounds, growth, deinit, insert, remove
// ============================================================================

test "list_bounds_get" {
    // Verify valid boundary indices work (can't test traps from within same program)
    var list: List(i64) = .{}
    list.append(10)
    list.append(20)
    list.append(30)
    // get(0) and get(count-1) must succeed
    @assert_eq(list.get(0), 10)
    @assert_eq(list.get(2), 30)
    // set boundary
    list.set(0, 99)
    @assert_eq(list.get(0), 99)
    list.set(2, 88)
    @assert_eq(list.get(2), 88)
    list.free()
}

test "list_growth_go" {
    // Go's nextslicecap: 2x for cap<256, ~1.25x for larger
    var list: List(i64) = .{}
    var i: i64 = 0
    while i < 300 {
        list.append(i)
        i = i + 1
    }
    @assert_eq(list.len(), 300)
    // Verify first and last elements survive growth
    @assert_eq(list.get(0), 0)
    @assert_eq(list.get(299), 299)
    // After 256 elements, growth should be ~1.25x, so capacity < 512 (which 2x would give)
    // With Go's formula: after 256, next cap = 256 + (256+768)/4 = 256 + 256 = 512
    // Then 512 is enough for 300, so cap should be 512
    // But the key test: capacity >= 300 and the data is correct
    @assert(list.cap() >= 300)
    list.free()
}

test "list_free" {
    var list: List(i64) = .{}
    list.append(1)
    list.append(2)
    list.append(3)
    list.free()
    @assert_eq(list.count, 0)
    @assert_eq(list.capacity, 0)
    @assert_eq(list.items, 0)
}

test "list_clear" {
    var list: List(i64) = .{}
    list.append(10)
    list.append(20)
    list.append(30)
    let cap_before = list.cap()
    list.clear()
    @assert_eq(list.len(), 0)
    // Capacity retained after clear
    @assert_eq(list.cap(), cap_before)
    // Can reuse after clear
    list.append(99)
    @assert_eq(list.get(0), 99)
    list.free()
}

test "list_insert" {
    var list: List(i64) = .{}
    list.append(10)
    list.append(30)
    list.append(40)
    // Insert at beginning
    list.insert(0, 5)
    // Insert in middle (between 10 and 30)
    list.insert(2, 20)
    // Insert at end
    list.insert(5, 50)
    // Expected: [5, 10, 20, 30, 40, 50]
    @assert_eq(list.len(), 6)
    @assert_eq(list.get(0), 5)
    @assert_eq(list.get(1), 10)
    @assert_eq(list.get(2), 20)
    @assert_eq(list.get(3), 30)
    @assert_eq(list.get(4), 40)
    @assert_eq(list.get(5), 50)
    list.free()
}

test "list_ordered_remove" {
    var list: List(i64) = .{}
    list.append(10)
    list.append(20)
    list.append(30)
    list.append(40)
    list.append(50)
    // Remove from beginning
    let first = list.orderedRemove(0)
    @assert_eq(first, 10)
    // Now: [20, 30, 40, 50]
    @assert_eq(list.len(), 4)
    @assert_eq(list.get(0), 20)
    // Remove from middle
    let mid = list.orderedRemove(1)
    @assert_eq(mid, 30)
    // Now: [20, 40, 50]
    @assert_eq(list.len(), 3)
    @assert_eq(list.get(0), 20)
    @assert_eq(list.get(1), 40)
    @assert_eq(list.get(2), 50)
    list.free()
}

test "list_swap_remove" {
    var list: List(i64) = .{}
    list.append(10)
    list.append(20)
    list.append(30)
    list.append(40)
    // SwapRemove index 1 (value 20): last element (40) moves to index 1
    let removed = list.swapRemove(1)
    @assert_eq(removed, 20)
    // Now: [10, 40, 30]
    @assert_eq(list.len(), 3)
    @assert_eq(list.get(0), 10)
    @assert_eq(list.get(1), 40)
    @assert_eq(list.get(2), 30)
    // SwapRemove last element (no swap needed)
    let last = list.swapRemove(2)
    @assert_eq(last, 30)
    @assert_eq(list.len(), 2)
    list.free()
}

test "list_reverse" {
    var list: List(i64) = .{}
    list.append(1)
    list.append(2)
    list.append(3)
    list.append(4)
    list.append(5)
    list.reverse()
    @assert_eq(list.get(0), 5)
    @assert_eq(list.get(1), 4)
    @assert_eq(list.get(2), 3)
    @assert_eq(list.get(3), 2)
    @assert_eq(list.get(4), 1)
    list.free()
}

test "list_clone" {
    var list: List(i64) = .{}
    list.append(10)
    list.append(20)
    list.append(30)
    var copy = list.clone()
    // Verify clone has same data
    @assert_eq(copy.len(), 3)
    @assert_eq(copy.get(0), 10)
    @assert_eq(copy.get(1), 20)
    @assert_eq(copy.get(2), 30)
    // Mutate original, verify clone unaffected
    list.set(0, 99)
    @assert_eq(copy.get(0), 10)
    list.free()
    copy.free()
}

test "list_last" {
    var list: List(i64) = .{}
    list.append(10)
    @assert_eq(list.last(), 10)
    list.append(20)
    @assert_eq(list.last(), 20)
    list.append(30)
    @assert_eq(list.last(), 30)
    let popped = list.pop()
    @assert_eq(list.last(), 20)
    list.free()
}

test "memcpy_overlap" {
    // Test overlapping @memcpy (memmove semantics) — used by insert/orderedRemove
    let buf = @alloc(40)
    // Write [10, 20, 30, 40, 50] at positions 0-4
    @intToPtr(*i64, buf).* = 10
    @intToPtr(*i64, buf + 8).* = 20
    @intToPtr(*i64, buf + 16).* = 30
    @intToPtr(*i64, buf + 24).* = 40
    @intToPtr(*i64, buf + 32).* = 0
    // Shift right: copy [0..3] to [1..4] (dst > src, backward copy path)
    @memcpy(buf + 8, buf, 32)
    // Expected: [10, 10, 20, 30, 40]
    @assert_eq(@intToPtr(*i64, buf).*, 10)
    @assert_eq(@intToPtr(*i64, buf + 8).*, 10)
    @assert_eq(@intToPtr(*i64, buf + 16).*, 20)
    @assert_eq(@intToPtr(*i64, buf + 24).*, 30)
    @assert_eq(@intToPtr(*i64, buf + 32).*, 40)
    @dealloc(buf)
}

// ============================================================================
// Tests: List(T) Tier 1+2 — search, resize, bulk ops, compact
// ============================================================================

test "list_contains" {
    // Go: slices.Contains — linear scan
    var list: List(i64) = .{}
    list.append(10)
    list.append(20)
    list.append(30)
    @assert_eq(list.contains(20), 1)
    @assert_eq(list.contains(99), 0)
    @assert_eq(list.contains(10), 1)
    @assert_eq(list.contains(30), 1)
    list.free()
}

test "list_index_of" {
    // Go: slices.Index — return index or -1
    var list: List(i64) = .{}
    list.append(10)
    list.append(20)
    list.append(30)
    list.append(20)
    @assert_eq(list.indexOf(10), 0)
    @assert_eq(list.indexOf(20), 1)
    @assert_eq(list.indexOf(30), 2)
    @assert_eq(list.indexOf(99), 0 - 1)
    list.free()
}

test "list_equal" {
    // Go: slices.Equal — element-wise comparison
    var a: List(i64) = .{}
    a.append(1)
    a.append(2)
    a.append(3)
    var b: List(i64) = .{}
    b.append(1)
    b.append(2)
    b.append(3)
    @assert_eq(a.equal(&b), 1)
    // Different length
    b.append(4)
    @assert_eq(a.equal(&b), 0)
    // Same length, different content
    var c: List(i64) = .{}
    c.append(1)
    c.append(99)
    c.append(3)
    @assert_eq(a.equal(&c), 0)
    a.free()
    b.free()
    c.free()
}

test "list_first" {
    var list: List(i64) = .{}
    list.append(42)
    list.append(99)
    @assert_eq(list.first(), 42)
    list.insert(0, 7)
    @assert_eq(list.first(), 7)
    list.free()
}

test "list_resize" {
    // Zig: resize — grow (undefined elements) or shrink
    var list: List(i64) = .{}
    list.append(10)
    list.append(20)
    list.append(30)
    // Shrink
    list.resize(2)
    @assert_eq(list.len(), 2)
    @assert_eq(list.get(0), 10)
    @assert_eq(list.get(1), 20)
    // Grow (new elements undefined, but count changes)
    list.resize(5)
    @assert_eq(list.len(), 5)
    // Original elements preserved
    @assert_eq(list.get(0), 10)
    @assert_eq(list.get(1), 20)
    // Can write to new slots
    list.set(2, 30)
    list.set(3, 40)
    list.set(4, 50)
    @assert_eq(list.get(4), 50)
    list.free()
}

test "list_append_n_times" {
    // Zig: appendNTimes — fill with value
    var list: List(i64) = .{}
    list.appendNTimes(42, 5)
    @assert_eq(list.len(), 5)
    @assert_eq(list.get(0), 42)
    @assert_eq(list.get(4), 42)
    // Append more
    list.appendNTimes(0, 3)
    @assert_eq(list.len(), 8)
    @assert_eq(list.get(5), 0)
    @assert_eq(list.get(7), 0)
    list.free()
}

test "list_insert_slice" {
    // Zig: insertSlice — bulk insert at position
    var list: List(i64) = .{}
    list.append(1)
    list.append(5)
    // Prepare source buffer [2, 3, 4]
    let src = @alloc(24)
    @intToPtr(*i64, src).* = 2
    @intToPtr(*i64, src + 8).* = 3
    @intToPtr(*i64, src + 16).* = 4
    // Insert at index 1: [1, 2, 3, 4, 5]
    list.insertSlice(1, src, 3)
    @dealloc(src)
    @assert_eq(list.len(), 5)
    @assert_eq(list.get(0), 1)
    @assert_eq(list.get(1), 2)
    @assert_eq(list.get(2), 3)
    @assert_eq(list.get(3), 4)
    @assert_eq(list.get(4), 5)
    list.free()
}

test "list_replace_range" {
    // Zig: replaceRange / Go: slices.Replace
    var list: List(i64) = .{}
    list.append(1)
    list.append(2)
    list.append(3)
    list.append(4)
    list.append(5)
    // Replace [1..3) (elements 2,3) with [20, 30, 40] — growing
    let src1 = @alloc(24)
    @intToPtr(*i64, src1).* = 20
    @intToPtr(*i64, src1 + 8).* = 30
    @intToPtr(*i64, src1 + 16).* = 40
    list.replaceRange(1, 2, src1, 3)
    @dealloc(src1)
    // Expected: [1, 20, 30, 40, 4, 5]
    @assert_eq(list.len(), 6)
    @assert_eq(list.get(0), 1)
    @assert_eq(list.get(1), 20)
    @assert_eq(list.get(2), 30)
    @assert_eq(list.get(3), 40)
    @assert_eq(list.get(4), 4)
    @assert_eq(list.get(5), 5)
    // Replace [1..4) (elements 20,30,40) with [99] — shrinking
    let src2 = @alloc(8)
    @intToPtr(*i64, src2).* = 99
    list.replaceRange(1, 3, src2, 1)
    @dealloc(src2)
    // Expected: [1, 99, 4, 5]
    @assert_eq(list.len(), 4)
    @assert_eq(list.get(0), 1)
    @assert_eq(list.get(1), 99)
    @assert_eq(list.get(2), 4)
    @assert_eq(list.get(3), 5)
    list.free()
}

test "list_shrink_and_free" {
    // Zig: shrinkAndFree — reduce length and realloc
    var list: List(i64) = .{}
    list.append(10)
    list.append(20)
    list.append(30)
    list.append(40)
    list.append(50)
    let old_cap = list.cap()
    list.shrinkAndFree(3)
    @assert_eq(list.len(), 3)
    @assert_eq(list.cap(), 3)
    @assert_eq(list.get(0), 10)
    @assert_eq(list.get(1), 20)
    @assert_eq(list.get(2), 30)
    // Shrink to 0 frees everything
    list.shrinkAndFree(0)
    @assert_eq(list.count, 0)
    @assert_eq(list.capacity, 0)
}

test "list_delete_range" {
    // Go: slices.Delete(s, i, j) — remove [start, end)
    var list: List(i64) = .{}
    list.append(1)
    list.append(2)
    list.append(3)
    list.append(4)
    list.append(5)
    // Delete [1, 3) — remove elements 2, 3
    list.deleteRange(1, 3)
    // Expected: [1, 4, 5]
    @assert_eq(list.len(), 3)
    @assert_eq(list.get(0), 1)
    @assert_eq(list.get(1), 4)
    @assert_eq(list.get(2), 5)
    // Delete [0, 1) — remove first element
    list.deleteRange(0, 1)
    // Expected: [4, 5]
    @assert_eq(list.len(), 2)
    @assert_eq(list.get(0), 4)
    list.free()
}

test "list_ensure_unused" {
    // Zig: ensureUnusedCapacity
    var list: List(i64) = .{}
    list.append(1)
    list.ensureUnusedCapacity(100)
    @assert(list.cap() >= 101)
    @assert_eq(list.len(), 1)
    @assert_eq(list.get(0), 1)
    list.free()
}

test "list_is_empty" {
    var list: List(i64) = .{}
    @assert_eq(list.isEmpty(), 1)
    list.append(42)
    @assert_eq(list.isEmpty(), 0)
    list.pop()
    @assert_eq(list.isEmpty(), 1)
}

test "list_compact" {
    // Go: slices.Compact — remove consecutive duplicates
    var list: List(i64) = .{}
    list.append(1)
    list.append(1)
    list.append(2)
    list.append(2)
    list.append(2)
    list.append(3)
    list.append(1)
    list.append(1)
    list.compact()
    // Expected: [1, 2, 3, 1]
    @assert_eq(list.len(), 4)
    @assert_eq(list.get(0), 1)
    @assert_eq(list.get(1), 2)
    @assert_eq(list.get(2), 3)
    @assert_eq(list.get(3), 1)
    list.free()
}
