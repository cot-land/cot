// StringMap â€” Hash map from string keys to i64 values.
//
// Design: Open addressing with linear probing, power-of-2 capacity, 75% load factor.
// String keys stored as (ptr, len) pairs in parallel arrays.
// Ref: Zig std.StaticStringMap, Go runtime map with string keys.
//
// Usage:
//   import "std/string_map"
//   var m: StringMap = .{}
//   m.set("hello", 42)
//   @assertEq(m.get("hello"), 42)

import "std/sys"

// FNV-1a 64-bit hash for strings.
// Ref: Zig std.hash.Fnv1a_64, Go hash/fnv
// offset_basis = 14695981039346656037 = -(3750763034362895579) signed i64
// prime = 1099511628211
fn stringHash(s: string) i64 {
    var ptr = @ptrOf(s)
    var slen = @lenOf(s)
    var h: i64 = 0 - 3750763034362895579
    var i: i64 = 0
    while (i < slen) {
        var b = @intToPtr(*i64, ptr + i).* & 255
        h = (h ^ b) * 1099511628211
        i += 1
    }
    return h
}

fn stringEqual(a: string, b: string) i64 {
    var alen = @lenOf(a)
    var blen = @lenOf(b)
    if (alen != blen) { return 0 }
    var aptr = @ptrOf(a)
    var bptr = @ptrOf(b)
    var i: i64 = 0
    while (i < alen) {
        var ab = @intToPtr(*i64, aptr + i).* & 255
        var bb = @intToPtr(*i64, bptr + i).* & 255
        if (ab != bb) { return 0 }
        i += 1
    }
    return 1
}

struct StringMap {
    // Parallel arrays: key_ptrs[i]/key_lens[i] = string key, values[i] = i64 value
    key_ptrs: i64,
    key_lens: i64,
    values: i64,
    states: i64,
    count: i64,
    capacity: i64,
}

impl StringMap {
    // ===== Internal =====

    fn rehash(self: *StringMap, new_cap: i64) void {
        var old_kp = self.key_ptrs
        var old_kl = self.key_lens
        var old_v = self.values
        var old_s = self.states
        var old_cap = self.capacity

        self.key_ptrs = alloc(0, new_cap * 8)
        self.key_lens = alloc(0, new_cap * 8)
        self.values = alloc(0, new_cap * 8)
        self.states = alloc(0, new_cap * 8)
        self.capacity = new_cap
        self.count = 0

        // Zero all states
        var si: i64 = 0
        while (si < new_cap) {
            @intToPtr(*i64, self.states + si * 8).* = 0
            si += 1
        }

        // Reinsert old entries
        var oi: i64 = 0
        while (oi < old_cap) {
            if (@intToPtr(*i64, old_s + oi * 8).* == 1) {
                var kp = @intToPtr(*i64, old_kp + oi * 8).*
                var kl = @intToPtr(*i64, old_kl + oi * 8).*
                var v = @intToPtr(*i64, old_v + oi * 8).*
                self.set(@string(kp, kl), v)
            }
            oi += 1
        }

        if (old_cap > 0) {
            dealloc(old_kp)
            dealloc(old_kl)
            dealloc(old_v)
            dealloc(old_s)
        }
    }

    // ===== Core =====

    fn set(self: *StringMap, key: string, value: i64) void {
        if (self.capacity == 0) {
            self.rehash(16)
        } else {
            if ((self.count + 1) * 4 >= self.capacity * 3) {
                self.rehash(self.capacity * 2)
            }
        }

        var h = stringHash(key)
        var idx = h & (self.capacity - 1)
        var first_tombstone: i64 = 0 - 1

        var i: i64 = 0
        while (i < self.capacity) {
            var st = @intToPtr(*i64, self.states + idx * 8)
            if (st.* == 0) {
                var target = idx
                if (first_tombstone >= 0) { target = first_tombstone }
                @intToPtr(*i64, self.key_ptrs + target * 8).* = @ptrOf(key)
                @intToPtr(*i64, self.key_lens + target * 8).* = @lenOf(key)
                @intToPtr(*i64, self.values + target * 8).* = value
                @intToPtr(*i64, self.states + target * 8).* = 1
                self.count += 1
                return
            }
            if (st.* == 1) {
                var ekp = @intToPtr(*i64, self.key_ptrs + idx * 8).*
                var ekl = @intToPtr(*i64, self.key_lens + idx * 8).*
                if (stringEqual(@string(ekp, ekl), key) == 1) {
                    @intToPtr(*i64, self.values + idx * 8).* = value
                    return
                }
            }
            if (st.* == 2) {
                if (first_tombstone < 0) { first_tombstone = idx }
            }
            idx = (idx + 1) & (self.capacity - 1)
            i += 1
        }
        @trap()
    }

    fn get(self: *StringMap, key: string) i64 {
        if (self.capacity == 0) { @trap() }
        var h = stringHash(key)
        var idx = h & (self.capacity - 1)

        var i: i64 = 0
        while (i < self.capacity) {
            var st = @intToPtr(*i64, self.states + idx * 8).*
            if (st == 0) { @trap() }
            if (st == 1) {
                var ekp = @intToPtr(*i64, self.key_ptrs + idx * 8).*
                var ekl = @intToPtr(*i64, self.key_lens + idx * 8).*
                if (stringEqual(@string(ekp, ekl), key) == 1) {
                    return @intToPtr(*i64, self.values + idx * 8).*
                }
            }
            idx = (idx + 1) & (self.capacity - 1)
            i += 1
        }
        @trap()
        return 0
    }

    fn getOrDefault(self: *StringMap, key: string, default: i64) i64 {
        if (self.capacity == 0) { return default }
        var h = stringHash(key)
        var idx = h & (self.capacity - 1)

        var i: i64 = 0
        while (i < self.capacity) {
            var st = @intToPtr(*i64, self.states + idx * 8).*
            if (st == 0) { return default }
            if (st == 1) {
                var ekp = @intToPtr(*i64, self.key_ptrs + idx * 8).*
                var ekl = @intToPtr(*i64, self.key_lens + idx * 8).*
                if (stringEqual(@string(ekp, ekl), key) == 1) {
                    return @intToPtr(*i64, self.values + idx * 8).*
                }
            }
            idx = (idx + 1) & (self.capacity - 1)
            i += 1
        }
        return default
    }

    fn has(self: *StringMap, key: string) i64 {
        if (self.capacity == 0) { return 0 }
        var h = stringHash(key)
        var idx = h & (self.capacity - 1)

        var i: i64 = 0
        while (i < self.capacity) {
            var st = @intToPtr(*i64, self.states + idx * 8).*
            if (st == 0) { return 0 }
            if (st == 1) {
                var ekp = @intToPtr(*i64, self.key_ptrs + idx * 8).*
                var ekl = @intToPtr(*i64, self.key_lens + idx * 8).*
                if (stringEqual(@string(ekp, ekl), key) == 1) { return 1 }
            }
            idx = (idx + 1) & (self.capacity - 1)
            i += 1
        }
        return 0
    }

    fn delete(self: *StringMap, key: string) void {
        if (self.capacity == 0) { return }
        var h = stringHash(key)
        var idx = h & (self.capacity - 1)

        var i: i64 = 0
        while (i < self.capacity) {
            var st = @intToPtr(*i64, self.states + idx * 8)
            if (st.* == 0) { return }
            if (st.* == 1) {
                var ekp = @intToPtr(*i64, self.key_ptrs + idx * 8).*
                var ekl = @intToPtr(*i64, self.key_lens + idx * 8).*
                if (stringEqual(@string(ekp, ekl), key) == 1) {
                    st.* = 2
                    self.count -= 1
                    return
                }
            }
            idx = (idx + 1) & (self.capacity - 1)
            i += 1
        }
    }

    // ===== Info =====

    fn len(self: *StringMap) i64 { return self.count }

    fn isEmpty(self: *StringMap) i64 {
        if (self.count == 0) { return 1 }
        return 0
    }

    // ===== Lifecycle =====

    fn free(self: *StringMap) void {
        if (self.capacity > 0) {
            dealloc(self.key_ptrs)
            dealloc(self.key_lens)
            dealloc(self.values)
            dealloc(self.states)
        }
        self.key_ptrs = 0
        self.key_lens = 0
        self.values = 0
        self.states = 0
        self.count = 0
        self.capacity = 0
    }

    fn clear(self: *StringMap) void {
        var ci: i64 = 0
        while (ci < self.capacity) {
            @intToPtr(*i64, self.states + ci * 8).* = 0
            ci += 1
        }
        self.count = 0
    }
}
