@safe

// fs — File I/O.
//
// Wraps low-level file descriptor operations via extern fn declarations.
// Reference: Zig std.fs (File, openFile, createFile)

import "std/sys"

const FsError = error { NotFound, PermissionDenied, IoError }

// Open flags — platform-conditional (macOS vs Linux differ)
const O_RDONLY: i64 = 0
const O_WRONLY: i64 = 1
const O_RDWR: i64 = 2
const O_CREAT: i64 = if (@targetOs() == "linux") { 64 } else { 512 }
const O_TRUNC: i64 = if (@targetOs() == "linux") { 512 } else { 1024 }
const O_APPEND: i64 = if (@targetOs() == "linux") { 1024 } else { 8 }
const O_EXCL: i64 = if (@targetOs() == "linux") { 128 } else { 2048 }
const O_CREATE: i64 = if (@targetOs() == "linux") { 578 } else { 1538 }
const O_WRITE_CREATE: i64 = if (@targetOs() == "linux") { 577 } else { 1537 }

// Seek whence
const SEEK_SET: i64 = 0
const SEEK_CUR: i64 = 1
const SEEK_END: i64 = 2

struct File {
    fd: i64,
}

impl File {
    fn read(self: File, buf: i64, len: i64) FsError!i64 {
        var result = fd_read(self.fd, buf, len)
        if (result < 0) { return error.IoError }
        return result
    }

    fn write(self: File, buf: i64, len: i64) FsError!i64 {
        var result = fd_write(self.fd, buf, len)
        if (result < 0) { return error.IoError }
        return result
    }

    fn writeAll(self: File, s: string) FsError!i64 {
        var result = fd_write(self.fd, @ptrOf(s), @lenOf(s))
        if (result < 0) { return error.IoError }
        return result
    }

    fn seekTo(self: File, pos: i64) FsError!i64 {
        var result = fd_seek(self.fd, pos, 0)
        if (result < 0) { return error.IoError }
        return result
    }

    fn seekBy(self: File, delta: i64) FsError!i64 {
        var result = fd_seek(self.fd, delta, 1)
        if (result < 0) { return error.IoError }
        return result
    }

    fn getPos(self: File) FsError!i64 {
        var result = fd_seek(self.fd, 0, 1)
        if (result < 0) { return error.IoError }
        return result
    }

    fn close(self: File) void {
        fd_close(self.fd)
    }

    fn isValid(self: File) i64 {
        if (self.fd >= 0) { return 1 }
        return 0
    }
}

fn openFile(path: string, flags: i64) File {
    var fd = fd_open(@ptrOf(path), @lenOf(path), flags)
    return File { .fd = fd }
}

fn createFile(path: string) File {
    return openFile(path, O_WRITE_CREATE)
}

// Well-known file descriptors (Zig: std.io.getStdIn/Out/Err)
fn stdin() File { return File { .fd = 0 } }
fn stdout() File { return File { .fd = 1 } }
fn stderr() File { return File { .fd = 2 } }

// ===== High-level APIs =====
// Reference: Zig std.fs.cwd().openFile() returns OpenError!File

// openFileChecked returns error union — use for explicit error handling.
fn openFileChecked(path: string, flags: i64) FsError!File {
    var fd = fd_open(@ptrOf(path), @lenOf(path), flags)
    if (fd < 0) { return error.NotFound }
    return File { .fd = fd }
}

fn readFile(path: string) FsError!string {
    var fd = fd_open(@ptrOf(path), @lenOf(path), O_RDONLY)
    if (fd < 0) { return error.NotFound }
    var size = fd_seek(fd, 0, 2)
    fd_seek(fd, 0, 0)
    if (size <= 0) {
        fd_close(fd)
        return error.IoError
    }
    var buf = alloc(0, size)
    var n = fd_read(fd, buf, size)
    fd_close(fd)
    if (n < 0) {
        dealloc(buf)
        return error.IoError
    }
    return @string(buf, n)
}

fn writeFile(path: string, data: string) FsError!void {
    var fd = fd_open(@ptrOf(path), @lenOf(path), O_CREATE)
    if (fd < 0) { return error.NotFound }
    var n = fd_write(fd, @ptrOf(data), @lenOf(data))
    fd_close(fd)
    if (n < 0) { return error.IoError }
}
