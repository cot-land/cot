// io — Buffered I/O.
//
// Wraps raw fd reads/writes with user-space buffering.
// Reference: Go bufio (bufio.go lines 32-700)
//
// Uses heap-allocated state (like json.cot) to avoid struct decomposition
// issues with methods on large structs + compound params.

import "std/string"

// BufferedReader layout (5 * 8 = 40 bytes):
//   +0:  fd (i64)
//   +8:  buf (i64 — pointer to @alloc'd buffer)
//   +16: rd (i64 — read position)
//   +24: wr (i64 — write position / valid data end)
//   +32: buf_size (i64 — buffer capacity)

fn newBufferedReader(fd: i64) i64 {
    return newBufferedReaderSize(fd, 4096)
}

fn newBufferedReaderSize(fd: i64, size: i64) i64 {
    var p = @alloc(40)
    @intToPtr(*i64, p).* = fd
    @intToPtr(*i64, p + 8).* = @alloc(size)
    @intToPtr(*i64, p + 16).* = 0
    @intToPtr(*i64, p + 24).* = 0
    @intToPtr(*i64, p + 32).* = size
    return p
}

// Go bufio.go:99 — slide unread data to front, then syscall read
fn readerFill(r: i64) void {
    var buf = @intToPtr(*i64, r + 8).*
    var rd = @intToPtr(*i64, r + 16).*
    var wr = @intToPtr(*i64, r + 24).*
    var buf_size = @intToPtr(*i64, r + 32).*

    // Slide unread data to front
    if (rd > 0) {
        var unread = wr - rd
        if (unread > 0) {
            @memcpy(buf, buf + rd, unread)
        }
        wr = unread
        rd = 0
        @intToPtr(*i64, r + 16).* = rd
        @intToPtr(*i64, r + 24).* = wr
    }
    // Buffer full — caller must consume
    if (wr >= buf_size) { return }
    // Read from fd
    var fd = @intToPtr(*i64, r).*
    var n = @fd_read(fd, buf + wr, buf_size - wr)
    if (n > 0) {
        @intToPtr(*i64, r + 24).* = wr + n
    }
}

// Go bufio.go:267 — single byte or -1 for EOF
fn readByte(r: i64) i64 {
    var rd = @intToPtr(*i64, r + 16).*
    var wr = @intToPtr(*i64, r + 24).*
    if (rd >= wr) {
        readerFill(r)
        rd = @intToPtr(*i64, r + 16).*
        wr = @intToPtr(*i64, r + 24).*
        if (rd >= wr) { return 0 - 1 }
    }
    var buf = @intToPtr(*i64, r + 8).*
    var c = @intToPtr(*u8, buf + rd).*
    @intToPtr(*i64, r + 16).* = rd + 1
    return c
}

// Go bufio.go:405 — scan for \n, return line without newline.
// Empty string (len 0) signals EOF.
fn readLine(r: i64) string {
    var sb = StringBuilder { .buf = 0, .len = 0, .cap = 0 }
    var have_prefix: i64 = 0

    var searching: i64 = 1
    while (searching == 1) {
        var buf = @intToPtr(*i64, r + 8).*
        var rd = @intToPtr(*i64, r + 16).*
        var wr = @intToPtr(*i64, r + 24).*

        // Scan current buffer for \n
        var i = rd
        while (i < wr) {
            var c = @intToPtr(*u8, buf + i).*
            if (c == 10) {
                // Found \n at position i
                var line_len = i - rd
                if (have_prefix == 1) {
                    if (line_len > 0) {
                        sb.append(@string(buf + rd, line_len))
                    }
                    @intToPtr(*i64, r + 16).* = i + 1
                    var result = sb.toString()
                    return result
                }
                // Simple case: no prefix accumulated
                var line = @string(buf + rd, line_len)
                @intToPtr(*i64, r + 16).* = i + 1
                return line
            }
            i = i + 1
        }

        // No \n found — save what we have and fill more
        var chunk_len = wr - rd
        if (chunk_len > 0) {
            sb.append(@string(buf + rd, chunk_len))
            have_prefix = 1
            @intToPtr(*i64, r + 16).* = wr
        }

        readerFill(r)
        var new_rd = @intToPtr(*i64, r + 16).*
        var new_wr = @intToPtr(*i64, r + 24).*
        if (new_rd >= new_wr) {
            searching = 0
        }
    }

    // EOF: return accumulated data (or empty for true EOF)
    if (have_prefix == 1) {
        var result = sb.toString()
        return result
    }
    return ""
}

// ============================================================================
// BufferedWriter
// ============================================================================

// BufferedWriter layout (4 * 8 = 32 bytes):
//   +0:  fd (i64)
//   +8:  buf (i64 — pointer to @alloc'd buffer)
//   +16: wr (i64 — bytes buffered)
//   +24: buf_size (i64 — buffer capacity)

fn newBufferedWriter(fd: i64) i64 {
    return newBufferedWriterSize(fd, 4096)
}

fn newBufferedWriterSize(fd: i64, size: i64) i64 {
    var p = @alloc(32)
    @intToPtr(*i64, p).* = fd
    @intToPtr(*i64, p + 8).* = @alloc(size)
    @intToPtr(*i64, p + 16).* = 0
    @intToPtr(*i64, p + 24).* = size
    return p
}

// Go bufio.go:635 — write buffered data to fd
fn writerFlush(w: i64) void {
    var wr = @intToPtr(*i64, w + 16).*
    if (wr > 0) {
        var fd = @intToPtr(*i64, w).*
        var buf = @intToPtr(*i64, w + 8).*
        @fd_write(fd, buf, wr)
        @intToPtr(*i64, w + 16).* = 0
    }
}

fn writeByte(w: i64, b: i64) void {
    var wr = @intToPtr(*i64, w + 16).*
    var buf_size = @intToPtr(*i64, w + 24).*
    if (wr >= buf_size) {
        writerFlush(w)
        wr = 0
    }
    var buf = @intToPtr(*i64, w + 8).*
    var p = @intToPtr(*u8, buf + wr)
    p.* = @intCast(u8, b)
    @intToPtr(*i64, w + 16).* = wr + 1
}

// Go bufio.go:672
fn writeString(w: i64, s: string) void {
    var slen = @lenOf(s)
    if (slen == 0) { return }
    var wr = @intToPtr(*i64, w + 16).*
    var buf_size = @intToPtr(*i64, w + 24).*
    var buf = @intToPtr(*i64, w + 8).*
    var avail = buf_size - wr
    if (slen <= avail) {
        @memcpy(buf + wr, @ptrOf(s), slen)
        @intToPtr(*i64, w + 16).* = wr + slen
        return
    }
    // Flush, then write directly if still too big
    writerFlush(w)
    if (slen >= buf_size) {
        var fd = @intToPtr(*i64, w).*
        @fd_write(fd, @ptrOf(s), slen)
        return
    }
    // Now it fits (wr was reset to 0 by flush)
    @memcpy(buf, @ptrOf(s), slen)
    @intToPtr(*i64, w + 16).* = slen
}

fn writerWriteAll(w: i64, ptr: i64, len: i64) void {
    if (len == 0) { return }
    var wr = @intToPtr(*i64, w + 16).*
    var buf_size = @intToPtr(*i64, w + 24).*
    var buf = @intToPtr(*i64, w + 8).*
    var avail = buf_size - wr
    if (len <= avail) {
        @memcpy(buf + wr, ptr, len)
        @intToPtr(*i64, w + 16).* = wr + len
        return
    }
    writerFlush(w)
    if (len >= buf_size) {
        var fd = @intToPtr(*i64, w).*
        @fd_write(fd, ptr, len)
        return
    }
    @memcpy(buf, ptr, len)
    @intToPtr(*i64, w + 16).* = len
}
